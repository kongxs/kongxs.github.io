{"meta":{"title":"师学","subtitle":"学而不思则罔，思而不学则殆。","description":null,"author":"师学","url":"http://wanke.fun","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2024-03-12T01:06:15.818Z","updated":"2024-03-12T01:06:15.818Z","comments":false,"path":"/404.html","permalink":"http://wanke.fun/404.html","excerpt":"","text":""},{"title":"关于","date":"2018-12-11T06:33:46.000Z","updated":"2024-03-12T01:06:15.830Z","comments":false,"path":"about/index.html","permalink":"http://wanke.fun/about/index.html","excerpt":"","text":"Email :18810504552@163.com Github: http://www.github.com/kongxs CSDN: https://blog.csdn.net/u010405231/ www.pianku.tv www.pianyuan.la > 三十功名尘与土，八千里路云和月。莫等闲、白了少年头，空悲切。"},{"title":"categories","date":"2018-12-11T06:33:31.000Z","updated":"2024-03-12T01:06:15.830Z","comments":false,"path":"categories/index.html","permalink":"http://wanke.fun/categories/index.html","excerpt":"","text":""},{"title":"jiu","date":"2020-02-22T11:32:16.000Z","updated":"2024-03-12T01:06:15.865Z","comments":true,"path":"jiu/index.html","permalink":"http://wanke.fun/jiu/index.html","excerpt":"","text":"白酒 酱香型 红花郎10 53° 习酒 金质、银质 53° 赖茅传承蓝 53° 茅台王子酱香经典 53° 茅台王子黑金 53° 茅台汉酱 51° 茅台王子珍品 浓香型 百年牛栏山 53° 五粮春 45° 泸州老窖特曲 52° 剑南春水晶剑 52° 清香型 老白汾10 53° 黄盖玻汾 53° 汾酒青花20 53° 兼香型 白云边15 42° 凤香型 华山论剑20 52° 西凤6年 15年 馥郁香型 紫酒鬼"},{"title":"友情链接","date":"2021-06-09T08:14:58.000Z","updated":"2024-03-12T01:06:15.865Z","comments":true,"path":"links/index.html","permalink":"http://wanke.fun/links/index.html","excerpt":"","text":""},{"title":"search","date":"2021-06-06T10:47:13.000Z","updated":"2024-03-12T01:06:15.865Z","comments":true,"path":"search/index.html","permalink":"http://wanke.fun/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-11T06:33:06.000Z","updated":"2024-03-12T01:06:15.865Z","comments":false,"path":"tags/index.html","permalink":"http://wanke.fun/tags/index.html","excerpt":"","text":""},{"title":"","date":"2024-03-12T01:06:15.866Z","updated":"2024-03-12T01:06:15.866Z","comments":false,"path":"top/index.html","permalink":"http://wanke.fun/top/index.html","excerpt":"","text":"AV.initialize(\"Ub2Nt2JHX7JQ9ju5K04snK3v-gzGzoHsz\", \"f6QEi1FylzxYNU3R8KXicCGS\"); var time=0 var title=\"\" var url=\"\" var query = new AV.Query('Counter'); query.notEqualTo('id',0); query.descending('time'); query.limit(1000); query.find().then(function (todo) { for (var i=0;i"}],"posts":[{"title":"手游SDK打包问题记录","slug":"手游SDK打包问题记录","date":"2024-01-18T01:56:00.000Z","updated":"2024-03-12T01:06:15.828Z","comments":true,"path":"手游SDK/手游SDK打包问题记录/","link":"","permalink":"http://wanke.fun/%E6%89%8B%E6%B8%B8SDK/%E6%89%8B%E6%B8%B8SDK%E6%89%93%E5%8C%85%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"","text":"Assets目录及apktool.yml1. assets目录的资源缺失当打包将.jar转化为smail的时候要将源码进行转化，还要处理资源文件，所将jar里面的非class资源抽出来处理。 2. unknown目录的生成在jar包里除了assets资源外，还可能会有其他文件比如文本文件 *.txt 等.查看apk信息和反编译后的apk文件，可以看到对应关系。 以上，需要在 apktool.yml文件中写入复制到unknow 文件夹的信息 3. !!brut.androlib.meta.MetaInfo不同版本apktool工具发现打包工具用的是2.3.3版本的，但是电脑配置环境变量apktool版本是2.0.1的版本，然后手动回编译时，老是报错：“could not determine a constructor for the tag ‘tag:yaml.org,2002:brut.androlib.meta.MetaInfo’”。才发现高版本的的apktool工具在生成apktool.yml文件时，自动在第一行上添加了这个字段，再用版本回编译的时候报错。如果反编译和回编译用的版本都是一样的就没有这个问题。 4. brut.androlib.AndrolibException: brut.common.BrutException: could not exec游戏包体资源放到assets目录太多，在回编译成apk包体时，无法编译。在apktool.yml处理下doNotCompress 字段下的字符串数字限制导致的(windows 命令行支持的字符串长度有限制，不超过8191个字符)。 为兼容apktool版本，在回编译时修改设置过滤规则修改apktool.yml文件下的doNotCompress字段。 5. libs目录合并保证渠道提供的.so资源文件在游戏包体对应的armeabi&#x2F;armeabi-v7a&#x2F;x86等目录下都保持一致。不然会导致部分机型crash 6. res目录合并渠道提供的资源目录结构与游戏反编译后的目录结构不一致问题。通常在新建安卓工程的时候，res目录的资源包大多是drawable、drawable-hdpi、drawable-xhdpi、values、values-hdpi等形式。但是反编译之后你就发现游戏的目录格式不一样： 如果游戏资源已经存在了资源文件，当拷贝渠道的资源后，回编译时，会提示资源重复，为了处理这个问题，在合并资源文件的时候，就需提前判断反编译后的目录结构。拷贝到对应的资源文件中。 7. res目录下values目录下arrays.xml&#x2F;colors.xml&#x2F;demens.xml&#x2F;strings.xml资源丢失拷贝完渠道res资源之后，渠道的资源同名资源会覆盖掉游戏反编译后原有的资源来保证资源是渠道的最新版本，但是需要注意的是values目录下arrays.xml&#x2F;colors.xml&#x2F;demens.xml&#x2F;strings.xml的资源丢失问题，因为游戏apk包反编译后的资源信息都打包到这几个文件里面了，覆盖后，找不到对应的资源会导致各种问题，所以需要针对这几个资源文件做合并处理。 8. 坑点三：res目录下values&#x2F;values-hdpi等目录下values.xml、values-hdpi.xml等资源冲突个别渠道的res&#x2F;values目录下提供的是values.xml、values-hdpi.xml的复合资源文件，将资源属性都定义到里面，values.xml准确来说就是arrays.xml&#x2F;colors.xml&#x2F;demens.xml&#x2F;strings.xml等的结合体： 其实在处理arrays.xml&#x2F;colors.xml&#x2F;demens.xml&#x2F;strings.xml资源的时候，并没有处理掉values.xml资源，后面在生成R文件的时候就会提示资源冲突了。需要先将values.xml转化为arrays.xml&#x2F;colors.xml&#x2F;demens.xml&#x2F;strings.xml等文件。 9. 坑点四：Error parsing XML: duplicate attribute 资源属性名称重复定义res目录下values&#x2F;values-hdpi等目录下，渠道的资源属性和游戏的资源属性重复定义，比如，游戏已定义了app_name这个字段，但是渠道资源里面也定义了这个字段。这类的处理是将渠道定义的属性去掉。 10. apktool无法识别compileSdkVersion 、compileSdkVersionCodename在实际操作过程中发现个别游戏包体反编译后，Manifest文件中有compileSdkVersion 、compileSdkVersionCodename这两个字段，即使下载了最新版本的apktool工具也无法识别。这个是因为游戏编译生成apk包时设置编译版本为compileSdkVersion &#x3D; 28 才会生成的。这里需要额外处理下将compileSdkVersion 、compileSdkVersionCodename字段去掉。 但是在个别包体发现，单单去掉还不行，需将targetSdkVersion设置为23以上才不会异常。 11. aapt停止运行一般是资源文件或是xml文件中有错误造成的。比如： 发现在反编译包体后，生成的资源文件有问题，发现在布局xml中都自动生成了n1这个字段。 最终定位的原因是模拟游戏母包的apk包是Android Studio3.0 Build Apks 生成包体，classpath ‘com.android.tools.build:gradle:3.0.0’ 生成的包体反编译后都会这样，可以通过将gradle版本设置：classpath ‘com.android.tools.build:gradle:2.3.3’ 就没有该问题出现 12. 第三方库通过R.xxx引用资源导致资源找不到问题。这个问题很典型的案例就是个别第三方渠道引用了v7库，v7库里面的res资源是通过R.xxx引用的。在最终打出来的包体资源只会跟当前包名有关，为解决类似这种需要指定包名的问题，可以生成多个R文件的思路解决。 PS：这里有个点：生成的R文件除了包名不一致外，资源的ID都是一样的。不知道会不会有问题。 12. xml.etree import ElementTree as ET 解析xml文件出现 ns0:xxx错误在解析文件之前需将在parse前一定要设置namespace，类似Manifest需添加下面代码。 1ET.register_namespace(&#x27;android&#x27;, &quot;http://schemas.android.com/apk/res/android&quot;)","categories":[{"name":"手游SDK","slug":"手游SDK","permalink":"http://wanke.fun/categories/%E6%89%8B%E6%B8%B8SDK/"}],"tags":[],"author":"师学"},{"title":"手游SDK打包核心流程","slug":"手游SDK打包核心流程","date":"2024-01-16T03:57:00.000Z","updated":"2024-03-12T01:06:15.828Z","comments":true,"path":"uncategorized/手游SDK打包核心流程/","link":"","permalink":"http://wanke.fun/uncategorized/%E6%89%8B%E6%B8%B8SDK%E6%89%93%E5%8C%85%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/","excerpt":"","text":"这里分三部分：游戏母包game.apk 、渠道资源包、自动化打包系统。 游戏母包：接入聚合SDK，对接统一化接口，走通整体SDK的登录、支付、数据上报交互逻辑的游戏包体。 渠道资源包：整合了中间层和业务层SDK。 打包系统：输入游戏母包和渠道资源包后，自动化解包、合并资源、封包，最终输出游戏_渠道包。 整个过程由打包系统进行。 输入游戏母包和SDK(为了代码安全建议使用 ProGuard 工具对代码混淆) 使用apktools 对游戏母包进行反编译 java -jar */apktool.jar d -o *.apk ./dir -f --only-main-classes 将SDK资源拷贝到反编译后的对应文件夹 合并manifest文件 使用aapt工具编译资源生成R文件 并 打包成 jar 生成R文件 aapt p -f -m -J res目录 -I android.jar -M AndroidManifest.xml javac -source 1.7 -target 1.7 -encoding UTF-8 *&#x2F;R.java jar cvf */R.jar * 将SDK下所有的源码和引用的jar包转化成smali并拷贝到母包的smali目录 jar 2 dex dx.jar --dex --output=./r.dex ./R.jar dex 2 smali java -jar baksmali.jar -o ./smali ./r.dex 使用apktools回编译成apk文件 java -jar apktool.jar b ./dir -o unsign.apk sign &amp; zipalign jarsigner -verbose -keystore *.keystore -storepass 密码 -keypass 密码 -signedjar sign.apk unsign.apk 别名","categories":[],"tags":[],"author":"师学"},{"title":"手游SDK插件加载流程设计","slug":"手游SDK-设计实现","date":"2024-01-13T09:57:00.000Z","updated":"2024-03-12T01:06:15.828Z","comments":true,"path":"手游SDK/手游SDK-设计实现/","link":"","permalink":"http://wanke.fun/%E6%89%8B%E6%B8%B8SDK/%E6%89%8B%E6%B8%B8SDK-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"整个项目结构上分为4层。 其中game.apk由cp提供并直接集成聚合sdk进行初始化，登录，支付等流程打通。 聚合SDK负责查找和加载三方插件进行流程分发。 中间层SDK直接引用聚合SDK以及业务SDK，实现插件加载规范，并做业务隔离。 以初始化为例，整个流程如下，其他诸如login，pay等流程类似。 在整个流程上，由于游戏apk里面是没有中间层和业务sdk层代码的，所以需要我们反编译游戏apk进行二次打包实现。 插件加载流程设计首先解决聚合SDK如何查找并加载插件的问题，由于聚合SDK和业务SDK并没有直接的发生联系，并且在游戏集成聚合SDK打包的过程中，其实是没有中间层SDK以及业务SDK存在的。 初始化聚合SDK新增接口Channel 12345678910public Interface Channel &#123; void init(final Activity activity); void login(final Activity activity); void pay(final OrderInfo orderInfo, final Activity activity); ···&#125; 在聚合SDK进行初始化的时候去assets目录通过查找配置文件的方式，找到Channel实现类中间层SDK在assets目录增加配置文件 plugins.xml 12class implements Channel &#123;&#125; 1234&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;UTF-8&#x27;?&gt;&lt;plugins&gt; &lt;plugin name=&quot;fu.wanke.MyChannel&quot;/&gt;&lt;/plugins&gt; 聚合SDK初始化，去assets查找plugins.xml文件并解析出我们的Channel实现，后续的init，pay等流程就由MyChannel接管。 那么问题又来了，游戏只集成了聚合SDK，游戏包并没有中间层SDK以及plugins.xml呢。这就涉及到另外一个实现机制了，反编译 &amp; 重打包 。 拿到游戏母包(集成了聚合SDK的apk)以后，我们将母包进行反编译，然后把我们聚合SDK和业务SDK通过打包流程，把smali和资源进行整合到母包中，然后再重编译，签名，安装，测试，发布。","categories":[{"name":"手游SDK","slug":"手游SDK","permalink":"http://wanke.fun/categories/%E6%89%8B%E6%B8%B8SDK/"}],"tags":[],"author":"师学"},{"title":"手游SDK-开篇","slug":"手游SDK-开篇","date":"2024-01-09T06:33:00.000Z","updated":"2024-03-12T01:06:15.828Z","comments":true,"path":"手游SDK/手游SDK-开篇/","link":"","permalink":"http://wanke.fun/%E6%89%8B%E6%B8%B8SDK/%E6%89%8B%E6%B8%B8SDK-%E5%BC%80%E7%AF%87/","excerpt":"","text":"这段时间一直在负责做手游SDK的设计实现以及手游自动化打包方面的开发。其中涉及到手游SDK结构设计以及编码，游戏反编译，重打包，python 等。算是一个记录以及自己这段时间的工作成果总结。 在手游行业通常有三个比较重要的角色 游戏自研商 游戏发行商 游戏渠道商。 通常游戏自研商更多专注的做游戏产品的研发；游戏发行商更多的负责游戏的发行和运营；游戏渠道商更多的是上线游戏产品做推广。 我们现做的属于长尾渠道商并且拥有自己的SDK、用户、支付 等体系进行手游联运。 整体架构设计分为四部分：游戏母包、聚合壳SDK、业务SDK、打包平台几部分。 游戏母包由上游的渠道商或者手游研发公司提供并且集成我们的聚合SDK，打通了登录支付等系列流程。 聚合SDK规范了接口以及通信流程，作为业务SDK和游戏母包通信的桥梁 业务SDK作为真正的业务实现部分，承载了我们渠道所有的具体业务实现包括用户体系，支付体系，数据追踪，营销活动等 打包平台负责将业务SDK和游戏母包进行融合，主要是反编译以及apk重编译的一个过程 为了更好的理解手游整体架构，借图。 主要集中在三方plugin渠道","categories":[{"name":"手游SDK","slug":"手游SDK","permalink":"http://wanke.fun/categories/%E6%89%8B%E6%B8%B8SDK/"}],"tags":[],"author":"师学"},{"title":"爬虫:阿里系token-acw_sc__v2","slug":"爬虫-阿里系token-acw-sc-v2","date":"2023-12-29T13:41:00.000Z","updated":"2024-03-12T01:06:15.828Z","comments":true,"path":"爬虫/爬虫-阿里系token-acw-sc-v2/","link":"","permalink":"http://wanke.fun/%E7%88%AC%E8%99%AB/%E7%88%AC%E8%99%AB-%E9%98%BF%E9%87%8C%E7%B3%BBtoken-acw-sc-v2/","excerpt":"","text":"阿里系token在请求时候回携带key为acw_sc__v2的cookie，前程无忧，36kr，雪球 acw_sc__v2 为两次请求生成，头一次接口返回一段js文件生成cookie，二次请求时候携带此cookie即可 以前程无忧搜索职位接口（job&#x2F;search-pc）为例。点击2处，就可以进入一段js代码，就是加密cookie生成逻辑。 扣取关键代码并还原封装成 getToken函数： 123456789101112131415161718192021222324252627282930313233343536373839String[&quot;prototype&quot;][&quot;hexXor&quot;] = function(_0x4e08d8) &#123; var _0x5a5d3b = &#x27;&#x27;; for (var _0xe89588 = 0x0; _0xe89588 &lt; this[&#x27;length&#x27;] &amp;&amp; _0xe89588 &lt; _0x4e08d8[&#x27;length&#x27;]; _0xe89588 += 0x2) &#123; var _0x401af1 = parseInt(this[&quot;slice&quot;](_0xe89588, _0xe89588 + 0x2), 0x10); var _0x105f59 = parseInt(_0x4e08d8[&#x27;slice&#x27;](_0xe89588, _0xe89588 + 0x2), 0x10); var _0x189e2c = (_0x401af1 ^ _0x105f59)[&#x27;toString&#x27;](0x10); if (_0x189e2c[&quot;length&quot;] == 0x1) &#123; _0x189e2c = &#x27;\\x30&#x27; + _0x189e2c; &#125; _0x5a5d3b += _0x189e2c; &#125; return _0x5a5d3b; &#125;;String[&#x27;prototype&#x27;][&#x27;unsbox&#x27;] = function() &#123; var _0x4b082b = [0xf, 0x23, 0x1d, 0x18, 0x21, 0x10, 0x1, 0x26, 0xa, 0x9, 0x13, 0x1f, 0x28, 0x1b, 0x16, 0x17, 0x19, 0xd, 0x6, 0xb, 0x27, 0x12, 0x14, 0x8, 0xe, 0x15, 0x20, 0x1a, 0x2, 0x1e, 0x7, 0x4, 0x11, 0x5, 0x3, 0x1c, 0x22, 0x25, 0xc, 0x24]; var _0x4da0dc = []; var _0x12605e = &#x27;&#x27;; for (var _0x20a7bf = 0x0; _0x20a7bf &lt; this[&#x27;length&#x27;]; _0x20a7bf++) &#123; var _0x385ee3 = this[_0x20a7bf]; for (var _0x217721 = 0x0; _0x217721 &lt; _0x4b082b[&#x27;length&#x27;]; _0x217721++) &#123; if (_0x4b082b[_0x217721] == _0x20a7bf + 0x1) &#123; _0x4da0dc[_0x217721] = _0x385ee3; &#125; &#125; &#125; _0x12605e = _0x4da0dc[&#x27;join&#x27;](&#x27;&#x27;); return _0x12605e; &#125;;let _0x5e8b26 = &quot;3000176000856006061501533003690027800375&quot;;function getToken(arg1) &#123; var _0x23a392 = arg1[&#x27;unsbox&#x27;](); arg2 = _0x23a392[&#x27;hexXor&#x27;](_0x5e8b26); return arg2&#125;","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://wanke.fun/categories/%E7%88%AC%E8%99%AB/"}],"tags":[],"author":"师学"},{"title":"爬虫：webpack扣取酷我音乐reqid和secret","slug":"爬虫：webpack扣取酷我音乐reqid和secret","date":"2023-12-21T13:02:00.000Z","updated":"2024-03-12T01:06:15.828Z","comments":true,"path":"爬虫/爬虫：webpack扣取酷我音乐reqid和secret/","link":"","permalink":"http://wanke.fun/%E7%88%AC%E8%99%AB/%E7%88%AC%E8%99%AB%EF%BC%9Awebpack%E6%89%A3%E5%8F%96%E9%85%B7%E6%88%91%E9%9F%B3%E4%B9%90reqid%E5%92%8Csecret/","excerpt":"","text":"酷我音乐排行榜接口 排行榜入参有一个字段reqid。 猜测 有可能是前置接口返回 本地生成 首先复制reqid的值进行搜索无果，猜测1pass。继续搜索reqId定位到js文件,在来源面板中打开进行搜索js文件，通过断点定位到reqId的生成位置 n = c()() reqId = n 通过观察我们可以看到webpack打包的js。找到c的声明处 打印n.n找到声明处，将webpack代码全部扣取保存 补全 window 声明 test对象，并将n复制给test 由以上代码分析得： 1234l = test(109)c = test.n(l)let req_id = result = c()();console.log(req_id) 运行代码提示缺少109模块，继续扣代码.依次扣取了204，205生成 reqid secret的获取同理继续扣取模块代码，发现执行逻辑定位到了document.cookies上。猜测是前置接口返回","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://wanke.fun/categories/%E7%88%AC%E8%99%AB/"}],"tags":[],"author":"师学"},{"title":"爬虫:非标准json数据的解析","slug":"爬虫-非标准json数据的解析","date":"2023-12-20T13:49:00.000Z","updated":"2024-03-12T01:06:15.828Z","comments":true,"path":"爬虫/爬虫-非标准json数据的解析/","link":"","permalink":"http://wanke.fun/%E7%88%AC%E8%99%AB/%E7%88%AC%E8%99%AB-%E9%9D%9E%E6%A0%87%E5%87%86json%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A7%A3%E6%9E%90/","excerpt":"","text":"yaml 是json的超级大类，可以解析非正常的json数据。 data = &#39;&#39;&#39; &#123; name: &#39;青南&#39;, salary: 999999999, address: &#39;上海&#39;, pro: true &#125; &#39;&#39;&#39; 12345678from ruamel.yaml import YAML# json.load(data)yaml = YAML(typ=&#x27;rt&#x27;)yaml_load = yaml.load(data)print(yaml_load)","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://wanke.fun/categories/%E7%88%AC%E8%99%AB/"}],"tags":[],"author":"师学"},{"title":"爬虫:5s盾的破解-cookie破解","slug":"爬虫-5s盾的破解-cookie破解","date":"2023-12-20T13:10:00.000Z","updated":"2024-03-12T01:06:15.828Z","comments":true,"path":"爬虫/爬虫-5s盾的破解-cookie破解/","link":"","permalink":"http://wanke.fun/%E7%88%AC%E8%99%AB/%E7%88%AC%E8%99%AB-5s%E7%9B%BE%E7%9A%84%E7%A0%B4%E8%A7%A3-cookie%E7%A0%B4%E8%A7%A3/","excerpt":"","text":"爬取与反爬。cookie机制，5s盾机制 TLS 指纹现在绝大多数的网站都已经使用了 HTTPS，要建立 HTTPS 链接，服务器和客户端之间首先要进行 TLS 握手，在握手过程中交换双方支持的 TLS 版本，加密算法等信息。不同的客户端之间的差异 很大，而且一般这些信息还都是稳定的，所以服务端就可以根据 TLS 的握手信息来作为特征，识别 一个请求是普通的用户浏览器访问，还是来自 Python 脚本等的自动化访问。 JA3 是生成 TLS 指纹的一个常用算法。它的工作原理也很简单，大概就是把以上特征拼接并求 md5。 cookie 机制破解首次请求会拉取一段js代码等，生成cookie。结合抓包工具可以看到首次拉取的代码进行破解或者cookie生成规则，有动态和静态两种需要区分对待。在后续的请求中携带头次生成的cookie即可 CloudFlare 5s盾 免费版破解curl_cffi 破解设备指纹1234567from curl_cffi import requests# 注意这个 impersonate 参数，指定了模拟哪个浏览器r = requests.get(&quot;https://tls.browserleaks.com/json&quot;, impersonate=&quot;chrome101&quot;)print(r.json())# output: &#123;&#x27;ja3_hash&#x27;: &#x27;53ff64ddf993ca882b70e1c82af5da49&#x27; cloudscraper 破解123import cloudscraperscraper = cloudscraper.create_scraper()resp = scraper.get(&#x27;目标网站&#x27;).text CloudFlare 5s盾 付费版 破解使用Docker容器 1234567docker run -d \\ --name=flaresolverr \\ -p 8191:8191 \\ -e LOG_LEVEL=info \\ --restart unless-stopped \\ ghcr.io/flaresolverr/flaresolverr:latest 这个容器启动以后，会开启8191端口。我们通过往这个端口发送http请求，让他转发请求给目标网站，就可以绕过五秒盾。关键原因就在这个项目中：FlareSolverr 123456789101112131415161718import requestsimport jsonurl = &quot;http://localhost:8191/v1&quot;payload = json.dumps(&#123; &quot;cmd&quot;: &quot;request.get&quot;, &quot;url&quot;: &quot;https://www.coinbase.com/ventures/content&quot;, &quot;maxTimeout&quot;: 60000&#125;)headers = &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27;&#125;response = requests.post(url, headers=headers, data=payload)# 这个Docker镜像启动的接口，返回的数据是JOSN，网页源代码在其中的.solution.response中print(response.json()[&#x27;solution&#x27;][&#x27;response&#x27;])","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://wanke.fun/categories/%E7%88%AC%E8%99%AB/"}],"tags":[],"author":"师学"},{"title":"爬虫：某音乐JavaScript加密破解","slug":"爬虫：某音乐JavaScript加密破解","date":"2023-12-19T14:34:00.000Z","updated":"2024-03-12T01:06:15.829Z","comments":true,"path":"爬虫/爬虫：某音乐JavaScript加密破解/","link":"","permalink":"http://wanke.fun/%E7%88%AC%E8%99%AB/%E7%88%AC%E8%99%AB%EF%BC%9A%E6%9F%90%E9%9F%B3%E4%B9%90JavaScript%E5%8A%A0%E5%AF%86%E7%A0%B4%E8%A7%A3/","excerpt":"","text":"分析查找 js文件查找 本地替换详见 某音乐python批量下载 hookwebsocket方式 js页面。首先在需要调用的函数处，找到适当位置可以调用到要hook的函数，插入如下代码12345678910111213141516window.ws = new WebSocket(&#x27;ws://127.0.0.1:10086/ws&#x27;); //连接成功时执行 ws.onopen = function () &#123; console.log(&#x27;browser started&#x27;) // ws.send(d(&quot;hello&quot;)) &#125;; // 收到服务端消息时执行 ws.onmessage = function (evt) &#123; //这里调用要执行的js函数，然后将返回结果给服务端 var retult = d(evt.data) console.log(&quot;send : &quot;+retult) ws.send(d(retult)); &#125; 服务端启用python websocket服务器建立链接。即可调用 sekiro rpc方式sekiro ipc 的使用 扣取js代码并利用python 加载js 本地执行扣取js代码放到本地执行，利用python execjs库进行加载 12345678910with open(&quot;.js&quot;,&quot;r&quot;) as f: read = f.read()#记载js代码ctx = execjs.compile(read)param = &#x27;&#x27;#执行 encryption 函数result = ctx.call(&quot;encryption&quot;, param)print(result)","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://wanke.fun/categories/%E7%88%AC%E8%99%AB/"}],"tags":[],"author":"师学"},{"title":"爬虫：某音乐python批量下载","slug":"爬虫：某音乐python批量下载","date":"2023-12-18T14:29:00.000Z","updated":"2024-03-12T01:06:15.829Z","comments":true,"path":"爬虫/爬虫：某音乐python批量下载/","link":"","permalink":"http://wanke.fun/%E7%88%AC%E8%99%AB/%E7%88%AC%E8%99%AB%EF%BC%9A%E6%9F%90%E9%9F%B3%E4%B9%90python%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD/","excerpt":"","text":"本文仅做技术交流学习使用，严禁一切商业或者其他用途，否则带来的后果由当事人自己承担。python实现 某狗子音乐批量下载。 python 3.11 以为搜索为例 https://www.kugou.com/yy/html/search.html#searchType=song&searchKeyWord=%E5%91%A8%E6%9D%B0%E4%BC%A6 在本页面可以看到排行榜歌曲，比如 周杰伦-晴天 接口抓取 打开控制台 刷新网页 找到网络面板和搜索按钮 在搜索按钮找关键字【晴天】 寻找并定位到接口位置如图： 接口分析 接口处右键复制链接地址得到信息： https://complexsearch.kugou.com/v2/search/song?callback=callback123&amp;srcappid=2919&amp;clientver=1000&amp;clienttime=1702885903212&amp;mid=1c8f9939584a8e35ed5d8e5510b845fe&amp;uuid=1c8f9939584a8e35ed5d8e5510b845fe&amp;dfid=1txNPf3JNHSk05LR6l3Upjvi&amp;keyword=%E5%91%A8%E6%9D%B0%E4%BC%A6&amp;page=1&amp;pagesize=30&amp;bitrate=0&amp;isfuzzy=0&amp;inputtype=0&amp;platform=WebFilter&amp;userid=0&amp;iscorrection=1&amp;privilege_filter=0&amp;filter=10&amp;token=&amp;appid=1014&amp;signature=461cd68d2aee31af3b9a163205848891 载荷和标头页面可以看到次网络请求的param和header 分析网络请求发现只有几处是变动的，其中 signature 字段看起来是需要动态计算 js逆向获取加密函数 继续搜索关键字signature，分析并定位到此字段生成处。取值为d函数对s字符串进行加密所得 右键选择在来源面板中打开。 断点调试 获取param：s的值，并进行md5加密测试。发现经过d函数运算和我们对s参数加密得到的结果一致 。 知识简单md5加密，并没有进行加盐等操作。 代码组织 经过以上分析，我们拿到了音乐的搜索接口 https://complexsearch.kugou.com/v2/search/song 并且对此接口的入参有了一定的了解。 准备好url和header 123456789 url = &quot;https://complexsearch.kugou.com/v2/search/song&quot;header = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36&#x27;, &quot;Referer&quot;: &quot;https://www.kugou.com/&quot; &#125; 构造签名 md5动态签名得到signature字段，其中每次只有歌手名和时间戳两个字段变化 123456789101112131415161718192021222324252627 def get_sign(name,req_time): value = ( &quot;NVPh5oo715z5DIWAeQlhMDsWXXQV4hwt&quot; &quot;appid=1014&quot; &quot;bitrate=0&quot; &quot;callback=callback123&quot; f&quot;clienttime=&#123;req_time&#125;&quot; &quot;clientver=1000&quot; &quot;dfid=1txNPf3JNHSk05LR6l3Upjvi&quot; &quot;filter=10&quot; &quot;inputtype=0&quot; &quot;iscorrection=1&quot; &quot;isfuzzy=0&quot; f&quot;keyword=&#123;name&#125;&quot; &quot;mid=1c8f9939584a8e35ed5d8e5510b845fe&quot; &quot;page=1&quot; &quot;pagesize=30&quot; &quot;platform=WebFilter&quot; &quot;privilege_filter=0&quot; &quot;srcappid=2919&quot; &quot;token=&quot; &quot;userid=0&quot; &quot;uuid=1c8f9939584a8e35ed5d8e5510b845fe&quot; &quot;NVPh5oo715z5DIWAeQlhMDsWXXQV4hwt&quot; ) return hashlib.md5(value.encode(encoding=&quot;UTF-8&quot;)).hexdigest() 构造params分析：每次搜索接口请求只有 时间戳，歌手名，签名三个字段可变123456789101112131415161718192021222324def getParams(time,name,sign) : return &#123; &quot;callback&quot;:&quot;callback123&quot;, &quot;srcappid&quot;:&quot;2919&quot;, &quot;clientver&quot;:&quot;1000&quot;, &quot;clienttime&quot;:f&quot;&#123;time&#125;&quot;, &quot;mid&quot;:&quot;1c8f9939584a8e35ed5d8e5510b845fe&quot;, &quot;uuid&quot;:&quot;1c8f9939584a8e35ed5d8e5510b845fe&quot;, &quot;dfid&quot;:&quot;1txNPf3JNHSk05LR6l3Upjvi&quot;, &quot;keyword&quot;:f&quot;&#123;name&#125;&quot;, &quot;page&quot;:&quot;1&quot;, &quot;pagesize&quot;:&quot;30&quot;, &quot;bitrate&quot;:&quot;0&quot;, &quot;isfuzzy&quot;:&quot;0&quot;, &quot;inputtype&quot;:&quot;0&quot;, &quot;platform&quot;:&quot;WebFilter&quot;, &quot;userid&quot;:&quot;0&quot;, &quot;iscorrection&quot;:&quot;1&quot;, &quot;privilege_filter&quot;:&quot;0&quot;, &quot;filter&quot;:&quot;10&quot;, &quot;token&quot;:&quot;&quot;, &quot;appid&quot;:&quot;1014&quot;, &quot;signature&quot;:f&quot;&#123;sign&#125;&quot; &#125; 发送请求 我们以搜索周杰伦歌曲为例12345678910 SINGER_NAME=&quot;周杰伦&quot;req_time = int(time.time() * 1000)singer_name = SINGER_NAMEsign = get_sign(SINGER_NAME,req_time)params = getParams(req_time, SINGER_NAME, sign)r = requests.get(url, headers=header, params=params)r.encoding = &#x27;utf-8&#x27;content = r.contentprint(content)","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://wanke.fun/categories/%E7%88%AC%E8%99%AB/"}],"tags":[],"author":"师学"},{"title":"sekiro-ipc的使用","slug":"sekiro-ipc-的使用","date":"2023-12-18T13:56:00.000Z","updated":"2024-03-12T01:06:15.827Z","comments":true,"path":"爬虫/sekiro-ipc-的使用/","link":"","permalink":"http://wanke.fun/%E7%88%AC%E8%99%AB/sekiro-ipc-%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"doc https://sekiro.iinti.cn/sekiro-doc/ 使用sekiro ipc 框架完成js的逆向代理工作 。 sekiro环境配置 需要java 1.8以上并配置java_home 下载服务，https://oss.iinti.cn/sekiro/sekiro-demo/ 解压并运行&#x2F;bin下的可执行文件 备用服务地址 访问：http://127.0.0.1:5612/business-demo/groupList 返回以下json就说明服务启动成功了 12&#123;&quot;data&quot;:[&quot;ws-group&quot;],&quot;ok&quot;:true,&quot;status&quot;:0&#125; 注意端口号： 默认5612 可在&#x2F;conf&#x2F;config.properties 查看修改 浏览器注入js同样需要注意端口号一致。可在console控制台输入，也可通过油猴使用 代码注入后访问 http://127.0.0.1:5612/business-demo/invoke?group=ws-group&amp;action=clientTime 如果返回一下结果代表成功 12345&#123;&quot;clientId&quot;: &quot;dd60a2e0-2d51-f177-158b-0c849ebf4e77&quot;,&quot;data&quot;: &quot;Mon Dec 18 2023 18:16:04 GMT+0800 (中国标准时间)&quot;,&quot;status&quot;: 0&#125; 脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222// ==UserScript==// @name New Userscript// @namespace http://tampermonkey.net/// @version 2023-12-18// @description try to take over the world!// @author You// @match https://www.kugou.com/yy/rank/home/1-8888.html?from=rank// @icon https://www.google.com/s2/favicons?sz=64&amp;domain=kugou.com// @grant none// ==/UserScript==function SekiroClient(wsURL) &#123; this.wsURL = wsURL; this.handlers = &#123;&#125;; this.socket = &#123;&#125;; // check if (!wsURL) &#123; throw new Error(&#x27;wsURL can not be empty!!&#x27;) &#125; this.webSocketFactory = this.resolveWebSocketFactory(); this.connect()&#125;SekiroClient.prototype.resolveWebSocketFactory = function () &#123; if (typeof window === &#x27;object&#x27;) &#123; var theWebSocket = window.WebSocket ? window.WebSocket : window.MozWebSocket; return function (wsURL) &#123; function WindowWebSocketWrapper(wsURL) &#123; this.mSocket = new theWebSocket(wsURL); &#125; WindowWebSocketWrapper.prototype.close = function () &#123; this.mSocket.close(); &#125;; WindowWebSocketWrapper.prototype.onmessage = function (onMessageFunction) &#123; this.mSocket.onmessage = onMessageFunction; &#125;; WindowWebSocketWrapper.prototype.onopen = function (onOpenFunction) &#123; this.mSocket.onopen = onOpenFunction; &#125;; WindowWebSocketWrapper.prototype.onclose = function (onCloseFunction) &#123; this.mSocket.onclose = onCloseFunction; &#125;; WindowWebSocketWrapper.prototype.send = function (message) &#123; this.mSocket.send(message); &#125;; return new WindowWebSocketWrapper(wsURL); &#125; &#125; if (typeof weex === &#x27;object&#x27;) &#123; // this is weex env : https://weex.apache.org/zh/docs/modules/websockets.html try &#123; console.log(&quot;test webSocket for weex&quot;); var ws = weex.requireModule(&#x27;webSocket&#x27;); console.log(&quot;find webSocket for weex:&quot; + ws); return function (wsURL) &#123; try &#123; ws.close(); &#125; catch (e) &#123; &#125; ws.WebSocket(wsURL, &#x27;&#x27;); return ws; &#125; &#125; catch (e) &#123; console.log(e); //ignore &#125; &#125; //TODO support ReactNative if (typeof WebSocket === &#x27;object&#x27;) &#123; return function (wsURL) &#123; return new theWebSocket(wsURL); &#125; &#125; // weex 鍜� PC鐜鐨剋ebsocket API涓嶅畬鍏ㄤ竴鑷达紝鎵€浠ュ仛浜嗘娊璞″吋瀹� throw new Error(&quot;the js environment do not support websocket&quot;);&#125;;SekiroClient.prototype.connect = function () &#123; console.log(&#x27;sekiro: begin of connect to wsURL: &#x27; + this.wsURL); var _this = this; // 涓峜heck close锛岃 // if (this.socket &amp;&amp; this.socket.readyState === 1) &#123; // this.socket.close(); // &#125; try &#123; this.socket = this.webSocketFactory(this.wsURL); &#125; catch (e) &#123; console.log(&quot;sekiro: create connection failed,reconnect after 2s&quot;); setTimeout(function () &#123; _this.connect() &#125;, 2000) &#125; this.socket.onmessage(function (event) &#123; _this.handleSekiroRequest(event.data) &#125;); this.socket.onopen(function (event) &#123; console.log(&#x27;sekiro: open a sekiro client connection&#x27;) &#125;); this.socket.onclose(function (event) &#123; console.log(&#x27;sekiro: disconnected ,reconnection after 2s&#x27;); setTimeout(function () &#123; _this.connect() &#125;, 2000) &#125;);&#125;;SekiroClient.prototype.handleSekiroRequest = function (requestJson) &#123; console.log(&quot;receive sekiro request: &quot; + requestJson); var request = JSON.parse(requestJson); var seq = request[&#x27;__sekiro_seq__&#x27;]; if (!request[&#x27;action&#x27;]) &#123; this.sendFailed(seq, &#x27;need request param &#123;action&#125;&#x27;); return &#125; var action = request[&#x27;action&#x27;]; if (!this.handlers[action]) &#123; this.sendFailed(seq, &#x27;no action handler: &#x27; + action + &#x27; defined&#x27;); return &#125; var theHandler = this.handlers[action]; var _this = this; try &#123; theHandler(request, function (response) &#123; try &#123; _this.sendSuccess(seq, response) &#125; catch (e) &#123; _this.sendFailed(seq, &quot;e:&quot; + e); &#125; &#125;, function (errorMessage) &#123; _this.sendFailed(seq, errorMessage) &#125;) &#125; catch (e) &#123; console.log(&quot;error: &quot; + e); _this.sendFailed(seq, &quot;:&quot; + e); &#125;&#125;;SekiroClient.prototype.sendSuccess = function (seq, response) &#123; var responseJson; if (typeof response == &#x27;string&#x27;) &#123; try &#123; responseJson = JSON.parse(response); &#125; catch (e) &#123; responseJson = &#123;&#125;; responseJson[&#x27;data&#x27;] = response; &#125; &#125; else if (typeof response == &#x27;object&#x27;) &#123; responseJson = response; &#125; else &#123; responseJson = &#123;&#125;; responseJson[&#x27;data&#x27;] = response; &#125; if (Array.isArray(responseJson)) &#123; responseJson = &#123; data: responseJson, code: 0 &#125; &#125; if (responseJson[&#x27;code&#x27;]) &#123; responseJson[&#x27;code&#x27;] = 0; &#125; else if (responseJson[&#x27;status&#x27;]) &#123; responseJson[&#x27;status&#x27;] = 0; &#125; else &#123; responseJson[&#x27;status&#x27;] = 0; &#125; responseJson[&#x27;__sekiro_seq__&#x27;] = seq; var responseText = JSON.stringify(responseJson); console.log(&quot;response :&quot; + responseText); this.socket.send(responseText);&#125;;SekiroClient.prototype.sendFailed = function (seq, errorMessage) &#123; if (typeof errorMessage != &#x27;string&#x27;) &#123; errorMessage = JSON.stringify(errorMessage); &#125; var responseJson = &#123;&#125;; responseJson[&#x27;message&#x27;] = errorMessage; responseJson[&#x27;status&#x27;] = -1; responseJson[&#x27;__sekiro_seq__&#x27;] = seq; var responseText = JSON.stringify(responseJson); console.log(&quot;sekiro: response :&quot; + responseText); this.socket.send(responseText)&#125;;SekiroClient.prototype.registerAction = function (action, handler) &#123; if (typeof action !== &#x27;string&#x27;) &#123; throw new Error(&quot;an action must be string&quot;); &#125; if (typeof handler !== &#x27;function&#x27;) &#123; throw new Error(&quot;a handler must be function&quot;); &#125; console.log(&quot;sekiro: register action: &quot; + action); this.handlers[action] = handler; return this;&#125;;function guid() &#123; function S4() &#123; return (((1+Math.random())*0x10000)|0).toString(16).substring(1); &#125; return (S4()+S4()+&quot;-&quot;+S4()+&quot;-&quot;+S4()+&quot;-&quot;+S4()+&quot;-&quot;+S4()+S4()+S4());&#125;var client = new SekiroClient(&quot;ws://127.0.0.1:5612/business-demo/register?group=ws-group&amp;clientId=&quot;+guid());client.registerAction(&quot;clientTime&quot;,function(request, resolve,reject )&#123; resolve(&quot;&quot;+new Date());&#125;) 使用新建html文件如下. 需在此页面进行注入 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://file.virjar.com/sekiro_web_client.js?_=123&quot;&gt;&lt;/script&gt; &lt;script&gt;function b64(arg) &#123; return btoa(arg)&#125; // 生成唯一标记uuid编号function guid() &#123; function S4() &#123; return (((1+Math.random())*0x10000)|0).toString(16).substring(1); &#125; return (S4()+S4()+&quot;-&quot;+S4()+&quot;-&quot;+S4()+&quot;-&quot;+S4()+&quot;-&quot;+S4()+S4()+S4());&#125;// 连接服务端var client = new SekiroClient(&quot;ws://127.0.0.1:5612/business-demo/register?group=ws-group&amp;clientId=&quot;+guid());// 业务接口client.registerAction(&quot;demo&quot;,function(request, resolve, reject)&#123; data = request[&#x27;page&#x27;] console.log(data,&#x27;记号&#x27;) resolve(&quot;我是Forever&quot;+new Date());&#125;) client.registerAction(&quot;demo1&quot;,function(request, resolve, reject)&#123; data = request[&#x27;pwd&#x27;] res = b64(data) resolve(res);&#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 接收注入的结果以python为例 sekiro支持多种语言可根据需要使用。 12345678import requestsdata = &#123;&quot;group&quot;: &quot;ws-group&quot;, &quot;action&quot;: &quot;demo&quot;, &quot;page&quot;: 10 &#125;res = requests.get(&quot;http://127.0.0.1:5610/business-demo/invoke&quot;,params=data )print(res.text) 线上注入 找到需要注入的js文件进行本地覆盖保存。 将上面的脚本文件在文件中写入 在原函数的调用处进行要hook的函数回调123456client.registerAction(&quot;demo&quot;,function(request, resolve, reject)&#123; var data = request[&#x27;page&#x27;] console.log(data,&#x27;记号&#x27;) var value = d(data) resolve(&quot;kugou: &quot;+value); &#125;);","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://wanke.fun/categories/%E7%88%AC%E8%99%AB/"}],"tags":[],"author":"师学"},{"title":"关于mitmdump","slug":"关于mitmdump","date":"2023-12-17T11:32:00.000Z","updated":"2024-03-12T01:06:15.827Z","comments":true,"path":"爬虫/关于mitmdump/","link":"","permalink":"http://wanke.fun/%E7%88%AC%E8%99%AB/%E5%85%B3%E4%BA%8Emitmdump/","excerpt":"","text":"mitmweb ： 功能强大的，python支持的网络请求抓包代理工具 不需要安装软件，直接在线（浏览器）进行抓包（包括手机端和PC端） 配合Python脚本抓包改包 抓包过程的所有数据包都可以自动保留到txt里面，方便过滤分析 使用相对简单，易上手。 环境python Python 2.7.18 mitmweb 安装，根据python环境选择了如下版本号。1pip install &quot;mitmproxy==0.18.2&quot; 启动mitmweb 指定端口号1mitmweb -p 8989 控制台输出Server listening at http://127.0.0.1:8081 代表启动成功。 在浏览器打开即可。 保存抓包日志 将网络请求保存到指定文件1mitmdump -p 8889 -w *.txt 使用python脚本抓取网络请求1mitmweb -p 8889 -s *.py 脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940from mitmproxy import ctx# 所有发出的请求数据包都会被这个方法所处理# 所谓的处理，我们这里只是打印一下一些项；当然可以修改这些项的值直接给这些项赋值即可def request(flow): # 获取请求对象 request = flow.request # 实例化输出类 info = ctx.log.info # 打印请求的url info(request.url) # 打印请求方法 info(request.method) # 打印host头 info(request.host) # 打印请求端口 info(str(request.port)) # 打印所有请求头部 info(str(request.headers)) # 打印cookie头 info(str(request.cookies))# 所有服务器响应的数据包都会被这个方法处理# 所谓的处理，我们这里只是打印一下一些项def response(flow): # 获取响应对象 response = flow.response # 实例化输出类 info = ctx.log.info # 打印响应码 info(str(response.status_code)) # 打印所有头部 info(str(response.headers)) # 打印cookie头部 info(str(response.cookies)) # 打印响应报文内容 info(str(response.text))","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://wanke.fun/categories/%E7%88%AC%E8%99%AB/"}],"tags":[],"author":"师学"},{"title":"java方式实现自定义plugin","slug":"java方式实现自定义plugin","date":"2023-12-07T05:31:00.000Z","updated":"2024-03-12T01:06:15.826Z","comments":true,"path":"Gradle/java方式实现自定义plugin/","link":"","permalink":"http://wanke.fun/Gradle/java%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89plugin/","excerpt":"","text":"接前文 gradle自定义plugin的几种方式 属于 groovy语言实现。这次记录java实现的方式 新建java porject在build.gradle接入插件 12apply plugin: &#x27;java-gradle-plugin&#x27;apply plugin: &#x27;maven-publish&#x27; 依赖 123dependencies &#123; implementation &quot;com.android.tools.build:gradle:4.1.3&quot;&#125; 声明插件实现 123456789gradlePlugin &#123; plugins &#123; shadow &#123; id = &quot;shadow.plugin&quot;//别的工程通过apply plugin引入的id //继承自Plugin的class，入口类 implementationClass = &quot;fu.wanke.plugin.MyClass&quot; &#125; &#125;&#125; 本地发布 12345678910111213141516171819202122publishing &#123; repositories &#123; maven &#123; // $rootDir 表示你项目的根目录 // 这里配置发布到的本地目录 url = &quot;$rootDir/repo&quot; &#125; &#125; publications &#123; maven(MavenPublication) &#123; // 插件的组ID，建议设置为插件的包名 groupId = &#x27;fu.wanke.plugin&#x27; // 插件的名字，后续在引用时会用到 artifactId = &#x27;shadPlugin&#x27; version = &#x27;1.0.0&#x27; // 组件类型 from components.java &#125; &#125;&#125; 配置完成通过命令 .&#x2F;gradlew publish 即可发布插件到本地仓库 使用： 项目根目录的build.gradle文件引入本地仓库： 12345678910111213141516171819buildscript &#123; repositories &#123; google() jcenter() maven &#123;// 添加Maven的本地依赖 url uri(&#x27;./repo&#x27;) &#125; &#125; dependencies &#123; //我们自定义的插件 classpath &quot;fu.wanke.plugin:shadPlugin:1.0.0&quot; classpath &quot;com.android.tools.build:gradle:4.1.3&quot; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125; 在项目的build.gradle文件里面引入插件1apply plugin: &#x27;shadow.plugin&#x27;","categories":[{"name":"Gradle","slug":"Gradle","permalink":"http://wanke.fun/categories/Gradle/"}],"tags":[],"author":"师学"},{"title":"frida动态调试环境搭建","slug":"frida动态调试环境搭建","date":"2023-11-27T06:37:34.000Z","updated":"2024-03-12T01:06:15.825Z","comments":true,"path":"uncategorized/frida动态调试环境搭建/","link":"","permalink":"http://wanke.fun/uncategorized/frida%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"环境搭建https://github.com/frida/frida/releases pycharm python: 3.11.5 frida-server: frida-server-16.1.7-android-arm64.xz 模拟器 android 8 root server端: 先将frida-server-16.1.7-android-arm64.xz解压得到frida文件 adb push frida &#x2F;data&#x2F;local&#x2F;tmp adb shell su cd &#x2F;data&#x2F;local&#x2F;tmp chmod 777 frida 运行.&#x2F;frida 以上搭配手机环境。重新换一个终端 进行端口转发 adb forward tcp:27042 jdwp:27042 adb forward tcp:27043 jdwp:27043 frida-ps -U 列出进程 adb shell ps 查看进程pid 加载脚本attach后可以写入进程名 com.xxx.xxx .如果提示找不到进程，可以使用pid 12345678910111213141516171819202122232425262728293031323334import frida # 导入frida模块import sys # 导入sys模块jscode = &quot;&quot;&quot; send(&#x27;script load ! &#x27;); Java.perform(function()&#123; send(&#x27; load into java ! &#x27;); var MainActivity = Java.use(&#x27;com.junxi.bizhewan.ui.game.detail.GameDetailActivity&#x27;); send(&#x27;MainActivity success !&#x27;); MainActivity.getMsg.implementation = function()&#123; send(&#x27;Statr! Hook!&#x27;); return &#x27;return hooked&#x27;; &#125; &#125;);&quot;&quot;&quot;def on_message(message, data): # js中执行send函数后要回调的函数 print(message)device = frida.get_remote_device()pid = device.spawn([&quot;com.junxi.bizhewan.sdkdemo&quot;])device.resume(pid)time.sleep(1)process = device.attach(pid) # 得到设备并劫持进程com.example.testfrida（该开始用get_usb_device函数用来获取设备，但是一直报错找不到设备，改用get_remote_device函数即可解决这个问题）script = process.create_script(jscode) # 创建js脚本script.on(&#x27;message&#x27;, on_message) # 加载回调函数，也就是js中执行send函数规定要执行的python函数script.load() # 加载脚本sys.stdin.read() 执行 python3 main.py 得保证frida-server正在运行，方法可以是在kali主机输入frida-ps -U命令，如果安卓机上的进程出现了，则frida-server运行良好。 还需要保证selinux是关闭的状态，可以在adb shell里，su -获得root权限之后，输入setenforce 0命令来获得，在Settings→About Phone→SELinux status里看到Permissive，说明selinux关闭成功。","categories":[],"tags":[],"author":"师学"},{"title":"Android连点器技术分析","slug":"Android模拟屏幕点击事件","date":"2023-11-23T01:46:23.000Z","updated":"2024-03-12T01:06:15.823Z","comments":true,"path":"uncategorized/Android模拟屏幕点击事件/","link":"","permalink":"http://wanke.fun/uncategorized/Android%E6%A8%A1%E6%8B%9F%E5%B1%8F%E5%B9%95%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"APP连点常用技术app外部控制 无障碍服务 AccessibilityService monkey框架 ADB控制 shell sendEvent 1234 eg：229就是menu的type值sendevent /dev/input/event0 1 229 1sendevent /dev/input/event0 1 229 0 这两句需要一起执行，因为一个点击事件包含down和up，不然不能执行操作 shell input tap 1adb shell input tap [x y] APP内部控制1. 通过Window注入MotionEvent123456789101112long downTime = SystemClock.uptimeMillis(); final MotionEvent downEvent = MotionEvent.obtain(downTime, downTime, MotionEvent.ACTION_DOWN, x, y, 0); downTime += 1000; MotionEvent upEvent = MotionEvent.obtain(downTime, downTime, MotionEvent.ACTION_UP, x, y, 0); getWindow().injectInputEvent(downEvent); getWindow().injectInputEvent(upEvent); 2 . Instrumentation 发送事件最大支持到android12 ，不受Activity限制，在任意屏幕可执行 123 对window有效 ，子线程调用 instrumentation.sendPointerSync(keyCode); 3 . getDecorView dispatchTouchEvent1针对window有效，无版本适配问题 连点器实现思路 找到需要注入点击事件的Activity 根视图添加空白的ViewGroup对touch点的拦截记录 最后对记录点进行点击模拟 兼容性测试1. window.injectInputEvent12android 13 mi10 android 14 模拟器 2. instrumentation.sendPointerSync123456android 6 模拟器android 9 vivo android 10 模拟器android 11 oppo android 12 模拟器 小7手游连点器分析 通过 window setCallback 进行事件分发的回调处理 构造MotionEvent 通过 window getDecorView dispatchTouchEvent 完成事件的分发 window getDecorView addView 添加连点器的画布FrameLayout，在frameLayout中完成画布的构建 android开发者工具app找到【执行】按钮所在布局的空间id，name 图1反编译apk，全局搜索使用到当前id的代码，因为当前空间可点击，重点关注onclick事件 图2step1：点击事件肯定是执行流程的开始，跟踪它。代码逻辑分支太多，发现PlanDetailBean里面保存了记录点和touch点 step2：看那些地方使用到这些点通过对recordEventList调用查询，定位到ensm#arsm，发现了MotionEvent，继续追踪此函数的调用方追踪到Window.Callback回调了dispatchTouchEvent。 通过给window添加callback实现了touch事件分发的拦截进行打点。 step3: 根据touchSpotList寻找无果，转变思路找cycleInterval 通过猜测是按钮点击的间隔，继续找， step4:定位到absm#alsm，此函数通过timer#schedule 执行定时任务，找到这个task，定位到absm#aosm函数有处理TouchSpotBean列表，猜测是点击点集合。追踪定位到bwsm#agsm,此函数有handler处理任务，定位到handleMessage，发现是不断循环的延迟任务处理自身。猜测：是执行定时点击的循环处理。 step5： 根据handleMessage定位到 absm#afsm ，发现有log输出坐标信息，打开手机运行游戏进行验证，right 图3 step6： 又根据logcat额外的信息定位到asm#asm，验证了图3的调用。此函数构造了MotionEvent，根据事件分发相关知识，关注此event如何被分发出去. 见图4 step7：this.asm.get().dispatchTouchEvent(obtain); 查看asm.get()是什么，发现asm.get在当前class构造函数被初始化,见图5 参考： Android代码模拟物理、屏幕点击事件阿里云android点击事件研究","categories":[],"tags":[],"author":"师学"},{"title":"bizhe","slug":"bizhe","date":"2023-10-27T03:08:00.000Z","updated":"2024-03-12T01:06:15.825Z","comments":true,"path":"bizhe/bizhe/","link":"","permalink":"http://wanke.fun/bizhe/bizhe/","excerpt":"","text":"比折APP schemebizhe:&#x2F;&#x2F;page&#x2F;param?jumpInfo&#x3D;{‘target’:’gift_package’,’params’:{‘gid’:’5158’}} bizhe:&#x2F;&#x2F;page&#x2F;param?jumpInfo&#x3D;{‘target’:’gift_package’,’params’:{‘gid’:’5158’}}&amp;traceid&#x3D;hello123 bizhe:&#x2F;&#x2F;page&#x2F;param?jumpInfo&#x3D;{‘target’:’gift_package’,’params’:{‘gid’:’5158’}}&amp;traceid&#x3D;hello456 消息中心 H5Game 抖音福利 快手福利 快手抖音跳转快手bizhewan001-3834578046 快手bizhewan002-2635564601 快手3848862866 抖音84628780429","categories":[{"name":"bizhe","slug":"bizhe","permalink":"http://wanke.fun/categories/bizhe/"}],"tags":[],"author":"师学"},{"title":"kotlin协程","slug":"kotlin协程","date":"2023-09-20T07:54:00.000Z","updated":"2024-03-12T01:06:15.827Z","comments":true,"path":"Kotlin/kotlin协程/","link":"","permalink":"http://wanke.fun/Kotlin/kotlin%E5%8D%8F%E7%A8%8B/","excerpt":"","text":"携程作用域123456789101112fun main() &#123; GlobalScope.launch &#123; println(&quot;scope start &quot;) delay(5000) println(&quot;scope end &quot;) &#125; println(&quot;bey &quot;)&#125;运行结果： bey Process finished with exit code 0 GlobalScope.launch会创建一个全局作用域的后台守护协程，它并不会阻塞当前线程。也就是说，在程序执行完毕，协程就消失了。如果我们想等待协程执行完毕再去关闭程序的话，可以通过获取GlobalScope.launch 返回值去调用join函数 123456789101112131415suspend fun main() &#123; var job = GlobalScope.launch &#123; println(&quot;scope start &quot;) delay(5000) println(&quot;scope end &quot;) &#125; job.join() println(&quot;bey &quot;)&#125;运行结果： scope start //停顿了5sscope end bey 以上等同于 runBlocking 12345678fun main() &#123; runBlocking &#123; println(&quot;block start &quot;) delay(5000) println(&quot;block end &quot;) &#125; println(&quot;bey &quot;)&#125; 等同于 coroutineScope创建 12345678suspend fun main() &#123; var job = coroutineScope &#123; println(&quot;coroutineScope start &quot;) delay(5000) println(&quot;coroutineScope end &quot;) &#125; println(&quot;bey&quot;)&#125; 等同于 withContext 12345678suspend fun main() &#123; var job = withContext(Dispatchers.IO) &#123; println(&quot;coroutineScope start &quot;) delay(5000) println(&quot;coroutineScope end &quot;) &#125; println(&quot;bey&quot;)&#125; 协程异步编程新建挂起函数 1234567891011suspend fun getMessageFromNet(requestName: String , times: Int) : String &#123; println(&quot;request: $requestName start ----- &quot;) delay(3000) withContext(Dispatchers.IO) &#123; println(&quot; net &quot;+ Thread.currentThread().name) (1..times).forEach &#123; &#125; &#125; return &quot;result for request $requestName&quot;&#125; 同步调用1234567891011121314fun main() = runBlocking &#123; Dispatchers.Main var result3 = getMessageFromNet(&quot;async1&quot; , 100000) var result4 = getMessageFromNet(&quot;async2&quot; , 800000) println(&quot;merge result $&#123;result3.toString()&#125; , $&#123;result4.toString()&#125;&quot;)&#125;运行结果： request: async1 start ----- net DefaultDispatcher-worker-1request: async2 start ----- net DefaultDispatcher-worker-1merge result result for request async1 , result for request async2在第一个getMessageFromNet函数返回结果以后才发起第二次调用。 异步调用123456789101112131415161718fun main() = runBlocking &#123; Dispatchers.Main var result3 = async &#123; getMessageFromNet(&quot;async1&quot; , 100000) &#125; var result4 = async &#123; getMessageFromNet(&quot;async2&quot; , 800000) &#125; val await = result3.await() val await1 = result4.await() println(&quot;merge result $&#123;await.toString()&#125; , $&#123;await1.toString()&#125;&quot;)&#125;运行结果： request: async1 start ----- request: async2 start ----- net DefaultDispatcher-worker-1 net DefaultDispatcher-worker-2merge result result for request async1 , result for request async2getMessageFromNet的第二次调用不必等待第一次的结果。","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://wanke.fun/categories/Kotlin/"}],"tags":[],"author":"师学"},{"title":"kotlin函数编程","slug":"kotlin函数编程","date":"2023-09-15T09:47:00.000Z","updated":"2024-03-12T01:06:15.827Z","comments":true,"path":"Kotlin/kotlin函数编程/","link":"","permalink":"http://wanke.fun/Kotlin/kotlin%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/","excerpt":"","text":"中缀infix 修饰的function ，只能是成员函数或者扩展函数 并且有一个参数 1234567891011121314class Test14 &#123; //只有一个参数的成员函数 ， 使用infix修饰 infix fun test(age : Int) &#123; &#125; fun test(age : Int , name: String) &#123; &#125;&#125;//扩展函数infix fun String.add(name: String) = this.plus(name)fun main() &#123; Test14() test 1 &quot;&quot; add &quot;&quot;&#125; 内联使用高阶函数会带来一些运行时的效率损失：每一个函数都是一个对象，并且会捕获一个闭包。 闭包那些在函数体内会访问到的变量的作用域。 内存分配（对于函数对象和类）和虚拟调用会引入运行时间开销。 但是在许多情况下通过内联化 lambda 表达式可以消除这类的开销。内联会把被调用处的函数体移植到调用处来 。 内联会使得包体积增大 12inline fun String.add(name: String) = this.plus(name) 带有接收者的函数字面值示例1 12var subtract : Int.(Int) -&gt; Int = &#123;this - it&#125;println(3.subtract(2)) 示例2 12345678910111213141516171819202122232425262728class People12&#123; var age: Int = 0 var name : String = &quot;&quot;&#125;fun test(block: (People12) -&gt; Unit) &#123; block(People12())&#125;//函数block的接受者就是 People12，类似于给People12添加了扩展函数的感觉fun test15(block: People12.() -&gt; Unit) &#123; People12().block()&#125;fun main() &#123; test &#123; people -&gt; people.name = &quot;&quot; people.age= 2 &#125; test15 &#123; age = 12 name = &quot;&quot; &#125;&#125;","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://wanke.fun/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://wanke.fun/tags/Kotlin/"}],"author":"师学"},{"title":"kotlin的一点知识","slug":"kotlin的一点知识","date":"2023-09-07T01:49:00.000Z","updated":"2024-03-12T01:06:15.827Z","comments":true,"path":"Kotlin/kotlin的一点知识/","link":"","permalink":"http://wanke.fun/Kotlin/kotlin%E7%9A%84%E4%B8%80%E7%82%B9%E7%9F%A5%E8%AF%86/","excerpt":"","text":"1. kotlin对象声明12345object Hello &#123; var age : Int = 0 fun sayHello() : Unit &#123; &#125;&#125; 对象生命可以看做是全局的静态函数 12kotlin中调用 ： Hello.sayHello()java中调用 ： Hello.Instance.sayHello() 通过反编译可以看到 , 所谓对象声明是在字节码底层，声明了当前class的实例，在static代码块中进行实例对象初始化 1234567public final class Hello &#123; public static final Hello INSTANCE; public final int getAge(); public final void sayHello(); static &#123;&#125;;&#125; kotlin伴生对象1234567891011class Hello4 &#123; var age : Int = 0 get() &#123;return field&#125; companion object &#123; fun test(): Unit&#123; &#125; &#125;&#125; 12345678910伴生对象字节码揭秘 public final class Hello4 &#123; public static final Hello4$Companion Companion; public Hello4(); public final int getAge(); public final void setAge(int); static &#123;&#125;;&#125; kotlin扩展函数1fun Hello.sayBey() = print(&quot;bey&quot;) 扩展函数回在声明了当前扩展函数的类中添加一个新的static函数,把被扩展的class当做参数传入 12字节码揭秘: public static final void sayBey(Hello); kotlin 内部类和嵌套类123456789101112131415class Outer &#123; var name : String = &quot;zhangsan&quot; class Nested &#123; fun test() &#123; &#125; &#125; inner class Inner &#123; fun test() &#123; this@Outer.name &#125; &#125;&#125; 看调用 1234fun main() &#123; Outer.Nested().test() Outer().Inner().test()&#125; 看字节码 ,区别在于inner修饰的class在内部会持有外部类的引用，类似于java的内部类。而嵌套类更类似于java中static修改的内部class 123456789101112public final class Outer$Inner &#123; final Outer this$0; public Outer$Inner(); public final void test();&#125;public final class Outer$Nested &#123; public Outer$Nested(); public final void test();&#125; kotlin 数据类和数据对象data修饰的object和class会在字节码底层增加field对应的set&#x2F;get函数。 hashCOde，toString，equals函数 1234567891011121314151617数据对象：data object DataObj &#123; lateinit var name : String &#125;对应字节码： public final class DataObj &#123; public static final DataObj INSTANCE; public static java.lang.String name; public final java.lang.String getName(); public final void setName(java.lang.String); public java.lang.String toString(); public int hashCode(); public boolean equals(java.lang.Object); static &#123;&#125;;&#125; 数据对象在字节码底部会声明当前object的实例 1234567891011121314数据类： 至少有一个构建参数data class DataClazz(val name: String)数据类字节码：public final class DataClazz &#123; public DataClazz(java.lang.String); public final java.lang.String getName(); public final java.lang.String component1(); public final DataClazz copy(java.lang.String); public static DataClazz copy$default(DataClazz, java.lang.String, int, java.lang.Object); public java.lang.String toString(); public int hashCode(); public boolean equals(java.lang.Object);&#125; kotlin类委托1234567891011121314interface ImageLoader&#123; fun load(url: String)&#125;class FresoLoader : ImageLoader &#123; override fun load(url: String) &#123; println(&quot;load $url with freso&quot;) &#125;&#125;class ImageLoaderEngine(imageLoader: ImageLoader) : ImageLoader by imageLoaderfun main() &#123; val engine = ImageLoaderEngine(FresoLoader()) engine.load(&quot;http:xx.png&quot;)&#125; 本质上，kotlin在设计层面提供了类似于java包装类的做法，在ImageLoaderEngine底层维持了传入的FresoLoader对象，并且在对应的函数里面使用FresoLoader去进行调用分发 kotlin属性委托123456789101112131415161718192021import kotlin.reflect.KPropertyimport Test10 as Test101class Test10 &#123; operator fun getValue(nothing: Nothing?, property: KProperty&lt;*&gt;): String &#123; println(&quot;getValue invoked&quot;) return &quot;&quot; &#125; operator fun setValue(nothing: Nothing?, property: KProperty&lt;*&gt;, s: String) &#123; println(&quot;setValue invoked&quot;) &#125;&#125;var name : String by Test101()var addr : String by Test101()fun main() &#123; name&#125; 在底层字节码回根据当前被委托属性的个数去维护一个 KProperty数组 1static final kotlin.reflect.KProperty&lt;java.lang.Object&gt;[] $$delegatedProperties; 用对应的委托对象，去代理到具体的实现类 kotlin 可观测委托12345678910//在value被修改以后，提供一个回调函数去进行观测var student : String by Delegates.observable(&quot;&quot;) &#123; prop ,oldValue ,newValue -&gt;&#125;//在字段的值被修改之前进行函数回调， true：修改，fanse： 不修改var student2 : String by Delegates.vetoable(&quot;&quot;) &#123; prop ,oldValue ,newValue -&gt; true&#125; kotlin 提供委托提供委托就是一个委托类的提供者，通过provideDelegate函数进行返回需要的 1234567891011121314151617181920212223242526272829303132class StrDelegate &#123; operator fun provideDelegate(thisRef: Test, property: KProperty&lt;*&gt;) : ReadWriteProperty&lt;Test , String&gt;&#123; return when(property.name) &#123; &quot;hello&quot; -&gt; Delegate1() else -&gt; Delegate2() &#125; &#125;&#125;class Delegate2 : ReadWriteProperty&lt;Test, String&gt; &#123; override fun getValue(thisRef: Test, property: KProperty&lt;*&gt;): String &#123; TODO(&quot;Not yet implemented&quot;) &#125; override fun setValue(thisRef: Test, property: KProperty&lt;*&gt;, value: String) &#123; TODO(&quot;Not yet implemented&quot;) &#125;&#125;class Delegate1 : ReadWriteProperty&lt;Test, String&gt; &#123; override fun getValue(thisRef: Test, property: KProperty&lt;*&gt;): String &#123; TODO(&quot;Not yet implemented&quot;) &#125; override fun setValue(thisRef: Test, property: KProperty&lt;*&gt;, value: String) &#123; TODO(&quot;Not yet implemented&quot;) &#125;&#125;class Test &#123; var student3 : String by StrDelegate()&#125;","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://wanke.fun/categories/Kotlin/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://wanke.fun/tags/kotlin/"}],"author":"师学"},{"title":"长链接心跳机制实现","slug":"socket_heart_beat","date":"2021-06-11T09:46:00.000Z","updated":"2024-03-12T01:06:15.827Z","comments":true,"path":"Android/socket_heart_beat/","link":"","permalink":"http://wanke.fun/Android/socket_heart_beat/","excerpt":"","text":"对于心跳包很多人误以为只是用来定期告诉服务端我们的状态，实际并非如此。 应用层维护心跳好处应用层维护心跳的好处自然是能够及时发现链路故障问题，尽早地建立新的连接进行故障转移。 比如客户端每隔3s通过长连接通道发送一个心跳请求到服务端，连续失败5次就断开连接。这样算下来最长15s就能发现连接已经不可用，一旦连接不可用，可以重连，也可以做其他的failover处理，比如请求其他服务器。 比如某台服务器因为某些原因导致负载超高，CPU飙高，或者线程池打满等等，无法响应任何业务请求，如果使用TCP自身的机制无法发现任何问题，然而对客户端而言，这时的最好选择就是断连后重新连接其他服务器，而不是一直认为当前服务器是可用状态，向当前服务器发送一些必然会失败的请求。 上面我们提到了 NAT 超时，即如果 App 一段时间内不活跃，会导致运营商那里删除我们的公网 IP 映射关系，这会导致我们的 TCP 长连接断开。因此，我们需要通过心跳机制来保证 App 的活跃度，防止发生 NAT 超时。 在线上运行时，长连接很有可能会由于网络切换之类的原因断开。这时，我们需要 尽快发现长连接断开，并 立即重连。一般有下面几种做法： 创建 Receiver，监控网络状态，如果网络发生切换则立即重连； 监控服务端心跳包回包，如果连续 5 次没有收到回包，则认为长连接已经失效； 设置心跳包超时限制，如果超过时间还没有收到心跳回包，则重连，这种方式比较耗电； 等 socket IO 异常抛出，不过耗时太长，需要 15s 左右才能发现。 固定心跳机制心跳机制主要是为了防止 NAT 超时，外网 IP 地址失效。因此，一般的做法就是在 NAT 失效前，保证有心跳包发出。或者说，客户端应当以略小于 NAT 超时时间的间隔来发送心跳包。 Mars 智能心跳策略在尽量不影响用户收消息及时性的前提下，根据网络类型自适应的找出保活信令 TCP 连接的尽可能大的心跳间隔，从而达到减少安卓APP因心跳引起的空中信道资源消耗，减少心跳 Server 的负载，以及减少部分因心跳引起的耗电。 自适应心跳在固定心跳机制下，动态的探测最大的 NAT 超时时间，然后选定合适的心跳间隔区间去发送心跳包。 当找到一个有效心跳间隔后，我们主动去加大这个间隔，然后测试是否能成功，如果不能，则使用比上一次成功间隔稍短的时间作为间隔；否则继续加大间隔，直到找到可用的有效间隔。 如何判断一个心跳间隔有效呢？方案是使用固定短心跳直到满足三次连续短心跳成功，则认为这个间隔有效。 探测过程大致为：60 秒短心跳，连续发 3 次后开始探测，90，120，150，180，210，240，270 前后台策略另外，考虑到 App 在前后台对于长连接的需求是不同的。因此当app在前台活跃态时，采用了 固定心跳机制；在前台熄屏态或者后台活跃态（进入后台 10 分钟内）时，先用几次最小心跳维持长连接，然后进入 自适应心跳机制；在后台稳定态（超过 10 分钟），则采用自适应心跳计算出来的最大心跳作为固定值。 如果在运行过程中，发生了心跳失败，则进行重连。同时将心跳间隔调整为断线前间隔减去 20s，重新走自适应心跳；如果连续 5 次均失败，则以初始心跳 180s 继续测试。 Alarm 对齐策略对于 Android 系统而言，为了减少频繁唤醒系统导致的电量损耗，提供了 Alarm 对齐唤醒 机制：把一定时间段内的多次 Alarm 唤醒合并成一次，减少系统被唤醒次数，增加待机时间。 而我们的心跳包就是需要在定时结束后自动触发一次心跳包的发送，因此，在 Mars 里面的心跳时间也是按照 Alarm 对齐时间来做心跳间隔，减少电量损耗。","categories":[{"name":"Android","slug":"Android","permalink":"http://wanke.fun/categories/Android/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://wanke.fun/tags/%E7%BD%91%E7%BB%9C/"}],"author":"师学"},{"title":"源码分析-multiDex","slug":"源码分析-multiDex","date":"2021-05-26T09:43:00.000Z","updated":"2024-03-12T01:06:15.828Z","comments":true,"path":"源码分析/Android/源码分析-multiDex/","link":"","permalink":"http://wanke.fun/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-multiDex/","excerpt":"","text":"概述MultiDex适用于API版本在4-20的Android系统 , 即Android 2.1 - 4.4 . 而在这些版本之间 , MultiDex会通过Application.getClassLoader进行加载. 而如果Dex比较多比较大的话 , 主线程加载Dex时间会很长 , 导致主线程ANR.由于Android 5.0之后使用ART虚拟机进行dex2oat , 将多dex在安装的时候将APK中多个Dex进行优化 , 优化过后生成一个ELF文件 , 名为.oat文件. 在加载后 , 会将oat文件直接映射到ART虚拟机中使用 , 这样就减少Dex加载的耗时.. MultiDex加载过程简述 读取APK的CRC32以及modifyTime进行校验 通过反射 , 从BaseDexClassLoader中找到pathList对象 通过反射调用PathList.makeDexElements创建Elements[] 通过反射将Elements[]添加到dexElements数组中 后续在该ClassLoader查找类到时候 , 会优先在dexElements中开始遍历查找 MultiDex加载过程MultiDex 123456789101112131415public static void install(Context context) &#123; if (IS_VM_MULTIDEX_CAPABLE) &#123; //VM版本大于2.1时，IS_VM_MULTIDEX_CAPABLE为true，这时候MultiDex.install什么也不用做，直接返回。因为大于2.1的VM会在安装应用的时候，就把多个dex合并到一块 &#125; else if (VERSION.SDK_INT &lt; 4) &#123; //Multi dex最小支持的SDK版本为4 throw new RuntimeException(&quot;Multi dex installation failed. SDK &quot; + VERSION.SDK_INT + &quot; is unsupported. Min SDK version is &quot; + 4 + &quot;.&quot;); &#125; else &#123; // 这里是重点逻辑 File dexDir = new File(e.dataDir, &quot;code_cache/secondary-dexes&quot;); //1. 把dex文件缓存到/data/data/&lt;packagename&gt;/code_cache/secondary-dexes/目录 List files = MultiDexExtractor.load(context, e, dexDir, false); //2. 安装所有的附属dex installSecondaryDexes(loader, dexDir, files); &#125;&#125; 执行文件拷贝工作 123456789MultiDexExtractor.load()&#123; try &#123; //从缓存目录中直接查找缓存文件，跳过解压 files = loadExistingExtractions(context, sourceApk, dexDir); &#125; catch (IOException var9) &#123; files = performExtractions(sourceApk, dexDir); putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + 1); &#125;&#125; 获取到所有的dex文件 123456789MultiDexExtractor.performExtractions() &#123; for (ZipEntry dexFile = apk.getEntry(&quot;classes&quot; + e + &quot;.dex&quot;); dexFile != null; dexFile = apk.getEntry(&quot;classes&quot; + e + &quot;.dex&quot;)) &#123; String fileName = extractedFilePrefix + e + &quot;.zip&quot;; File extractedFile = new File(dexDir, fileName); files.add(extractedFile); &#125;&#125; 1234567891011MultiDex.installSecondaryDexes() &#123; if (!files.isEmpty()) &#123; if (VERSION.SDK_INT &gt;= 19) &#123; MultiDex.V19.install(loader, files, dexDir); &#125; else if (VERSION.SDK_INT &gt;= 14) &#123; MultiDex.V14.install(loader, files, dexDir); &#125; else &#123; MultiDex.V4.install(loader, files); &#125; &#125;&#125; 1234567MultiDex.V14.install(loader, files, dexDir)&#123;Field pathListField = MultiDex.findField(loader, &quot;pathList&quot;); Object dexPathList = pathListField.get(loader); MultiDex.expandFieldArray(dexPathList, &quot;dexElements&quot;, makeDexElements(dexPathList, new ArrayList(additionalClassPathEntries), optimizedDirectory)); &#125; 1234567private static Object[] makeDexElements(Object dexPathList, ArrayList&lt;File&gt; files, File optimizedDirectory) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123; Method makeDexElements = MultiDex.findMethod(dexPathList, &quot;makeDexElements&quot;, new Class[]&#123;ArrayList.class, File.class&#125;); return (Object[]) ((Object[]) makeDexElements.invoke(dexPathList, new Object[]&#123;files, optimizedDirectory&#125;)); &#125; 1234567891011private static void expandFieldArray(Object instance, String fieldName, Object[] extraElements) throws NoSuchFieldException, IllegalArgumentException, IllegalAccessException &#123; Field jlrField = findField(instance, fieldName); Object[] original = (Object[]) ((Object[]) jlrField.get(instance)); Object[] combined = (Object[]) ((Object[]) Array.newInstance(original.getClass() .getComponentType(), original.length + extraElements.length)); System.arraycopy(original, 0, combined, 0, original.length); System.arraycopy(extraElements, 0, combined, original.length, extraElements.length); jlrField.set(instance, combined); &#125; Multidex的缺陷在冷启动时因为需要安装DEX文件，如果DEX文件过大时，处理时间过长，很容易引发ANR 解决方案 第一次启动的时候，检测到未曾加载过second dex，那么启动欢迎页面（启动新的进程，原来进程进入阻塞等待，注意，此时不会发生ANR，因为已经不是前台进程了），在欢迎页面里面进行second dex的加载，加载完成后通知主线程继续 设定单个dex文件最大方法数为48000（经验值）而不是65536，避免内存问题 控制程序逻辑，未曾加载完second dex之前，进入阻塞等待，直到加载完程序才往下走 123Application.attachBaseContext(Context context) &#123; loadMultiDex(context)&#125; 1234567891011121314151617private void loadMultiDex(Context context) &#123; newTempFile(context); //创建临时文件 //启动另一个进程去加载MultiDex Intent intent = new Intent(context, LoadMultiDexActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intent); //死循环 ，检查MultiDex是否安装完（安装完会删除临时文件） checkUntilLoadDexSuccess(context); //另一个进程以及加载 MultiDex，有缓存了，所以主进程再加载就很快了。 //为什么主进程要再加载，因为每个进程都有一个ClassLoader MultiDex.install(context); &#125; 1234LoadMultiDexActivity.onCreate() &#123; new thread().run&#123;loadMultiDex();&#125;&#125; 123456789101112loadMultiDex()&#123; //执行加载 MultiDex.install(LoadMultiDexActivity.this); //加载结束后,删除临时文件，application就可以继续执行了 deleteTempFile(this); //将这个进程杀死 Log.d(TAG, &quot;aftetMultiDex: &quot;); finish(); Process.killProcess(Process.myPid());&#125; 抖音BoostMultiDex优化实践","categories":[{"name":"源码分析","slug":"源码分析","permalink":"http://wanke.fun/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Android","slug":"源码分析/Android","permalink":"http://wanke.fun/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android/"}],"tags":[],"author":"师学"},{"title":"源码分析-leakCanary","slug":"源码分析-leakCanary","date":"2021-05-24T02:34:00.000Z","updated":"2024-03-12T01:06:15.828Z","comments":true,"path":"Android/源码分析/源码分析-leakCanary/","link":"","permalink":"http://wanke.fun/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-leakCanary/","excerpt":"","text":"前言 Reference 把内存分为 4 种状态，Active 、 Pending 、 Enqueued 、 Inactive 1234&gt;+ Active 一般说来内存一开始被分配的状态都是 Active&gt;+ Pending 快要放入队列（ReferenceQueue）的对象，也就是马上要回收的对象&gt;+ Enqueued 对象已经进入队列，已经被回收的对象。方便我们查询某个对象是否被回收&gt;+ Inactive 最终的状态，无法变成其他的状态 ReferenceQueue 引用队列，在 Reference 被回收的时候，Reference 会被添加到 ReferenceQueue 中 如何检测一个对象是否被回收 123创建一个引用队列 queue创建 Reference 对象（通常用弱引用）并关联引用队列在 Reference 被回收的时候，Reference 会被添加到 queue 中 12345ReferenceQueue queue = new ReferenceQueue(); WeakReference reference = new WeakReference(new Object(), queue); System.gc(); Reference reference1 = queue.remove(); 在 Reference 类加载的时候，Java 虚拟机会会创建一个最大优先级的后台线程，这个线程的工作就是不断检测 pending 是否为 null，如果不为 null，那么就将它放到 ReferenceQueue。因为 pending 不为 null，就说明引用所指向的对象已经被 GC，变成了不可达。 原理弱引用： 在垃圾回收时，无论内存是否充足，都会将弱引用包装的对象回收。 当JVM进行垃圾回收时，无论内存是否充足，如果该对象只有弱引用存在，那么该对象会被垃圾回收器回收，同时该引用会被加入到关联的ReferenceQueue。因此程序可以通过判断引用队列中是否已经包含指定的引用，来了解被引用的对象是否被GC回收 (引用队列中存在指定的弱引用，说明对象被回收)。 所以 Leakcanary 在进行内存泄露的监控时，利用弱引用的上述特性，在对象生命周期结束后主动gc并检查该对象的弱引用是否被回收，如果弱引用没有被正常回收，说明在对象生命周期结束以后，该对象还被其他对象持有他的非弱引用。该对象还有到达GC ROOTS的可达路径。如果在对象生命周期结束后弱引用不存在了，说明该对象已经被JVM的垃圾回收器正常回收了，该对象的内存空间也被正常回收。 监听 Activity 的生命周期。 在 onDestory 的时候，创建对应的 Actitity 的 Refrence 和 相应的 RefrenceQueue，启动后台进程去检测。 一段时间后，从 RefrenceQueue 中读取，如果有这个 Actitity 的 Refrence，那么说明这个 Activity 的 Refrence 已经被回收，但是如果 RefrenceQueue 没有这个 Actitity 的 Refrence 那就说明出现了内存泄漏。 dump 出 hprof 文件，找到泄漏路径。 生命周期监测onDestory 时候对activity进行监测 1234567891011121314151617// ActivityRefWatcher.classpublic static void install(@NonNull Context context, @NonNull RefWatcher refWatcher) &#123; Application application = (Application) context.getApplicationContext(); ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher); // 通过 Application 注册 Activity 生命周期回调接口。 application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);&#125;private final Application.ActivityLifecycleCallbacks lifecycleCallbacks = new ActivityLifecycleCallbacksAdapter() &#123; @Override public void onActivityDestroyed(Activity activity) &#123; // 在Activity 被销毁的时候去进行监听(Activity被销毁后，理应被回收，所以在这里触发监听操作)。 refWatcher.watch(activity); &#125; &#125;; 主线程空闲AndroidWatchExecutor 123456789private void waitForIdle(final Retryable retryable, final int failedAttempts) &#123; // This needs to be called from the main thread. Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() &#123; @Override public boolean queueIdle() &#123; postToBackgroundWithDelay(retryable, failedAttempts); return false; &#125; &#125;); &#125; 监测泄漏RefWatcher 123456789101112131415161718192021222324252627282930313233343536373839404142Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) &#123; long gcStartNanoTime = System.nanoTime(); long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime); // 1.先进行移除(可能这里已经发生过gc操作了) removeWeaklyReachableReferences(); // Debug 模式忽略 if (debuggerControl.isDebuggerAttached()) &#123; // The debugger can create false leaks. return RETRY; &#125; // 2.判断 retainedKeys 中是否存在指定的 key，gone()返回true 表示不存在。 if (gone(reference)) &#123; return DONE; &#125; // 3.前面表示指定的弱引用没有被回收，因此手动触发GC操作。 gcTrigger.runGc(); //内部触发 Runtime.getRuntime().gc() 操作，同时让当前线程sleep(100，给gc一段处理时间)。 // 4.与步骤1相同的操作 removeWeaklyReachableReferences(); // 5.如果gone()返回false，表示可能存在内存泄漏。 if (!gone(reference)) &#123; long startDumpHeap = System.nanoTime(); long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime); // 6.导出堆栈信息，内部其实会触发 Debug.dumpHprofData(heapDumpFile.getAbsolutePath()) 方法导出HProf文件。 File heapDumpFile = heapDumper.dumpHeap(); if (heapDumpFile == RETRY_LATER) &#123; // Could not dump the heap. return RETRY; &#125; long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap); // 7.将导出的信息封装成HeapDump对象 HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key) .referenceName(reference.name) .watchDurationMs(watchDurationMs) .gcDurationMs(gcDurationMs) .heapDumpDurationMs(heapDumpDurationMs) .build(); // 8.对HeapDump进行内存泄漏的分析 heapdumpListener.analyze(heapDump); // heapdumpListeners是ServiceHeapDumpListener类型 &#125; return DONE;&#125; 先进行移除(可能这里已经发生过gc操作了)。 判断 retainedKeys 中是否存在指定的 key，gone()返回true 表示不存在。 前面表示指定的弱引用没有被回收，因此手动触发GC操作。与步骤1相同的操作。 如果gone()返回false，表示可能存在内存泄漏。 导出堆栈信息，内部其实会触发 Debug.dumpHprofData(heapDumpFile.getAbsolutePath()) 方法导出HProf文件。 将导出的信息封装成HeapDump对象。 对HeapDump进行内存泄漏的分析。 在launcher的显示123456789&lt;activity android:theme=&quot;@style/leak_canary_LeakCanary.Base&quot; android:name=&quot;.internal.DisplayLeakActivity&quot; android:process=&quot;:leakcanary&quot; android:enabled=&quot;false&quot; android:label=&quot;@string/leak_canary_display_activity_label&quot; android:icon=&quot;@mipmap/leak_canary_icon&quot; android:taskAffinity=&quot;com.squareup.leakcanary.$&#123;applicationId&#125;&quot; &gt; 12345678public static void setEnabledBlocking(Context appContext, Class&lt;?&gt; componentClass, boolean enabled) &#123; ComponentName component = new ComponentName(appContext, componentClass); PackageManager packageManager = appContext.getPackageManager(); int newState = enabled ? COMPONENT_ENABLED_STATE_ENABLED : COMPONENT_ENABLED_STATE_DISABLED; // Blocks on IPC. packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP); &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://wanke.fun/categories/Android/"},{"name":"源码分析","slug":"Android/源码分析","permalink":"http://wanke.fun/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}],"tags":[],"author":"师学"},{"title":"源码分析-glide","slug":"源码分析-glide","date":"2021-05-21T06:59:00.000Z","updated":"2024-03-12T01:06:15.828Z","comments":true,"path":"Android/源码分析/源码分析-glide/","link":"","permalink":"http://wanke.fun/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-glide/","excerpt":"","text":"支持GIF，webP ，video 生命周期集成 高效缓存，根据imageView尺寸进行缓存 默认 RGB_565内存开销比较小 RequestManager获取通过Glide.with() 获取RequestManager对象，为每个activity对应添加一个透明不可见的fragment，并且持有当前fragment的生命周期引用，将图片加载的工作同生命周期进行绑定 。 123456789RequestManager fragmentGet(Context context, android.app.FragmentManager fm) &#123; RequestManagerFragment current = getRequestManagerFragment(fm); RequestManager requestManager = current.getRequestManager(); if (requestManager == null) &#123; requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode()); current.setRequestManager(requestManager); &#125; return requestManager; &#125; 12345678910111213RequestManagerFragment getRequestManagerFragment(final android.app.FragmentManager fm) &#123; RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG); if (current == null) &#123; current = pendingRequestManagerFragments.get(fm); if (current == null) &#123; current = new RequestManagerFragment(); pendingRequestManagerFragments.put(fm, current); fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss(); handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget(); &#125; &#125; return current; &#125; DrawableTypeRequest12345678public DrawableTypeRequest&lt;String&gt; load(String string) &#123; return (DrawableTypeRequest&lt;String&gt;) fromString().load(string); &#125;public DrawableTypeRequest&lt;String&gt; fromString() &#123; return loadGeneric(String.class); &#125; 1234567891011121314private &lt;T&gt; DrawableTypeRequest&lt;T&gt; loadGeneric(Class&lt;T&gt; modelClass) &#123; ModelLoader&lt;T, InputStream&gt; streamModelLoader = Glide.buildStreamModelLoader(modelClass, context); ModelLoader&lt;T, ParcelFileDescriptor&gt; fileDescriptorModelLoader = Glide.buildFileDescriptorModelLoader(modelClass, context); if (modelClass != null &amp;&amp; streamModelLoader == null &amp;&amp; fileDescriptorModelLoader == null) &#123; throw new IllegalArgumentException(&quot;Unknown type &quot; + modelClass + &quot;. You must provide a Model of a type for&quot; + &quot; which there is a registered ModelLoader, if you are using a custom model, you must first call&quot; + &quot; Glide#register with a ModelLoaderFactory for your custom model class&quot;); &#125; return optionsApplier.apply( new DrawableTypeRequest&lt;T&gt;(modelClass, streamModelLoader, fileDescriptorModelLoader, context, glide, requestTracker, lifecycle, optionsApplier)); &#125; 返回DrawableTypeRequest构造 modelClass : java.lang.String streamModelLoader : StreamStringLoader fileDescriptorModelLoader : FileDescriptorStringLoader DrawableTypeRequest#intoGenericRequestBuilder#into 1234public Target&lt;TranscodeType&gt; into(ImageView view) &#123; ....... return into(glide.buildImageViewTarget(view, transcodeClass)); &#125; glide.buildImageViewTarget &#x3D; DrawableImageViewTarget GenericRequestBuilder#into 123456789//target: ImageViewpublic &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(Y target) &#123; Request request = buildRequest(target); // GenericRequest target.setRequest(request); lifecycle.addListener(target); requestTracker.runRequest(request); return target;&#125; RequestTracker#runRequest 123456789public void runRequest(Request request) &#123; requests.add(request); if (!isPaused) &#123; request.begin(); &#125; else &#123; pendingRequests.add(request); &#125; &#125; GenericRequest#begin 12345678910public void begin() &#123; status = Status.WAITING_FOR_SIZE; if (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123; onSizeReady(overrideWidth, overrideHeight); &#125; else &#123; // target: GlideDrawableImageViewTarget extends ViewTarget target.getSize(this); &#125;&#125; ViewTarget#getSize 1234567891011121314if (isSizeValid(currentWidth) &amp;&amp; isSizeValid(currentHeight)) &#123; cb.onSizeReady(currentWidth, currentHeight); &#125; else &#123; // We want to notify callbacks in the order they were added and we only expect one or two callbacks to // be added a time, so a List is a reasonable choice. if (!cbs.contains(cb)) &#123; cbs.add(cb); &#125; if (layoutListener == null) &#123; final ViewTreeObserver observer = view.getViewTreeObserver(); layoutListener = new SizeDeterminerLayoutListener(this); observer.addOnPreDrawListener(layoutListener); &#125; &#125; GenericRequest#onSizeReady 1234567891011121314151617181920212223242526272829303132if (status != Status.WAITING_FOR_SIZE) &#123; return; &#125; status = Status.RUNNING; width = Math.round(sizeMultiplier * width); height = Math.round(sizeMultiplier * height); // 1. ImageVideoModelLoader ModelLoader&lt;A, T&gt; modelLoader = loadProvider.getModelLoader(); // 2. ImageVideoModelLoader#ImageVideoFetcher final DataFetcher&lt;T&gt; dataFetcher = modelLoader.getResourceFetcher(model, width, height); if (dataFetcher == null) &#123; onException(new Exception(&quot;Failed to load model: \\&#x27;&quot; + model + &quot;\\&#x27;&quot;)); return; &#125; ResourceTranscoder&lt;Z, R&gt; transcoder = loadProvider.getTranscoder(); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logV(&quot;finished setup for calling load in &quot; + LogTime.getElapsedMillis(startTime)); &#125; loadedFromMemoryCache = true; //3. loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder, priority, isMemoryCacheable, diskCacheStrategy, this); loadedFromMemoryCache = resource != null; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logV(&quot;finished onSizeReady in &quot; + LogTime.getElapsedMillis(startTime)); &#125; Engine#load 123456789101112131415161718public &lt;T, Z, R&gt; LoadStatus load()&#123;final String id = fetcher.getId();//1. imageUrl EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(), loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(), transcoder, loadProvider.getSourceEncoder());·····EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable); DecodeJob&lt;T, Z, R&gt; decodeJob = new DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation, transcoder, diskCacheProvider, diskCacheStrategy, priority); EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority); jobs.put(key, engineJob); engineJob.addCallback(cb)// cb: GenericRequest engineJob.start(runnable);&#125; EngineRunnable 1234567891011public void run() &#123; Resource&lt;?&gt; resource = null; try &#123; resource = decode(); &#125; catch (Exception e) &#123; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; Log.v(TAG, &quot;Exception decoding&quot;, e); &#125; exception = e; &#125;&#125; 1234567private Resource&lt;?&gt; decode() throws Exception &#123; if (isDecodingFromCache()) &#123; return decodeFromCache(); &#125; else &#123; return decodeFromSource(); &#125; &#125; 123private Resource&lt;?&gt; decodeFromSource() throws Exception &#123; return decodeJob.decodeFromSource(); &#125; DecodeJob 1234public Resource&lt;Z&gt; decodeFromSource() throws Exception &#123; Resource&lt;T&gt; decoded = decodeSource(); return transformEncodeAndTranscode(decoded); &#125; 123456789101112131415161718192021private Resource&lt;T&gt; decodeSource() throws Exception &#123; Resource&lt;T&gt; decoded = null; try &#123; long startTime = LogTime.getLogTime(); // 1, fetcher: ImageVideoModelLoader final A data = fetcher.loadData(priority); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Fetched data&quot;, startTime); &#125; if (isCancelled) &#123; return null; &#125; //2, decoded = decodeFromSourceData(data); &#125; finally &#123; fetcher.cleanup(); &#125; return decoded; &#125; ImageVideoModelLoader 123456public ImageVideoWrapper loadData(Priority priority) throws Exception &#123; // 1. streamFetcher: HttpUrlFetcher is = streamFetcher.loadData(priority); return new ImageVideoWrapper(is, fileDescriptor);&#125; HttpUrlFetcher 123public InputStream loadData(Priority priority) throws Exception &#123; return loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/, glideUrl.getHeaders()); &#125; 12345678private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl, Map&lt;String, String&gt; headers) throws IOException &#123; //http requestt .... final int statusCode = urlConnection.getResponseCode(); if (statusCode / 100 == 2) &#123; return getStreamForSuccessfulRequest(urlConnection); &#125;&#125; 12345678910111213private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection) throws IOException &#123; if (TextUtils.isEmpty(urlConnection.getContentEncoding())) &#123; int contentLength = urlConnection.getContentLength(); stream = ContentLengthInputStream.obtain(urlConnection.getInputStream(), contentLength); &#125; else &#123; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, &quot;Got non empty content encoding: &quot; + urlConnection.getContentEncoding()); &#125; stream = urlConnection.getInputStream(); &#125; return stream; &#125; 获取到结果：ImageVideoWrapper ， 进入 DecodeJob 123456789101112131415161718private Resource&lt;T&gt; decodeSource() throws Exception &#123; Resource&lt;T&gt; decoded = null; try &#123; long startTime = LogTime.getLogTime(); final A data = fetcher.loadData(priority); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Fetched data&quot;, startTime); &#125; if (isCancelled) &#123; return null; &#125; // 2. decoded = decodeFromSourceData(data); &#125; finally &#123; fetcher.cleanup(); &#125; return decoded; &#125; 123456789private Resource&lt;T&gt; decodeFromSourceData(A data) throws IOException &#123; final Resource&lt;T&gt; decoded; long startTime = LogTime.getLogTime(); decoded = loadProvider.getSourceDecoder().decode(data, width, height); return decoded; &#125; GIfBitmapWrapperResourceDecoder 12345678910111213public Resource&lt;GifBitmapWrapper&gt; decode(ImageVideoWrapper source, int width, int height) throws IOException &#123; ByteArrayPool pool = ByteArrayPool.get(); byte[] tempBytes = pool.getBytes(); GifBitmapWrapper wrapper = null; try &#123; // 1. wrapper = decode(source, width, height, tempBytes); &#125; finally &#123; pool.releaseBytes(tempBytes); &#125; return wrapper != null ? new GifBitmapWrapperResource(wrapper) : null; &#125; 1234567private GifBitmapWrapper decode(ImageVideoWrapper source, int width, int height, byte[] bytes) throws IOException &#123; final GifBitmapWrapper result; if (source.getStream() != null) &#123; result = decodeStream(source, width, height, bytes); &#125; return result; &#125; 123456private GifBitmapWrapper decodeStream(ImageVideoWrapper source, int width, int height, byte[] bytes)&#123; ImageVideoWrapper forBitmapDecoder = new ImageVideoWrapper(bis, source.getFileDescriptor()); result = decodeBitmapWrapper(forBitmapDecoder, width, height); return result;&#125; 12345678910private GifBitmapWrapper decodeBitmapWrapper(ImageVideoWrapper toDecode, int width, int height) throws IOException &#123; GifBitmapWrapper result = null; Resource&lt;Bitmap&gt; bitmapResource = bitmapDecoder.decode(toDecode, width, height); if (bitmapResource != null) &#123; result = new GifBitmapWrapper(bitmapResource, null); &#125; return result; &#125; ImageVideoBitmapDecoder 12345public Resource&lt;Bitmap&gt; decode(ImageVideoWrapper source, int width, int height)&#123; result = streamDecoder.decode(is, width, height); return result;&#125; StreamBitmapDecoder 1234public Resource&lt;Bitmap&gt; decode(InputStream source, int width, int height) &#123; Bitmap bitmap = downsampler.decode(source, bitmapPool, width, height, decodeFormat); return BitmapResource.obtain(bitmap, bitmapPool); &#125; DownSamper 123public Bitmap decode(InputStream is, BitmapPool pool, int outWidth, int outHeight, DecodeFormat decodeFormat) &#123; ·······&#125; 流转到 EngineRunnable 1234567891011public void run() &#123; ······ resource = decode(); if (resource == null) &#123; onLoadFailed(exception); &#125; else &#123; onLoadComplete(resource); &#125;&#125; 123private void onLoadComplete(Resource resource) &#123; manager.onResourceReady(resource); &#125; EngineJob 1234public void onResourceReady(final Resource&lt;?&gt; resource) &#123; this.resource = resource; MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget(); &#125; 12345678910111213handlerpublic boolean handleMessage(Message message) &#123; if (MSG_COMPLETE == message.what || MSG_EXCEPTION == message.what) &#123; EngineJob job = (EngineJob) message.obj; if (MSG_COMPLETE == message.what) &#123; job.handleResultOnMainThread(); &#125; return true; &#125; return false; &#125; 12345678private void handleResultOnMainThread() &#123; for (ResourceCallback cb : cbs) &#123; if (!isInIgnoredCallbacks(cb)) &#123; engineResource.acquire(); cb.onResourceReady(engineResource); &#125; &#125;&#125; GenericRequest 1234public void onResourceReady(Resource&lt;?&gt; resource) &#123; onResourceReady(resource, (R) received);&#125; 12345private void onResourceReady(Resource&lt;?&gt; resource, GlideBitmapDrawable result) &#123; status = Status.COMPLETE; GlideAnimation&lt;R&gt; animation = animationFactory.build(loadedFromMemoryCache, isFirstResource); target.onResourceReady(result, animation);&#125; GlideDrawwableImageViewTarget 123456public void onResourceReady(GlideDrawable resource, GlideAnimation&lt;? super GlideDrawable&gt; animation) &#123;super.onResourceReady(resource, animation);//1. this.resource = resource; resource.setLoopCount(maxLoopCount); resource.start();&#125; 123protected void setResource(GlideDrawable resource) &#123; view.setImageDrawable(resource); &#125; 一阶段： 图片加载成功 。。。。。。。。 glide对于图片的加载分为以下几个步骤完成 构造request cache&#x2F;网络请求进行图片获取 decode&#x2F;图片解析 图片加载时序图 GIF加载时序图 glide 缓存处理Engine 1234567891011121314151617181920public &lt;T, Z, R&gt; LoadStatus load(Key signature, int width, int height, DataFetcher&lt;T&gt; fetcher, DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder, Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) &#123; final String id = fetcher.getId();// 1. 图片url EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(), loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(), transcoder, loadProvider.getSourceEncoder()); EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable); if (cached != null) &#123; cb.onResourceReady(cached);//直接回调显示 if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Loaded resource from cache&quot;, startTime, key); &#125; return null; &#125; &#125; 1234567private EngineResource&lt;?&gt; loadFromCache(Key key, boolean isMemoryCacheable) &#123; EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key); return cached; &#125; 123private EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123; &#125; cache : put : 时序图 cache : get : 时序图","categories":[{"name":"Android","slug":"Android","permalink":"http://wanke.fun/categories/Android/"},{"name":"源码分析","slug":"Android/源码分析","permalink":"http://wanke.fun/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}],"tags":[],"author":"师学"},{"title":"源码分析-okHttp","slug":"源码分析-okHttp","date":"2021-05-19T09:39:00.000Z","updated":"2024-03-12T01:06:15.828Z","comments":true,"path":"Android/源码分析/源码分析-okHttp/","link":"","permalink":"http://wanke.fun/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-okHttp/","excerpt":"","text":"addInterceptor与addNetworkInterceptor有什么区别 ？网络缓存如何实现的？网络连接怎么实现复用？OkHttp如何做网络监控？ 缓存机制CacheInterceptorokhttp 的缓存策略是，key 为 Request的 url 的 MD5 值，value 为 response。 如果在 okhttpclient 初始化的时候配置了 cache，那么我们则从缓存中读取 caseResponse。 如果没有指定，那么我们将 request 和 caseResponse 构建一个 CacheStrategy 的类 判断 cachestrategy 是否有效，如果 request 和 caseResponse 都为空，直接返回 504 如果 request &#x3D;&#x3D; null ，cacheResponse 不为空，则返回 如果为空，那么我们就进行网络请求，如果返回了 304 且我们本地有缓存，那么说明我们的缓存没有过期，可以继续使用 多路复用 TCP&#x2F;IP 请求是需要握手的，那握手就会消耗相应的时间，所以在我们的 okhttp 中，我们会复用之前的链接进行请求，这样请求速度就快了很多。 复用 如果此链接的负载数目超过指定数目（表现为RealConnection的allocations集合的数量超过该链接指定的数量）或者noNewStreams为true时，此链接不可复用。 StreamAllocation 所持有的Address对象和RealConnection的Address非主机部分不同，则此链接不可复用。至于非主机部分的判定是在Address的equalsNonHost方法来体现。两者Adress对象的非主机部分相等的标准就是dns,Authenticator对象、协议、CA授权验证标准、端口等信息全部相等。 在1、2判定条件都为true的话，如果两个Address对象的host或者说url中的host一样，则此链接可复用，正如注释说说，添加1、2、3都满足的话，那么此时这个链接就是This connection is a perfect match。 清理标记清除法 首先标记出最不活跃的链接（空闲链接），之后进行清除 如果被标记的链接空闲 socket 超过 5 个，时间大于 5 分钟，那么直接清除。 如果此链接空闲，但是不足五分钟，则返回剩余时间，并进行标记，以供下次清除。 如果没用空闲链接的话，则五分钟之后再进行清理 判断是否为空闲链接： 遍历其中的 StreamAllocation，判断是否为空，如果为空，则没有引用这个 StreamAllocation 如果引用数量为 0 ，则为空闲链接 OkHttp框架中的设计模式","categories":[{"name":"Android","slug":"Android","permalink":"http://wanke.fun/categories/Android/"},{"name":"源码分析","slug":"Android/源码分析","permalink":"http://wanke.fun/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}],"tags":[],"author":"师学"},{"title":"Android-view绘制","slug":"Android-view绘制","date":"2021-05-11T07:49:00.000Z","updated":"2024-03-12T01:06:15.823Z","comments":true,"path":"Android/Android-view绘制/","link":"","permalink":"http://wanke.fun/Android/Android-view%E7%BB%98%E5%88%B6/","excerpt":"","text":"view 绘制流程 12345678910111213141. ActivityThread#handleResumeActivity&#123; wm.addView(decor, l);&#125;2. WindowManagerImpl#addView&#123; root.setView(view, wparams, panelParentView);&#125;3. ViewRoot#setView &#123; requestLayout();&#125;4. ViewRoot#requestLayout() &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125; 深入理解Android之View的绘制流程 Android高频面试专题 - 提升篇（二）View绘制流程 View绘制流程-精讲 Android-举一反三：12个View绘制流程高频面试题，带你全面理解View的绘制流程 公共技术点之 View 绘制流程","categories":[{"name":"Android","slug":"Android","permalink":"http://wanke.fun/categories/Android/"}],"tags":[],"author":"师学"},{"title":"Android触摸事件传递机制","slug":"Android触摸事件传递机制","date":"2021-04-28T10:13:00.000Z","updated":"2024-03-12T01:06:15.823Z","comments":true,"path":"Android/Android触摸事件传递机制/","link":"","permalink":"http://wanke.fun/Android/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/","excerpt":"","text":"事件的产生-InputManagerServiceIMS所做的工作就是监听&#x2F;dev&#x2F;input下的所有的设备节点，当设备节点有数据时会将数据进行加工处理并找到合适的Window，将输入事件派发给它。Linux会为所有可用的输入设备在&#x2F;dev&#x2F;input目录在建立event0~n或者其他名称的设备节点，Android输入系统会监控这些设备节点，具体是通过INotify和Epoll机制来进行监控。而不是通过一个线程进行轮询查询。 INotify是Linux内核提供的一种文件系统变化通知机制。它可以为应用程序监控文件系统的变化，如文件的新建，删除等。 Epoll机制简单的说就是使用一次等待来获取多个描述的可读或者可写状态。这样我们不必对每一个描述符创建独立的线程进行阻塞读取，在避免了资源浪费的同时获得较快的相应速度。 Android是基于Linux系统的。当输入设备可用时（这里的输入设备包括很多设备，比如触摸屏和键盘是Android最普遍也是最标准的输入设备，另外它还包括外接的游戏手柄、鼠标等），Linux内核会为输入设置创建对应的设备节点。我们对触摸屏进行操作时，Linux就会收到相应的硬件中断，然后将中断加工成原始的输入事件并写入相应的设备节点中。而我们的Android 输入系统所做的事情概括起来说就是监控这些设备节点，当某个设备节点有数据可读时，将数据读出并进行一系列的翻译加工，然后在所有的窗口中找到合适的事件接收者，并派发给它。 点击屏幕 InputManagerService的Read线程捕获事件，预处理后发送给Dispatcher线程Dispatcher找到目标窗口 通过Socket将事件发送到目标窗口 APP端被唤醒 找到目标窗口处理事件 当我们触摸（点击）屏幕时，Android输入系统IMS通过对事件的加工处理再合适的Window接收者并通过InputChannel向Window派发加工后的事件，并触发InputReceiver的onInputEvent的调用，由此产生后面一系列的调用，把事件派发给整个控件树的根DecorView。而DecorView又上演了一出偷梁换柱的把戏，先把事件交给Activity处理，在Activity中又把事件交还给了我们的DecorView。自此沿着控件树自上向下依次派发事件。 dispatchTouchEvent true: 消费事件并拦截,停止向下传递，流转到当前控件的 onTouchEvent false: 消费并停止向下传递，流转到上层ViewGroup或者Activity的 onTouchEvent super.dispatchTouchEven: 流转到当前控件的Intercept onInterceptTouchEvent true: 将事件进行拦截，流转到当前view的onTouchEvent false: 放行，流转到子控件的dispatchTouchEvent Android触摸事件原理（InputManagerService） 图解Android事件分发机制（深入底层源码） Android触摸事件传递机制 Android事件分发机制详解：史上最全面、最易懂","categories":[{"name":"Android","slug":"Android","permalink":"http://wanke.fun/categories/Android/"}],"tags":[],"author":"师学"},{"title":"进程间通信","slug":"进程间通信","date":"2021-04-26T08:00:00.000Z","updated":"2024-03-12T01:06:15.829Z","comments":true,"path":"Android/进程间通信/","link":"","permalink":"http://wanke.fun/Android/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/","excerpt":"","text":"几种ipc方式 Android基于Linux系统，在Linux中进程空间被划分为用于空间和内核空间 用户空间：用户间的数据不共享 内核空间：属于共享空间 用户空间和内核空间的交互需要通过系统调用 copy_from_user（）：将用户空间的数据拷贝到内核空间 copy_to_user（）：将内核空间的数据拷贝到用户空间 进行了2次copy。 binder通信机制 模型 基于 Client - Server 模式 。其核心原理：内存映射。 参考 操作系统：图文详解 内存映射 对比 Linux （Android基于Linux）上的其他进程通信方式（管道、消息队列、共享内存、信号量、Socket），Binder 机制的优点有： 高效，只需要一次数据拷贝 安全，给每个进程分配了 UID&#x2F;PID 进行身份校验 Linux 系统中，进程与进程间内存是不共享的。两个进程就像两个平行的世界，A 进程没法直接访问 B 进程的数据，这就是进程隔离的通俗解释。 内核空间（Kernel）是系统内核运行的空间，用户空间（User Space）是用户程序运行的空间，每个进程运行在独立的用户空间。为了保证安全性，它们之间是隔离的。 内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。 映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。 ServiceManager、Binder Client、Binder Server处于不同的进程，他们三个都在用户空间，而Binder驱动在内核空间。Server进程向ServiceManager注册一个映射关系表，Client进程想要和Server进程通信，首先向ServiceManager查询地址，ServiceManager收到查询的请求之后，返回查询结果给Client。 Binder 驱动在内核空间创建数据接收缓存区和内核缓存区，建立内核缓存区和内核中数据接收缓存区之间的映射关系，以及内核中数据接收缓存区和接收进程用户空间地址的映射关系。发送方进程通过系统调用 copyfromuser() 将数据 copy 到内核中的内核缓存区，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。 跨进程传递大图片当我们使用Intent跨进程传输数据的时候，数据量要是太大，会抛出TransactionTooLargeException的异常，这个异常表示两个Client的进行交互式，事物占用的内存过大，该异常发生的一些情况和解决方法： 发送&#x2F;返回的数据量过大，跨进程通信的过程中，发送数据和接收数据都是通过Buffer承载的，要是占用的内存过大，那么预留给对方的内存就有可能不足，当内存不足的时候，发送&#x2F;返回数据申请不到足够的内存，就会抛这个异常； BInder缓存申请不到足够的内存缓存空间，应用在启动Binder机制的时候，会穿件1M的缓存空间作为BInder通信的内存空间，所有的Binder公用这1M的内存，要是某个Binder服务占用的内存空间较大，导致其他的Binder无法申请到足够的内存空间，就会抛出这个异常； 对于单个Binder调用数据传输量过大的问题，建议的解决方案是将数据打散分批发送。 通过Intent来跨进程传递一个Bitmap，当mBitmap占用的内存过大的时候，就会抛出TRansactionTooLargeException的异常。而以下方式则不会 12345678Bundle bundle = new Bundle();bundle.putBinder(&quot;binder&quot;, new IRemoteGetBitmap.Stub() &#123; @Override public Bitmap getBitMap() throws RemoteException &#123; return mBitmap; &#125;&#125;);intent.putExtras(bundle); 如上面的代码，我们通过Intent传递一个Binder对象，接收端在收到Binder对象之后，通过调用BInder对象的getBitmap方法，同样可以获得传输的Bitmap，却不会造成异常。 当我们调用putParcelable传递Bitmap（Bitmap是实现了Parcelable接口的，可以进行序列化的）的时候，系统自动将allowFds设为false，禁止使用文件描述符，bitmap的传输不能利用共享内存的方式，只能将Bitmap拷贝Binder的缓存区，导致缓存区超限，需要申请的内存大于了Binder初始化的1M内存空间的限制，这样就会抛出 当我们使用putBinder的方式传递Bitmap的时候，系统是会将allowFds设置为true，运行带fd描述字符的，当传递数据的时候，首先会判断当前数据是否小于16K，小于16KB的时候会直接使用Binder的缓存空间，而当大于16KB的时候，则开辟一个ashmem，映射出一块内存，该数据会保存到ashmem中，在Intent中之写入一个fd的文件描述符，这样即使传输的数据再大，Intent中传输的也只是该资源的文件描述符。而ashmem就是利用了共享内存，在发送端和接收端之间映射同一块内存，无需多次拷贝，提高了数据传输的性能。 优秀文章: Android跨进程通信：图文详解 Binder机制 原理 Android跨进程通信：图文详解 Binder机制 原理 操作系统：图文详解 内存映射 写给 Android 应用工程师的 Binder 原理剖析 Android中怎么跨进程传输大图片 跨进程传递大图，你能想到哪些方案呢？","categories":[{"name":"Android","slug":"Android","permalink":"http://wanke.fun/categories/Android/"}],"tags":[],"author":"师学"},{"title":"Android版本适配指北","slug":"Android版本适配指北","date":"2021-04-24T02:13:00.000Z","updated":"2024-03-12T01:06:15.823Z","comments":true,"path":"Android/Android版本适配指北/","link":"","permalink":"http://wanke.fun/Android/Android%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D%E6%8C%87%E5%8C%97/","excerpt":"","text":"Android5.0 multiDexEnabled Button将总是位于最上层 从5.0开始，在同一个layout下，就算你在Button上覆盖了相应的View，Button将总是位于最上层。产生原因：stateListAnimator属性。谷歌在Material Design中推出,是一个非常简单的方法用来实现在可视状态之间平滑过渡。这个属性可以通过android:stateListAnimator进行设置，可以使控件在点击时产生不同的交互。对于Button，点击时默认有个阴影的效果用于表示按下的状态（5.0以前就是简单的变色）。 解决方法：可以使用 android:stateListAnimator&#x3D;”@null” 去掉阴影效果而使Button可以被正常的覆盖。 Android6.0 动态权限 wifi Android6.0之后，Wifi的使用更加严格。需要动态获取LOCATION权限，如果还想获取Wifi列表的话还需要打开GPS(位置信息)。 12&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;&gt;&lt;/uses-permission&gt; Android7.0 使用FileProvider授权参考 APK signature scheme v2 org.apache不支持问题 Android8.0 Notification(通知权限) 1234567891011121314151617181920212223242526/** * 判断通知权限是否开启 * @param context 上下文 */public static boolean isNotificationEnabled(Context context)&#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; return ((NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE)).areNotificationsEnabled(); &#125; else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; AppOpsManager appOps = (AppOpsManager) context.getSystemService(Context.APP_OPS_SERVICE); ApplicationInfo appInfo = context.getApplicationInfo(); String pkg = context.getApplicationContext().getPackageName(); int uid = appInfo.uid; try &#123; Class&lt;?&gt; appOpsClass = Class.forName(AppOpsManager.class.getName()); Method checkOpNoThrowMethod = appOpsClass.getMethod(&quot;checkOpNoThrow&quot;, Integer.TYPE, Integer.TYPE, String.class); Field opPostNotificationValue = appOpsClass.getDeclaredField(&quot;OP_POST_NOTIFICATION&quot;); int value = (Integer) opPostNotificationValue.get(Integer.class); return (Integer) checkOpNoThrowMethod.invoke(appOps, value, uid, pkg) == 0; &#125; catch (NoSuchMethodException | NoSuchFieldException | InvocationTargetException | IllegalAccessException | RuntimeException | ClassNotFoundException ignored) &#123; return true; &#125; &#125; else &#123; return true; &#125;&#125; Notification(通知适配) 静态广播无法正常接收 Google官方声明：从android 8.0（API26）开始，对清单文件中静态注册广播接收者增加了限制，建议大家不要在清单文件中静态注册广播接收者，改为动态注册。当然，如果你还是想用静态注册的方式也是有方法的，Intent里添加Component参数可实现。 Android9.0 刘海屏支持Android 9 支持最新的全面屏，其中包含为摄像头和扬声器预留空间的屏幕缺口。 通过 DisplayCutout类可确定非功能区域的位置和形状，这些区域不应显示内容。 要确定这些屏幕缺口区域是否存在及其位置，使用 getDisplayCutout() 函数。 1234567891011121314151617if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123; View decorView = getWindow().getDecorView(); WindowInsets rootWindowInsets = decorView.getRootWindowInsets(); if (rootWindowInsets != null) &#123; DisplayCutout cutout = rootWindowInsets.getDisplayCutout(); List&lt;Rect&gt; boundingRects = cutout.getBoundingRects(); if (boundingRects != null &amp;&amp; boundingRects.size() &gt; 0) &#123; String msg = &quot;&quot;; for (Rect rect : boundingRects) &#123; msg = msg +&quot;left-&quot; + rect.left; Log.d(TAG, msg); &#125; &#125; &#125;&#125; Android 10.0 Scoped Storage（分区存储） 特定目录（App-specific），使用getExternalFilesDir(String type)或 getExternalCacheDir()方法访问。无需权限，且卸载应用时会自动删除。 照片、视频、音频这类媒体文件。使用MediaStore 访问，访问其他应用的媒体文件时需要READ_EXTERNAL_STORAGE权限。 其他目录，使用存储访问框架SAF（Storage Access Framwork） 权限变化 后台启动 Activity 的限制 简单解释就是应用处于后台时，无法启动Activity。因为此项行为变更适用于在 Android 10 上运行的所有应用，所以这一限制导致最明显的问题就是点击推送信息时，有些应用无法进行正常的跳转（具体的实现问题导致）。所以针对这类问题，全屏 intent，注意设置最高优先级和添加USE_FULL_SCREEN_INTENT权限，这是一个普通权限。比如微信来语音或者视频通话时，弹出的接听页面就是使用这一功能。 Android11.0 强制执行分区存储","categories":[{"name":"Android","slug":"Android","permalink":"http://wanke.fun/categories/Android/"}],"tags":[],"author":"师学"},{"title":"自定义线程池实现","slug":"自定义线程池实现","date":"2021-04-23T02:53:00.000Z","updated":"2024-03-12T01:06:15.829Z","comments":true,"path":"Java/concurrent/自定义线程池实现/","link":"","permalink":"http://wanke.fun/Java/concurrent/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"任务队列 拒绝策略(抛异常，丢弃，阻塞 ， 临时队列 等 ) init active max 成员变量12345678// 工作线程数量 private int size ; //工作队列大小 private int queueSize ; // 任务缓存队列 private final static LinkedList&lt;Runnable&gt; taskQueue = new LinkedList&lt;&gt;(); // 线程集合 private final static List&lt;WorkThread&gt; threadQueue = new ArrayList&lt;&gt;(); 构造函数进行线程初始化123456789101112private void init() &#123; for (int i = 0; i &lt; size; i++) &#123; createWorkThread(); &#125; &#125; private void createWorkThread() &#123; WorkThread task = new WorkThread(threadGroup , &quot;thread: &quot;+serialNo++); threadQueue.add(task); task.start(); &#125; 工作线程核心代码如果当前线程状态存活，就不断的从任务队列中取，如果任务队列为空就进入阻塞状态 1234567891011121314151617181920212223242526@Override public void run() &#123; OUTER: while (taskState != TaskState.DEAD) &#123; Runnable runnable ; synchronized (taskQueue) &#123; while (taskQueue.isEmpty()) &#123; try &#123; taskState = TaskState.BLOCKED; taskQueue.wait(); &#125; catch (InterruptedException e) &#123;// e.printStackTrace(); break OUTER; &#125; &#125; runnable = taskQueue.removeFirst(); &#125; if (runnable != null) &#123; taskState = TaskState.RUNNING; runnable.run(); taskState = TaskState.FREE; &#125; &#125; &#125; 提交任务锁定任务队列，计算缓存大小，添加任务并唤醒 123456789101112131415public void submit(Runnable runnable) &#123; if (isDestoryed) &#123; throw new IllegalStateException(&quot;线程池已经关闭 , 不允许提交任务 &quot;); &#125; synchronized (taskQueue) &#123; if (taskQueue.size() &gt; queueSize) &#123; discardPolicy.discard(); &#125; taskQueue.addLast(runnable); taskQueue.notifyAll(); &#125; &#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194public class ThreadPool &#123; // 工作线程数量 private int size ; //工作队列大小 private int queueSize ; //拒绝策略 private DiscardPolicy discardPolicy; private int serialNo ; private final static int DEFAULT_SIZE = 10 ; private final static int DEFAULT_QUEUE_SIZE = 100 ; // 任务缓存队列 private final static LinkedList&lt;Runnable&gt; taskQueue = new LinkedList&lt;&gt;(); // 线程集合 private final static List&lt;WorkThread&gt; threadQueue = new ArrayList&lt;&gt;(); private final ThreadGroup threadGroup = new ThreadGroup(&quot;pool_group&quot;); private static DiscardPolicy DEFAULT_POLICY = () -&gt; &#123; throw new DiscardException(&quot;拒绝了 ... &quot;); &#125;; private boolean isDestoryed = false; public ThreadPool() &#123; this(DEFAULT_SIZE , DEFAULT_QUEUE_SIZE , DEFAULT_POLICY); &#125; public ThreadPool(int poolSize, int queueSize ) &#123; this(poolSize , queueSize ,DEFAULT_POLICY); &#125; public ThreadPool(int poolSize, int queueSize , DiscardPolicy policy) &#123; this.size = poolSize; this.queueSize = queueSize ; this.discardPolicy = policy; init(); &#125; public void submit(Runnable runnable) &#123; if (isDestoryed) &#123; throw new IllegalStateException(&quot;线程池已经关闭 , 不允许提交任务 &quot;); &#125; synchronized (taskQueue) &#123; if (taskQueue.size() &gt; queueSize) &#123; discardPolicy.discard(); &#125; taskQueue.addLast(runnable); taskQueue.notifyAll(); &#125; &#125; public void shutdown() throws InterruptedException &#123; while (!taskQueue.isEmpty()) &#123; Thread.sleep(50); &#125; int initval = threadQueue.size(); while (initval &gt; 0) &#123; for (WorkThread task : threadQueue) &#123; if (task.getTaskState() == TaskState.BLOCKED) &#123; task.interrupt(); task.close(); initval--; &#125; else &#123; Thread.sleep(10); &#125; &#125; &#125; isDestoryed = true; &#125; private void init() &#123; for (int i = 0; i &lt; size; i++) &#123; createWorkThread(); &#125; &#125; private void createWorkThread() &#123; WorkThread task = new WorkThread(threadGroup , &quot;thread: &quot;+serialNo++); threadQueue.add(task); task.start(); &#125; public static class DiscardException extends RuntimeException &#123; public DiscardException(String message) &#123; super(message); &#125; &#125; public interface DiscardPolicy &#123; void discard(); &#125; enum TaskState &#123; FREE , RUNNING , BLOCKED , DEAD &#125; /** * 工作线程，核心代码 */ static class WorkThread extends Thread &#123; private volatile TaskState taskState = TaskState.FREE; public WorkThread(ThreadGroup group , String name) &#123; super(group,name); &#125; public TaskState getTaskState() &#123; return taskState; &#125; @Override public void run() &#123; OUTER: while (taskState != TaskState.DEAD) &#123; Runnable runnable ; synchronized (taskQueue) &#123; while (taskQueue.isEmpty()) &#123; try &#123; taskState = TaskState.BLOCKED; taskQueue.wait(); &#125; catch (InterruptedException e) &#123;// e.printStackTrace(); break OUTER; &#125; &#125; runnable = taskQueue.removeFirst(); &#125; if (runnable != null) &#123; taskState = TaskState.RUNNING; runnable.run(); taskState = TaskState.FREE; &#125; &#125; &#125; public void close() &#123; this.taskState = TaskState.DEAD; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; ThreadPool threadPool = new ThreadPool(); for (int i = 0; i &lt; 40; i++) &#123; int finalI = i; threadPool.submit(()-&gt; &#123; System.out.println(&quot;the runnable is : &quot; + finalI + &quot; thread: &quot; + Thread.currentThread() + &quot; start &quot;); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;the runnable is : &quot; + finalI + &quot; thread: &quot; + Thread.currentThread() + &quot; end &quot;); &#125;); &#125; System.out.println(&quot; ----------------------------- &quot;); threadPool.shutdown(); threadPool.submit(() -&gt; &#123; System.out.println(&quot;hello world&quot;); &#125;); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://wanke.fun/categories/Java/"},{"name":"concurrent","slug":"Java/concurrent","permalink":"http://wanke.fun/categories/Java/concurrent/"}],"tags":[],"author":"师学"},{"title":"设计模式总览","slug":"设计模式总览","date":"2021-04-22T07:22:00.000Z","updated":"2024-03-12T01:06:15.829Z","comments":true,"path":"设计模式/设计模式总览/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E8%A7%88/","excerpt":"","text":"设计模式七大原则设计模式简介UML模式对比 创建者模式单例模式工厂模式原型模式建造者模式 结构型模式适配器模式代理模式装饰者模式桥接模式外观模式享元模式组合模式桥接模式 行为型模式模板模式策略模式命令模式职责链模式状态模式观察者模式中介者模式迭代器模式访问者模式备忘录模式解释器模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"LinkedHashMap分析","slug":"LinkedHashMap分析","date":"2021-04-22T06:34:00.000Z","updated":"2024-03-12T01:06:15.825Z","comments":true,"path":"Java/LinkedHashMap分析/","link":"","permalink":"http://wanke.fun/Java/LinkedHashMap%E5%88%86%E6%9E%90/","excerpt":"","text":"1 简介LinkedHashMap 继承 HashMap，内部有一个双向链表维护键值对的顺序，在 LinkedHashMap 中可以保持两种顺序，分别是插入顺序和访问顺序。 1public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt; &#123;&#125; 2 源码LinkedHashMap 继承 HashMap，数据数据结构也继承了 HashMap.Node，还有几个重要的属性。 1234567891011121314151617// Entry 继承 HashMap.Nodestatic class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; //前驱节点 后继节点 Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125;// 用于指向双向链表的头部transient LinkedHashMap.Entry&lt;K,V&gt; head;//用于指向双向链表的尾部transient LinkedHashMap.Entry&lt;K,V&gt; tail;//false 按插入顺序存储数据 默认为 false//true 按访问顺序存储数据 -&gt; 用来实现 LRU 策略缓存。final boolean accessOrder; LinkedHashMap 有多个重载的构造方法，默认初始化中，accessOrder 的初始值都为 false，也可以通过以下构造方法进行设置： 1234567//多了一个 accessOrder的参数，用来指定按照LRU排列方式还是顺序插入的排序方式public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder; &#125; get()12345678910public V get(Object key) &#123; Node&lt;K,V&gt; e; //调用 HashMap#getNode() 取出节点 if ((e = getNode(hash(key), key)) == null) return null; //如果 accessOrder == true，执行afterNodeAccess，把节点移动到链表末尾 if (accessOrder) afterNodeAccess(e); return e.value;&#125; getNode()1234567891011121314151617181920212223242526272829303132//得到桶号final HashMap.Node&lt;K,V&gt; getNode(int hash, Object key) &#123; //定义变量 HashMap.Node&lt;K,V&gt;[] tab; HashMap.Node&lt;K,V&gt; first, e; int n; K k; //数组不为空、数组长度&gt;0、 通过hash计算出该元素在数组中存放位置的索引 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; //hash == key? 判断该数组索引位置处第一个是否要找的元素 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) //找到，返回 return first; //没有找到,循环遍历 if ((e = first.next) != null) &#123; //如果第1个的元素是红黑树类型的节点 if (first instanceof HashMap.TreeNode) //调用红黑树的方法查找节点 return ((HashMap.TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); //如果不是,则该为链表,需要遍历查找 do &#123; //循环判断下一个节点的 hash == key? if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; //更新e为下一个 &#125; while ((e = e.next) != null); &#125; &#125; //没找到返回Null return null; &#125; afterNodeAccess()1234567891011121314151617181920212223242526272829303132//把节点移动到链表末尾void afterNodeAccess(Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; last; //如果 accessOrder == true，并且访问的节点不是尾节点 if (accessOrder &amp;&amp; (last = tail) != e) &#123; //取出前驱和后继节点 LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; //p的前驱节点为空，则将a赋值给头节点 if (b == null) head = a; else //把p节点从链表中移除 b.after = a; //构建双向链表 if (a != null) a.before = b; else last = b; //把p节点放到双向链表尾 if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; //尾节点为p tail = p; ++modCount; &#125; &#125; put()使用父类 HashMap()。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //存放元素的 table 桶不存在,进行初始化 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //用来存放目标hash值得节点不存在,新建 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; //hash相同,key值相同 Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) //是否是二叉树节点,如是放入二叉树中 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; //操作 ++ ++modCount; if (++size &gt; threshold) resize(); //调用 afterNodeInsertion afterNodeInsertion(evict); return null; &#125; afterNodeInsertion()12345678910111213141516171819202122232425262728293031323334353637383940 //新节点插入之后回调 ，判断是否需要删除最老插入的节点。 void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; //LinkedHashMap 默认返回 false 则不删除节点 if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; //调用 removeNode 移除节点 removeNode(hash(key), key, null, false, true); &#125; &#125;void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125; &#125; //LinkedHashMap 默认返回false 则不删除节点。 返回true 代表要删除最早的节点。通常构建一个LRUCache 会在达到Cache的上限是返回true protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return false; &#125; remove()使用 HashMap 的 remove() 123456public V remove(Object key) &#123; Node&lt;K,V&gt; e; //调用 removeNode() 删除节点 return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125; removeNode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; // 节点数组、当前节点、数组长度、索引值 //根据 hash 找到节点对象p if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; //如果当前节点的hash 和 key 相等，那么当前节点就是要删除的节点，赋值给node if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; //检查是否有 next 节点 else if ((e = p.next) != null) &#123; //如果当前节点是TreeNode类型，说明是一个红黑树，调用getTreeNode从树结构中查找满足条件的节点 if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); //如果是一个链表，只需要从头到尾逐个节点比对即可 else &#123; do &#123; //如果e节点的是否和key相等，e节点就是要删除的节点，赋值给node变量 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; // 走到这里，说明e也没有匹配上 p = e; // 把当前节点p指向e，这一步是让p存储的永远下一次循环里e的父节点，如果下一次e匹配上了，那么p就是node的父节点 &#125; while ((e = e.next) != null); //如果e存在下一个节点，那么继续去匹配下一个节点。直到匹配到某个节点跳出 或者 遍历完链表所有节点 &#125; &#125; /* * 如果node不为空，说明匹配到了要删除的节点 * 如果不需要对比value值或需要value 值相等 * 那么删除该node节点 */ if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) // 红黑树 ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; //删除节点 else p.next = node.next; ++modCount; //修改次数递增 --size; // 元素个数递减 afterNodeRemoval(node); // 调用afterNodeRemoval方法，该方法HashMap 没有任何实现逻辑，目的是为了让子类根据需要自行覆写 return node; &#125; &#125; return null;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://wanke.fun/categories/Java/"}],"tags":[],"author":"师学"},{"title":"HashMap-2","slug":"HashMap-2","date":"2021-04-22T06:33:00.000Z","updated":"2024-03-12T01:06:15.825Z","comments":true,"path":"Java/HashMap-2/","link":"","permalink":"http://wanke.fun/Java/HashMap-2/","excerpt":"","text":"1 简介HashMap 主要用来存放键值对，它的实现是基于哈希表的 Map 接口。 JDK1.7 的 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表采用拉链法解决哈希冲突。 JDK1.8 的 HashMap 由 数组+链表 + 红黑树，当链表长度大于阈值（默认为 8）（判断数组长度是否超过 64，超过了，就会进行扩容）会将链表转化为红黑树。 2 数据结构JDK1.7 的 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表采用拉链法解决哈希冲突。 HashMap 通过 key 的 hashCode 经过扰动函数，得到 hash 值，之后通过 （n - 1）&amp; hash 得到元素的存放位置，如果当前位置存在元素，判断该元素与要存入的元素的 hash 值和 key 是否相同，如果相同，直接覆盖，不相同就通过拉链法解决哈希冲突。 JDK1.8 的 HashMap 由 数组+链表 + 红黑树，当链表长度大于阈值（默认为 8）（先判断数组长度是否超过 64，超过了，就会先进行扩容）会将链表转化为红黑树。 1234567891011//JDK 1.7 hashstatic int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125;//JDK 1.8 hashstatic final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; JDK 1.7 数组结构 JDK 1.8 数组结构，当链表长度大于阈值（默认为8）时，先调用 treeifyBin()，当数组长度大于或者等于 64 时，转换红黑树，以减少搜索时间。否则，执行 resize() 方法对数组扩容。 3 源码123456789101112131415161718192021222324252627public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; private static final long serialVersionUID = 362498820763181265L; //初始容量 16 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; //最大容量 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //默认的填充因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; //用来确定何时将解决 hash 冲突的链表转变为红黑树 static final int TREEIFY_THRESHOLD = 8; //用来确定何时将解决 hash 冲突的红黑树转变为链表 static final int UNTREEIFY_THRESHOLD = 6; static final int MIN_TREEIFY_CAPACITY = 64; //存储元素的数组，总是2的幂次倍 transient Node&lt;k,v&gt;[] table; //存放具体元素的集 transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet; //存放元素的个数，注意这个不等于数组的长度。 transient int size; //每次扩容和更改map结构的计数器 transient int modCount; //临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容 int threshold; //加载因子 final float loadFactor;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 // Node&lt;K,V&gt; 类用来实现数组及链表的数据结构 static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; //保存节点的 hash 值 final K key; //保存节点的 key 值 V value; //保存节点的 value 值 //指向链表结构下的当前节点的 next 节点，红黑树 TreeNode 节点中也有用到 Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; &#125; public final V getValue() &#123; &#125; public final String toString() &#123; &#125; public final int hashCode() &#123; &#125; public final V setValue(V newValue) &#123; &#125; public final boolean equals(Object o) &#123; &#125; &#125; public class LinkedHashMap&lt;K,V&gt; &#123; static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125; &#125; &#125; //TreeNode&lt;K,V&gt; 继承 LinkedHashMap.Entry&lt;K,V&gt;，用来实现红黑树相关的存储结构 static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; //存储当前节点的父节点 TreeNode&lt;K,V&gt; left; //存储当前节点的左孩子 TreeNode&lt;K,V&gt; right; //存储当前节点的右孩子 TreeNode&lt;K,V&gt; prev; //存储当前节点的前一个节点 boolean red; // 存储当前节点的颜色（红、黑） TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125;&#125; 3.1 构造方法1234567891011121314151617181920212223 //指定初始容量及装载因子public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; //仅指定初始容量，装载因子的值采用默认的 0.75public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;//所有参数均采用默认值public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125; 3.2 putJDK 1.7 12345678910111213141516171819202122public V put(K key, V value) if (table == EMPTY_TABLE) &#123; inflateTable(threshold);&#125; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; // 先遍历 Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); // 再插入 return null;&#125; 根据key 得到 hash 值，定位位置，如果定位到的数组位置没有元素直接插入。 否则，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。 JDK 1.8 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //table未初始化或者长度为0，进行扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中) if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 桶中已经存在元素 else &#123; Node&lt;K,V&gt; e; K k; //比较桶中第一个元素(数组中的结点)的hash值相等，key相等 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) //将第一个元素赋值给e，用e来记录 e = p; //hash值不相等，即key不相等；为红黑树结点 else if (p instanceof TreeNode) // 放入树中 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //为链表结点 else &#123; // 在链表最末插入结点 for (int binCount = 0; ; ++binCount) &#123; //到达链表的尾部 if ((e = p.next) == null) &#123; //在尾部插入新结点 p.next = newNode(hash, key, value, null); //结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法 //这个方法会根据 HashMap 数组来决定是否转换为红黑树。 //只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); //跳出循环 break; &#125; //判断链表中结点的key值与插入的元素的key值是否相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) //相等，跳出循环 break; //用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表 p = e; &#125; &#125; //表示在桶中找到key值、hash值与插入元素相等的结点 if (e != null) &#123; //记录e的value V oldValue = e.value; //onlyIfAbsent为false或者旧值为null if (!onlyIfAbsent || oldValue == null) //用新值替换旧值 e.value = value; //访问后回调 afterNodeAccess(e); //返回旧值 return oldValue; &#125; &#125; ++modCount; //实际大小大于阈值则扩容 if (++size &gt; threshold) resize(); //插入后回调 afterNodeInsertion(evict); return null;&#125; 如果定位到的数组位置没有元素就直接插入。 否则，要插入的 key 比较，如果 key 相同就直接覆盖，否则，就判断 p 是否是一个树节点是就调用e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。 3.3 get12345678910111213141516171819202122232425262728public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 数组元素相等 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 桶中不止一个节点 if ((e = first.next) != null) &#123; // 在树中get if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 在链表中get do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 3.4 resize1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; //超过最大值就不再扩充了 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; //没超过最大值，扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; &#125; else if (oldThr &gt; 0) newCap = oldThr; else &#123; // signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; //计算新的resize上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; //把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; //原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; //原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); //原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; //原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://wanke.fun/categories/Java/"}],"tags":[],"author":"师学"},{"title":"Java虚拟机-2","slug":"Java虚拟机-2","date":"2021-04-22T06:32:00.000Z","updated":"2024-03-12T01:06:15.825Z","comments":true,"path":"Jvm/Java/Java虚拟机-2/","link":"","permalink":"http://wanke.fun/Jvm/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-2/","excerpt":"1 Java 内存区域（运行时数据区）Java 不同版本内存区域有所不同，如下图所示。","text":"1 Java 内存区域（运行时数据区）Java 不同版本内存区域有所不同，如下图所示。 线程私有： 程序计数器 虚拟机栈 本地方法栈 线程共享： 堆 方法区 直接内存（非运行时数据的一部分） 1.1 程序计数器当前线程所执行的字节码的行号指示器。 程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。 1.2 Java 虚拟机栈生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。 可能出现两种错误：StackOverFlowError 和 OutOfMemoryError。 StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。 OutOfMemoryError： 若 Java 虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话。就会抛出 OutOfMemoryError 错误。 1.3 本地方法栈和虚拟机栈所发挥的作用非常相似，只是本地方法栈使用到的是 Native 方法。 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。 可能出现两种错误：StackOverFlowError 和 OutOfMemoryError。 1.4 堆几乎所有对象都在这里分配内存，存放对象实例，是垃圾收集的主要区域（”GC 堆”）。但是，随着 JIT 编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化。从 JDK1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。 现在收集器基本都采用分代垃圾收集算法： 在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常被分为下面三部分： 新生代内存(Young Generation) 老生代(Old Generation) 永生代(Permanent Generation) JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），使用是元空间（使用直接内存）。 堆容易出现的就是 OutOfMemoryError 错误： OutOfMemoryError: GC Overhead Limit Exceeded ： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。 java.lang.OutOfMemoryError: Java heap space ：假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发java.lang.OutOfMemoryError: Java heap space 错误。(和本机物理内存无关，和你配置的内存大小有关！) 1.5 方法区存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来，方法区也被称为永久代。 注意： JDK 6，HotSpot 开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了。 JDK 7，已经把原本放在永久代的字符串常量池、静态变量等移出。 JDK 8，终于完全废弃了永久代的概念，改用与 JRockit、J9 一样在本地内存中实现的元空间（Meta- space）来代替，把 JDK 7 中永久代还剩余的内容（主要是类型信息）全部移到元空间中。 Java 方法有两种返回方式： return 语句。 抛出异常。 1.5.1 运行时常量池运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表，用于存放编译期生成的各种字面量和符号引用。 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。 1.6 直接内存并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。 2 对象的创建 2.1 类加载检查虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 2.2 分配内存类加载检查通过后，接下来虚拟机将为新生对象分配内存。分配方式有：指针碰撞 和 空闲列表两种。选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的。 2.2.1 内存分配两种选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。 指针碰撞（规整） 空闲列表（不规整） 2.2.2 内存分配并发 CAS + 失败重试： CAS 是乐观锁的一种实现方式。乐观锁就是每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。 TLAB： 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。 2.3 初始化零值虚拟机将分配到的内存空间都初始化为零值。 2.4 设置对象头虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 2.5 执行init方法在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，所以要执行程序写的 init 方法。 3 对象的内存布局在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：对象头、实例数据、对齐填充。 对象头 用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志等等）。 类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。 实例数据：对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。 对齐填充：仅仅起占位作用，不是必然存在的，也没有什么特别的含义。 4 对象的访问定位建立对象就是为了使用对象， Java 程序通过栈上的 reference 数据来操作堆上的具体对象，有两种方式。 句柄: Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。 直接指针:那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。 使用句柄：reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。 直接指针：速度快，节省了一次指针定位的时间开销。 5 对象已经死亡？在堆里面存放着几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。 5.1 引用计数法给对象中添加一个引用计数器，当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；计数器为 0 的对象就是不可能再被使用的。 这个方法实现简单、效率高，但是无法解决循环引用问题。 1234567891011public class TestGC &#123; Object instance = null; public static void main(String[] args) &#123; TestGC a = new TestGC(); TestGC b = new TestGC(); a.instance = b; b.instance = a; a = null; a = null;//循环引用无法解决 &#125;&#125; 5.2 可达性分析算法通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。 ![](..&#x2F;asset&#x2F;gc root.png) 可作为 GC Roots 的对象包括下面几种: 虚拟机栈(栈帧中的本地变量表)中引用的对象 本地方法栈(Native 方法)中引用的对象 方法区中 类静态属性引用的对象 常量引用的对象 5.3 方法区的回收方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。 主要是对常量池的回收和对类的卸载。 为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。 类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载： 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。 5.4 不可达的对象并非“非死不可”即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。 被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。 5.4 引用分类5.4.1 强引用对象不会被回收。 使用 new 方式来创建。 5.4.2 软引用只有在内存不够的情况下才会被回收。 使用 SoftReference 类来创建。 5.4.3 弱引用一定会被回收，只能存活到下一次垃圾回收发生之前。 使用 WeakReference 类来创建。 5.4.4 虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。 使用 PhantomReference 来创建。 6 垃圾收集算法6.1 标记-清除算法 该算法分为“标记”和“清除”阶段：先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。有两问题： 效率问题 空间问题（产生大量不连续的碎片） 6.2 复制算法 将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。 6.3 标记-整理 根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。 6.4 分代算法新生代：每次收集都会有大量对象死去，可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。 老年代：对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。 7 垃圾收集器 收集器 简介 Serial 收集器 串行、单线程 ParNew 收集器 Serial 收集器的多线程、新生代收集器 Parallel Scavenge 收集器 多线程收集器、吞吐量优先 Serial Old 收集器 Serial 收集器的老年代版本、 Parallel Old 收集器 Parallel Scavenge 收集器的老年代版本、在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 CMS 收集器 标记 - 清除算法、流程（初始标记、并发标记、重新标记、并发清除） G1 收集器 面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队期望未来可以替换掉 CMS 收集器。G1 可以直接对新生代和老年代一起回收。 8 内存分配与回收策略8.1 Minor GC 和 Full GC Minor GC：回收新生代，新生代对象存活时间短， Minor GC 会频繁执行，执行的速度一般比较快。 Full GC：回收老年代和新生代，老年代对象其存活长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。 Full GC 触发条件： 调用 System.gc() 老年代空间不足 空间分配担保失败 JDK 1.7 及以前的永久代空间不足 Concurrent Mode Failure：CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足。 8.2 内存分配策略 对象优先在 Eden 分配 大对象直接进入老年代 长期存活的对象进入老年代 动态对象年龄判定 虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 空间分配担保 在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。 如果是， Minor GC 可以确认是安全的。 如果不是，虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。 9 类文件结构 在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。 .class文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。 9.1 Class 文件结构123456789101112131415161718ClassFile &#123; u4 magic; //Class 文件的标志，魔数 u2 minor_version;//Class 的小版本号 u2 major_version;//Class 的大版本号 u2 constant_pool_count;//常量池的数量 cp_info constant_pool[constant_pool_count-1];//常量池 u2 access_flags;//Class 的访问标记 u2 this_class;//当前类 u2 super_class;//父类 u2 interfaces_count;//接口 u2 interfaces[interfaces_count];//一个类可以实现多个接口 u2 fields_count;//Class 文件的字段属性 field_info fields[fields_count];//一个类会可以有个字段 u2 methods_count;//Class 文件的方法数量 method_info methods[methods_count];//一个类可以有个多个方法 u2 attributes_count;//此类的属性表中的属性数 attribute_info attributes[attributes_count];//属性表集合&#125; u2 和 u4 分别代表两个字节和四个字节的无符号数，_info 结尾表示是一个表结构，表结构可以理解为一个类，用于表示复合数据结构的数据。 9.2 魔数与Class文件的版本每个 Class 文件的头4个字节被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。 紧接着魔数的 4 个字节存储的是Class文件的版本号：第 5 和第 6 个字节是次版本号（Minor Version），第 7 和第 8 个字节是主版本号（Major Version）。、 9.3 常量池紧接着主、次版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class 文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目。 常量池中主要存放两大类常量 字面量（Literal）:比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等 符号引用（Symbolic References）:属于编译原理方面的概念，主要包括下面几类常量： 被模块导出或者开放的包（Package） 类和接口的全限定名（Fully Qualified Name） 字段的名称和描述符（Descriptor） 方法的名称和描述符 方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic） 动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant） 9.4 访问标志紧接着的2个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract 类型；如果是类的话，是否被声明为final；等等。 9.5 类索引、父类索引与接口索引集合类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定该类型的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。 9.6 字段表集合用于描述接口或者类中声明的变量。 9.7 方法表集合Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表合（attributes）几项，仅在访问标志和属性表集合的可选项中有所区别。 9.8 属性表集合Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。 10 类加载机制 系统加载 Class 类型的文件三步:加载-&gt;连接-&gt;初始化。连接过程又可分为三步:验证-&gt;准备-&gt;解析。 10.1 加载主要完成下面3件事情： 通过全类名获取定义此类的二进制字节流（ ZIP 包、JAR、EAR、WAR、网络、动态代理生成 等） 将字节流所代表的静态存储结构转换为方法区的运行时数据结构 在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口 10.2 连接10.2.1 验证确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 10.2.2 准备类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。 实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。 初始值一般为 0 值。 12public static int value = 1;//被初始化为 0public static final int value = 1;//变量是常量 初始化为 1 10.2.3 解析将常量池的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。 其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。 10.3 初始化真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行初始化方法 &lt;clinit&gt; ()方法的过程。 在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，可以通过程序制定的主观计划去初始化类变量和其它资源。 () 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码： 1234567public class Test &#123; static &#123; i = 0; // 给变量赋值可以正常编译通过 System.out.print(i); // 这句编译器会提示“非法向前引用” &#125; static int i = 1;&#125; 由于父类的 () 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码： 1234567891011121314static class Parent &#123; public static int A = 1; static &#123; A = 2; &#125;&#125;static class Sub extends Parent &#123; public static int B = A;&#125;public static void main(String[] args) &#123; System.out.println(Sub.B); &#125; 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 () 方法。但接口与类不同的是，执行接口的 () 方法不需要先执行父接口的 () 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 () 方法。 虚拟机会保证一个类的 () 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 () 方法，其它线程都会阻塞等待，直到活动线程执行 () 方法完毕。如果在一个类的 () 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。 11 类与类加载器11.1 类加载器分类从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器： 启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分； 所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。 从 Java 开发人员的角度来看，类加载器分为三类: 启动类加载器（Bootstrap ClassLoader）：此类加载器负责将存放在 \\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。 扩展类加载器（Extension ClassLoader）：这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 &#x2F;lib&#x2F;ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）：这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 11.2 双亲委派机制如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。 简而言之：下向上检查是否加载过类，上到下尝试加载类。 双亲委派机制好处： 避免类的重复加载，JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类。 安全，保证了 Java 的核心 API 不被篡改。例如，自定义一个 String 类替代了 系统的 String 类。 自定义加载器，需要继承 ClassLoader 。 不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。 想打破双亲委派模型则需要重写 loadClass() 方法。 1234567891011121314151617181920212223242526272829303132333435363738//类加载器源码分析private final ClassLoader parent; protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // 检查请求的类是否已经被加载过 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; //父加载器不为空，调用父加载器loadClass()方法处理 c = parent.loadClass(name, false); &#125; else &#123; //父加载器为空，使用启动类加载器 BootstrapClassLoader 加载 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; //抛出异常说明父类加载器无法完成加载请求 &#125; if (c == null) &#123; long t1 = System.nanoTime(); //尝试加载 c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125;","categories":[{"name":"Jvm","slug":"Jvm","permalink":"http://wanke.fun/categories/Jvm/"},{"name":"Java","slug":"Jvm/Java","permalink":"http://wanke.fun/categories/Jvm/Java/"}],"tags":[],"author":"师学"},{"title":"Java线程池","slug":"Java线程池","date":"2021-04-22T06:30:00.000Z","updated":"2024-03-12T01:06:15.825Z","comments":true,"path":"Java/Java线程池/","link":"","permalink":"http://wanke.fun/Java/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"1 简介在需要异步或者并发编程中，常常使用线程池，所谓线程池，就是事先创建好一堆线程，装到一个池子里面，需要用到时候取出来，这样带来了以下的好处： 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如无限制地创建，不仅会消耗系统资源， 还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。","text":"1 简介在需要异步或者并发编程中，常常使用线程池，所谓线程池，就是事先创建好一堆线程，装到一个池子里面，需要用到时候取出来，这样带来了以下的好处： 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如无限制地创建，不仅会消耗系统资源， 还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。 2 处理流程 3 Executor 框架Java 线程既是工作单元，也是执行机制，在 Java 5 之后，引入 Executor 充当执行机制，工作单元由 Runnable 和 Callable 提供。 3.1 结构 任务：需要实现 Runnable 或 Callable 接口。 任务的执行： 执行机制核心接口 Executor 继承 Executor 的 ExecutorService（ThreadPoolExecutor 和 ScheduleThreadPoolExecutor） 异步计算结果： 接口 Future 实现 Future 接口的 FutureTask 类 3.2 使用 主线程首先创建实现 Runnable 或 Callable 接口的任务对象。 把任务对象交给 ExecutorService 执行 ExecutorService.execute（Runnable task） ExecutorService.submit（Runnable task） ExecutorService.submit（Callable task） 如果执行 ExecutorService.submit（…），将返回一个实现 Future 接口的对象，由于 FutureTask 实现了 Runnable，我们也可以创建 FutureTask，然后直接交给 ExecutorService 执行。 主线程可以执行 FutureTask.get() 方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。 4 ThreadPoolExecutorThreadPoolExecutor 是 Executor 最为核心的类，由四部分组成。 corePool：核心线程池的大小。 maximumPool：最大线程池的大小。 BlockingQueue：用来暂时保存任务的工作队列。 RejectedExecutionHandler：当 ThreadPoolExecutor 已经关闭或 ThreadPoolExecutor 已经饱和时（达到了最大线程池大小且工作队列已满），execute() 方法将要调用的 Handler。 123456789101112131415161718192021222324public ThreadPoolExecutor(int corePoolSize,//核心线程数量 int maximumPoolSize,//最大线程数 long keepAliveTime,//当线程数 &gt; 核心线程数时，多余的空闲线程存活的最长时间 TimeUnit unit,//时间单位 BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列 ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可 RejectedExecutionHandler handler) &#123;//拒绝策略，当提交的任务过多而不能及时处理时，可以定制策略来处理任务 if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; corePoolSize（线程池的核心线程数基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的 prestartAllCoreThreads() 方法， 线程池会提前创建并启动所有基本线程。 runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。 ArrayBlockingQueue：基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。 LinkedBlockingQueue：基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue，Executors.newFixedThreadPool() 使用了这个队列。 SynchronousQueue：不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，Executors.newCachedThreadPool 使用了这个队列。 PriorityBlockingQueue：一个具有优先级的无限阻塞队列。 maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。 ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。 RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，必须采取策略处理提交的新任务。默认情况下是 AbortPolicy，在JDK 1.5中Java线程池框架提供了以下4种策略,也可以根据应用场景需要来实现 RejectedExecutionHandler 接口自定义策略。如记录日志或持久化存储不能处理的任务。 。 AbortPolicy：直接抛出异常。 CallerRunsPolicy：只用调用者所在线程来运行任务。 DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。 DiscardPolicy：不处理，丢弃掉。 keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。 TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟 （MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。 5 常用的线程池5.1 FixedThreadPool可重用固定线程数的线程池。 123456//Executors.javapublic static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; FixedThreadPool 的 corePoolSize 和 maximumPoolSize 都被设置为 nThreads。 execute() 执行过程： 当前运行的线程数少于 corePoolSize，则创建新线程来执行任务。 当前运行的线程数等于corePoolSize，将任务加入 LinkedBlockingQueue。 线程执行完 1中的任务后，会在循环中反复从 LinkedBlockingQueue 获取任务来执行 5.1.1 注意FixedThreadPool 使用无界队列 LinkedBlockingQueue（队列的容量为 Intger.MAX_VALUE）作为线程池的工作队列会对线程池带来如下影响 ： 当线程池中的线程数达到 corePoolSize 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 corePoolSize； 由于使用无界队列时 maximumPoolSize 将是一个无效参数，因为不可能存在任务队列满的情况。所以，通过创建 FixedThreadPool 的源码可以看出创建的 FixedThreadPool 的 corePoolSize 和 maximumPoolSize被设置为同一个值。 由于 1 和 2，使用无界队列时 keepAliveTime 将是一个无效参数； 运行中的 FixedThreadPool（未执行 shutdown() 或 shutdownNow()）不会拒绝任务，在任务比较多的时候会导致 OOM（内存溢出）。 5.2 SingleThreadExecutor只有一个线程的线程池。 1234567public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory)); &#125; corePoolSize 和 maximumPoolSize 都被设置为 1。 execute() 执行过程： 如果当前运行的线程数少于 corePoolSize，则创建一个新的线程执行任务； 当前线程池中有一个运行的线程后，将任务加入 LinkedBlockingQueue; 线程执行完当前的任务后，会在循环中反复从 LinkedBlockingQueue 中获取任务来执行； 5.2.1 注意使用无界队列 LinkedBlockingQueue 作为线程池的工作队列（队列的容量为 Intger.MAX_VALUE）。SingleThreadExecutor 使用无界队列作为线程池的工作队列会对线程池带来的影响与 FixedThreadPool 相同，可能会导致 OOM， 5.3 CachedThreadPool会根据需要创建新线程的线程池。 123456public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), threadFactory); &#125; corePoolSize 被设置为 0，即 corePool 为空；maximumPoolSize被设置为 Integer.MAX_VALUE，即 maximumPool 是无界的。 keepAliveTime设置为 60L，意味着 CachedThreadPool 中的空闲线程等待新任务的最长时间为60秒，空闲线程超过60秒后将会被终止。 execute() 执行过程： 首先执行 SynchronousQueue.offer(Runnable task) 提交任务到任务队列。如果当前 maximumPool 中有闲线程正在执行 SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)，那么主线程执行 offer 操作与空闲线程执行的 poll 操作配对成功，主线程把任务交给空闲线程执行，execute() 方法执行完成，否则执行下面的步骤 2； 当初始 maximumPool 为空，或者 maximumPool 中没有空闲线程时，将没有线程执行 SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)。这种情况下，步骤 1 将失败，此时 CachedThreadPool 会创建新线程执行任务，execute 方法执行完成； 在步骤 2 中新创建的线程将任务执行完后，会执行 SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS）。这个poll操作会让空闲线程最多在SynchronousQueue中等待60秒钟。如果60 秒钟内主线程提交了一个新任务（主线程执行步骤1）），那么这个空闲线程将执行主线程提交的新任务；否则，这个空闲线程将终止。由于空闲60秒的空闲线程会被终止，因此长时间保持空闲的 CachedThreadPool不会使用任何资源。 5.3.1 注意允许创建的非核心线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。 5.4 newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务和延迟任务。 1234public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; //ScheduledThreadPoolExecutor return new ScheduledThreadPoolExecutor(corePoolSize);&#125; 5.5 ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来在给定的延迟之后运行任务，或定期执行任务。 ScheduledThreadPoolExecutor 的执行主要分为两大部分： 当调用 ScheduledThreadPoolExecutor 的 scheduleAtFixedRate() 方法或者 scheduleWithFixedDelay() 方法时，会向 ScheduledThreadPoolExecutor 的 DelayQueue 添加一个实现了 RunnableScheduledFuture 接口的 ScheduledFutureTask 。 线程池中的线程从 DelayQueue 中获取 ScheduledFutureTask，然后执行任务。 ScheduledThreadPoolExecutor 为了实现周期性的执行任务，对 ThreadPoolExecutor 做了如下修改： 使用 DelayQueue 作为任务队列； 获取任务的方不同； 执行周期任务后，增加了额外的处理； 5.4.1 定期执行任务 线程 1 从 DelayQueue 中获取已到期的 ScheduledFutureTask（DelayQueue.take()）。到期任务是指ScheduledFutureTask 的 time 大于等于当前时间。 线程1执行这个 ScheduledFutureTask。 线程1修改 ScheduledFutureTask 的 time 变量为下次将要被执行的时间。 线程1把这个修改 time 之后的 ScheduledFutureTask 放回 DelayQueue 中（DelayQueue.add()）。","categories":[{"name":"Java","slug":"Java","permalink":"http://wanke.fun/categories/Java/"}],"tags":[],"author":"师学"},{"title":"Java并发-2","slug":"Java并发-2","date":"2021-04-22T06:26:00.000Z","updated":"2024-03-12T01:06:15.825Z","comments":true,"path":"Java/concurrent/Java并发-2/","link":"","permalink":"http://wanke.fun/Java/concurrent/Java%E5%B9%B6%E5%8F%91-2/","excerpt":"1 进程与线程1.1 进程与线程进程：系统进行资源分配和调度的基本单位。 线程：操作系统能够进行运算调度的最小单位。","text":"1 进程与线程1.1 进程与线程进程：系统进行资源分配和调度的基本单位。 线程：操作系统能够进行运算调度的最小单位。 1.2 并发与并行 并发： 一个时间段内，多个任务在执行 (单位时间内不一定同时执行)； 并行： 单位时间内，多个任务同时执行。 2 多线程2.1 多线程的实现 继承 Thread 实现 Runnable 接口 实现 Callable 接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class TestThread &#123; public static class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(Thread.currentThread() + &quot;:继承Thread&quot;); &#125; &#125; public static class MyRunnable implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread() + &quot;:实现Runnable&quot;); &#125; &#125; public static class MyCallable implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; Thread.sleep(500); System.out.println(Thread.currentThread() + &quot;:实现Callable&quot;); return &quot;Test&quot;; &#125; &#125; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; //1.继承Thread MyThread thread1 = new MyThread(); thread1.start(); //2.实现Runnable Thread thread2 = new Thread(new MyRunnable()); thread2.start(); //3.实现Callable 有返回值，通过 FutureTask 进行封装 MyCallable myCallable = new MyCallable(); FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(myCallable); Thread thread3 = new Thread(futureTask); thread3.start(); String s = futureTask.get(); System.out.println(s); &#125;&#125;//out://Thread[Thread-0,5,main]:继承Thread//Thread[Thread-1,5,main]:实现Runnable//Thread[Thread-2,5,main]:实现Callable//Test 2.2 Daemon – 守护线程 守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分，当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。 setDaemon() 方法可以将一个线程设置为守护线程。 123Thread thread = new Thread(new MyRunnable());thread.setDaemon(true);thread.start(); 2.3 线程的生命周期Java 运行的生命周期包括以下六个状态： 状态名称 说明 NEW 初始状态 线程被创建，但是还没有调用 start() 方法 RUNNABLE 运行状态 将操作系统的就绪和运行状态称为 - 运行中 BLOCKED 阻塞状态 线程阻塞于锁 WAITING 等待状态 当前线程需要等待其他线程作出一些特定动作（通知或中断） TIME_WAITING 超时等待 指定时间自行返回 TERMINATED 终止状态 线程已经执行完毕 线程创建之后处于 NEW（新建） 状态; 调用 start() 方法后开始运行，线程处于 READY（可运行）状态; 可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNING（运行） 状态; 线程执行 wait() 方法之后，线程进入 WAITING（等待） 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态; TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。 当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。 当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。 线程在执行 Runnable 的 run() 方法之后将会进入到 TERMINATED（终止） 状态。 2.4 线程常用方法12345678910111213141516public static Thread currentThread() 返回目前正在执行的线程。public final String getName() 返回线程的名称public final int getPriority() 返回线程的优先级public boolean isInterrupted() 判断目前线程是否被中断，如果是，返回true，否则返回falsepublic final boolean isActive() 判断线程是否在活动，如果是返回true，否则返回falsepublic final void join() throws InterruptedException 指定的线程加入到当前线程public final synchronized void join(long millis) throws InterruptedException 等待millis毫秒后。public void run() 执行线程public final void setName() 设定线程名称public final void setPriority（int newPriority） 设定线程的优先级public static void sleep（long millis） throws InterruptedException 使目前正在执行的线程休眠millis毫秒public void start() 开始执行线程。public static void yield() 将目前正在执行的线程暂停一次，允许其他线程执行public final void setDaemon(boolean on) 将一个线程设置成后台运行public final void setPriority(int newPriority) 更改线程的优先级 2.4.1 sleep()Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。 sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。 1234567public void run() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 2.4.2 yield()让出当前时间片给其他线程执行，建议具有相同优先级的其它线程可以运行。 123public void run() &#123; Thread.yield();&#125; 2.4.3 中断 interrupt()、interrupted() 和 isInterrupted() interrupt()：改变中断状态而已，它不会中断一个正在运行的线程，通知线程应该中断了，该处理了。如果线程在wait， sleep，join的时候受阻，调用了interrupt()方法，那么不仅会清除中断标志位，还会抛出 InterruptedException异常。 interrupted()：第一次使用返回 true，并清除中断标志位，在此之后查询中断状态 isInterrupt() 都会返回false。 isInterrupted()：判断目前线程是否被中断，如果是，返回 true，否则返回 false。 12345678910111213141516171819202122232425262728293031323334public class Interrupt &#123; public static void main(String[] args) throws Exception &#123; Thread t = new Thread(new MyRunnable()); t.start(); Thread.sleep(100); t.interrupt(); System.out.println(&quot;主线程结束&quot;); &#125; public static class MyRunnable implements Runnable &#123; public void run() &#123; System.out.println(&quot;子线程开始&quot;); try &#123; Thread.sleep(500); // 此时被interrupt()会抛出InterruptedException &#125; catch (InterruptedException e) &#123; Thread thread = Thread.currentThread(); System.out.println(&quot;再次中断之前isInterrupted():&quot; + thread.isInterrupted()); System.out.println(&quot;再次中断之前interrupted():&quot; + Thread.interrupted()); // 再次调用interrupt方法中断自己，将中断状态设置为“中断” thread.interrupt(); System.out.println(&quot;再次interrupt()后isInterrupted():&quot; + thread.isInterrupted()); System.out.println(&quot;再次interrupt()后第一次interrupted()返回:&quot; + Thread.interrupted());// clear status // interrupted()判断是否中断，还会清除中断标志位 System.out.println(&quot;interrupted()后此时再判断IsInterrupted: &quot; + thread.isInterrupted()); System.out.println(&quot;---------After Interrupt Status Cleared----------&quot;); System.out.println(&quot;再次interrupt()后第二次interrupted()返回: &quot; + Thread.interrupted()); System.out.println(&quot;此时再判断IsInterrupted: &quot; + thread.isInterrupted()); &#125; System.out.println(&quot;Worker stopped.&quot;); &#125; &#125;&#125; 2.5 上下文切换线程上下文是指某一时间点 CPU 寄存器和程序计数器的内容，CPU 通过时间片分配算法来循环执行任务（线程），因为时间片非常短，所以 CPU 通过不停地切换线程执行。 换言之，单 CPU 这么频繁，多核 CPU 一定程度上可以减少上下文切换。 2.6 死锁多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。 线程 A 持有资源 2，等待资源 1。线程 B 持有资源 1，等待资源 B，造成了死锁。 互斥：该资源任意一个时刻只由一个线程占用。 请求和保持：一个线程因请求资源而阻塞时，对已获得的资源保持不放。 不可剥夺：线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。 环路等待：线程之间形成一种头尾相接的循环等待资源关系。 2.6.1 避免死锁 破坏互斥条件 ：无法破坏，因为用锁本来就是想让他们互斥的（临界资源需要互斥访问）。 破坏请求与保持条件 ：一次性申请所有的资源。 破坏不剥夺条件 ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。 破坏环路条件 ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏环路等待条件。 2.7 线程协作2.7.1 join()把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。 1234567891011121314151617181920212223242526272829303132333435public class TestJoin &#123; private static class A extends Thread &#123; @Override public void run() &#123; System.out.println(&quot;A&quot;); &#125; &#125; private static class B extends Thread &#123; private A a; public B(A a) &#123; this.a = a; &#125; @Override public void run() &#123; try &#123; a.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;B&quot;); &#125; &#125; public static void main(String[] args) &#123; A a = new A(); B b = new B(a); b.start(); a.start(); &#125;&#125; 2.7.2 wait() 、notify()、 notifyAll()wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。 12345678910111213141516171819202122232425262728public class TestWait &#123; private static class WaitExample &#123; public synchronized void before() &#123; System.out.println(&quot;before&quot;); notifyAll();// notify() 单一线程唤醒，多个线程不保证顺序 &#125; public synchronized void after() &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;after&quot;); &#125; &#125; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); WaitExample example = new WaitExample(); executorService.execute(example::after); executorService.execute(example::before); &#125;&#125;//out://before//after 2.7.3 wait() 和 sleep() 的区别 wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法； wait() 会释放锁，sleep() 不会释放锁。 2.7.4 await()、signal()、signalAll()java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协作，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。 1234567891011121314151617181920212223242526272829303132333435363738public class TestAwait &#123; private static class WaitExample &#123; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public void before() &#123; lock.lock(); try &#123; System.out.println(&quot;before&quot;); condition.signalAll(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void after() &#123; lock.lock(); try &#123; condition.await(); System.out.println(&quot;after&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); WaitExample example = new WaitExample(); executorService.execute(example::after); executorService.execute(example::before); &#125;&#125;//out://before//after 2.8 为什么线程启动要调用 start()，而不是直接调用 run()?调用 start() 可启动线程并使线程进入就绪状态，时间片轮转到，就开始执行，直接执行 run() 的话不会以多线程的方式执行。 3 线程同步3.1 synchronized解决的是多个线程之间访问资源的同步性，保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。 在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的，如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。 3.1.1 synchronized三种使用方式12345678910111213141516//修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁synchronized void method() &#123; //...&#125;/*修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。*/synchronized staic void method() &#123; //...&#125;//指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。public void method() &#123; synchronized (this) &#123; //... &#125;&#125; 3.1.2 synchronized 原理3.1.2.1 同步语句块12345public void method() &#123; synchronized (this) &#123; //... &#125; &#125; 使用的是 monitorenter 和 monitorexit 指令，其中monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。锁计数器为 0，可获取，获取后将锁计数器设为 1 也就是加 1。相应的在执行monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。 3.1.2.2 修饰实例方法123synchronized void method() &#123; //...&#125; 使用 ACC_SYNCHRONIZED 标识，指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。 ACC_SYNCHRONIZED 会去隐式调⽤刚才的两个指令：monitorenter 和monitorexit。归根究底，还是 monitor对象的争夺。 3.1.3 JDK 1.6 锁优化无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁 3.1.3.1 适应性自旋锁思想：让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。 缺点：需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。若锁被其他线程长时间占用，会带来许多性能上的开销。所以自旋的次数不再固定。由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。 如果共享数据的锁定状态持续时间较短，切换线程不值得（会有上下文切换），可以利用自旋锁尝试一定的次数。 3.1.3.2 锁消除JIT 编译时，会去除不可能存在竞争的锁。通过 JIT 的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁的保护，通过逃逸分析在 TLAB 来分配对象，这样就不存在共享数据带来的线程安全问题。 3.1.3.3 锁粗化减少不必要的紧连在一起的 lock，unlock 操作，将多个连续的锁扩展成一个范围更大的锁。 3.1.3.4 偏向锁（重入锁）为了在无线程竞争的情况下避免在锁获取过程中执行不必要的 CAS 原子指令，因为 CAS 原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟（因为 CAS 的底层是利用 LOCK 指令 + cmpxchg 汇编指令来保证原子性的，LOCK 指令会锁总线，其他 CPU 的内存操作将会被阻塞，因为 CPU 架构如果是 CMU 的话，控制信号、数据信号等是通过共享总线传到内存控制器中）。减少同一线程获取锁的代价，省去了大量有关锁申请的操作。 总结：只有一个线程访问同步块时，使用偏向锁。 3.1.3.5 轻量级锁这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态（即单线程执行环境），在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁(重量级锁的底层就是这样实现的)，只需要依靠一条 CAS 原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行 CAS 指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒。 总结：需要执行 CAS 操作自旋来获取锁，如果执行同步块的时间比较少，那么多个线程之间执行使用轻量级锁交替执行。 3.1.3.6 锁的对比 锁 优点 缺点 适用场景 偏向锁 加锁和解锁不需要额外的消耗, 和执行非同步代码方法的性能相差无几 如果线程间存在锁竞争, 会带来额外的锁撤销的消耗 适用于只有一个线程访问的同步场景 轻量级锁 竞争的线程不会阻塞, 提高了程序的响应速度 如果始终得不到锁竞争的线程, 使用自旋会消耗CPU 追求响应时间, 同步快执行速度非常快 重量级锁 线程竞争不适用自旋, 不会消耗CPU 线程堵塞, 响应时间缓慢 追求吞吐量, 同步快执行时间速度较长 3.2 ReentrantLock主要利用 CAS+AQS 队列 来实现，支持公平锁和非公平锁。 3.2.1 CASCompare and Swap，比较并交换。有3个操作数： 内存值 V 预期值 A 要修改的新值B 当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。该操作是一个原子操作，被广泛的应用在Java的底层实现中。在Java中，CAS 主要是由sun.misc.Unsafe这个类通过JNI调用CPU底层指令实现 4 ThreadLocal4.1 简介在使用多线程场景中，对同一个共享变量进行访问，会容易出现并发问题，造成所得到的结果不正确，通常采取的办法是在访问这个共享变量进行同步操作，一般加锁操作。 但是，众所周知，加锁操作，一定程度上会减低程序性能。假如这个变量并不需要保证在各个线程共享，各个线程都可以独立操作这个变量时，不用在意是否在读取这个变量时候，这个变量已被其他线程修改了值，那么完全可以不用同步操作，这就涉及到我们今天要讲的 ThreadLocal 这个类。 ThreaLocal 是 JKD 包提供，位于 java.lang 包下，它提供线程本地变量，简而言之，就是为每一个线程创建一个变量副本，线程操作是自己本地内存中的值，从而使每个线程都可以对这个变量为所欲为了。典型的应用场景是，数据库打开关闭操作。 4.2 使用ThreadLocal 使用也非常简单，下面写一个简单例子： 1234567891011121314151617181920212223@Testpublic void testThreadLocal() &#123; final ThreadLocal&lt;String&gt; local = new ThreadLocal&lt;&gt;(); Thread threadA = new Thread(new Runnable() &#123; @Override public void run() &#123; local.set(&quot;线程A对变量为所欲为&quot;); System.out.println(&quot;线程A：&quot; local.get()); &#125; &#125;); Thread threadB = new Thread(new Runnable() &#123; @Override public void run() &#123; local.set(&quot;线程B对变量为所欲为&quot;); System.out.println(&quot;线程B：&quot; local.get()); &#125; &#125;); threadA.start(); threadB.start();&#125;//输出：//线程A：线程A对变量为所欲为//线程B：线程B对变量为所欲为 以上程序可以看出，两个线程都通过 set 对 local 设置值，之后通过 get 读取 local 值，但是都是操作自己本地副本。 4.3 原理ThreaLocal 的代码量很少，原理也比较简单，简单来说，内部维护了一个 Map，这个 Map 是 ThreadLocal 一个内部静态类，叫 ThreadLocalMap。因为每一个线程都可以关联多个 ThreadLocal 变量，所以设计成 Map结构。接下来看看各个方法主要实现逻辑： 4.3.1 void set(T value)12345678910111213141516171819202122public void set(T value) &#123; //1.获取当前线程 Thread t = Thread.currentThread(); //2.以当前线程 t 为 key，获取当前 threadLocals 变量 ThreadLocalMap map = getMap(t); //3.如果存在，把 value 设置到 threadLocals 中 if (map != null) map.set(this, value); //4.如果不存在，创建当前线程对应的 Map else createMap(t, value);&#125;ThreadLocalMap getMap(Thread t) &#123; //获取线程自己的变量 threadLocals return t.threadLocals;&#125;void createMap(Thread t, T firstValue) &#123; //创建当前线程的 threadLocals 变量 t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 4.3.2 T get(T value)123456789101112131415161718192021222324252627282930313233public T get() &#123; //1.获取当前线程 Thread t = Thread.currentThread(); //2.以当前线程 t 为 key，获取当前 threadLocals 变量 ThreadLocalMap map = getMap(t); //3.如果不为 null，就返回 key 对应的本地变量的值 if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; //4.如果为null，就进行初始化 return setInitialValue();&#125;//逻辑和 void set() 差不多private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125;protected T initialValue() &#123; return null;&#125; 4.3.3 void remove()1234567public void remove() &#123; //1.以当前线程 t 为 key，获取当前 threadLocals 变量 ThreadLocalMap m = getMap(Thread.currentThread()); //2.如果不为 null，删除本地变量 if (m != null) m.remove(this);&#125; 4.4 问题在使用 ThreadLocal 中，由于每一个线程都持有一个 threadLocals 变量，他是一个 HashMap 类型，key 为当前线程，value 为变量副本，如果一个线程一直不消亡，会一直持有变量副本，容易造成内存泄露，所以，为了保险起见，在使用完变量副本之后，要调用 remove() 方法来删除本地变量副本。 5 volatile5.1 Java 内存模型(JMM) 在 JDK1.2 之前，Java 内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。 5.2 volatile关键字volatile 是 Java 虚拟机提供的轻量级的同步机制。在某些情况下，比锁要更加方便。如果一个字段被声明为volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。 可见性：当写一个 volatile 变量时。JMM 会把该线程对应的工作内存的共享变量刷新到主内存中当去读取一个 volatile 变量时。JMM 会把该线程对应的工作内存设置为无效。 有序性（禁止指令重排）：通过插入内存屏障防止在内存屏障前前后进行指令重排序优化写前写后各插入一个。 不保证原子性 5.3 volatile 和 synchronized 区别 volatile 的本质是告诉 JMM 当前变量在工作内存中的值是不确定的，需要从主存中读取，synchronized 则是锁定当前变量只有该线程可以访问，并阻塞其他线程 volatile 仅仅使用在变量级别 synchronized 可以使用在 变量、方法、代码块 volatile 仅能实现变量的可见性，不能保证原子性。sync 可以保证可见性、 原子性 volatile 不会造成线程的阻塞， synchronized 可能会造成线程的阻塞 volatile 标记的变量不会被编译器优化，synchronized 可以被编译器优化 6 Atomic 原子类6.1 概述JUC 原子类位于 java.util.concurrent.atomic 包下，顾名思义，其作用是在多线程编程中，保证线程安全，具有原子操作的特点。 原子类的底层使用了处理器提供的原子指令，采用更为高效的方式 CAS (compare and swap) + volatile 和 native方法，对比传统的 synchronized，把同步交给硬件层面来处理，是一种非阻塞式。 但是，并非所有保证线程安全操作都可以采用这种方式，Atomic 适用于粒度比较小型，例如在多线程下使用计数器这种需求。 6.2 分类根据操作的数据类型，将 JUC 包中的原子类分为 4 类。 6.2.1 基本类型使用原子的方式更新基本类型，包含以下 3 个类。 AutomicBoolean：原子更新布尔类型。 AutomicInteger：原子更新整型。 AutomicLong：原子更新长整型。 6.2.2 数组类型使用原子的方式更新数组里的某个元素，包含以下 3 个类。 AtomicIntegerArray：整型数组原子类 AtomicLongArray：长整型数组原子类 AtomicReferenceArray ：引用类型数组原子类 6.2.3 引用类型使用原子的方式更新引用类型，包含以下 3 个类。 AtomicReference：原子更新引用类型。 AtomicReferenceFieldUpdater：原子更新引用类型里的字段。 AtomicMarkableReference：原子更新带有标记位的引用类型。 6.2.4 对象的属性修改类型使用原子的方式更新引用类型（类）里面的字段，包含以下 3 个类。 AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。 AtomicLongFieldUpdater：原子更新长整型字段的更新器 AtomicStampedReference：原子更新带有版本号的引用类型 6.3 基本类型原子类使用原子的方式更新引用类型，包含以下 3 个类。 AtomicReference：原子更新引用类型。 AtomicReferenceFieldUpdater：原子更新引用类型里的字段。 AtomicMarkableReference：原子更新带有标记位的引用类型，可以原子更新一个布尔类型的标记位和引用类型。 基本类型原子类提供的方法几乎相同，以 AtomicInteger 为例子来介绍。 12345678public final int get() //获取当前值public final int getAndSet(int newValue)//获取当前值，并设置新值public final int getAndIncrement()//获取当前值，并自增，相当于 i++public final int incrementAndGet() //先自增，再返回，相当于 ++ipublic final int getAndDecrement() //获取当前值，并自减，相当于 i--public final int getAndAdd(int delta) //获取当前的值，并加上预期值 boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）public final void lazySet(int newValue)//最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值 6.3.1 基本使用基本类型原子类是用来保证多线程环境线程安全。 1234567891011121314151617181920212223public class TestAtomic &#123; private volatile int count = 0; //保证线程安全，需加锁 public synchronized void increment() &#123; count++; &#125; public int getCount() &#123; return count; &#125;&#125;public class TestAtomic &#123; private AtomicInteger count = new AtomicInteger(0); //不需要加锁，就可以保证线程安全 public void increment() &#123; count.incrementAndGet(); &#125; public int getCount() &#123; return count.get(); &#125;&#125; 6.3.2 原理查看 AtomicInteger 源码 1234567891011121314public class AtomicInteger extends Number implements java.io.Serializable &#123; //采用 Unsafe，这个类是位于 sun.misc 下，里面基本是本地方法，可以直接操作内存 private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; //用获取某个字段相对 Java 对象的“起始地址”的偏移量 valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(&quot;value&quot;)); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; //volatile 保证线程可见 private volatile int value;&#125; 主要利用 CAS (compare and swap) + volatile 和 native 方法 保证原子操作，比 synchronized 更加高效。 6.4 数组类型原子类使用原子的方式更新数组里的某个元素，包含以下 3 个类。 AtomicIntegerArray：整型数组原子类 AtomicLongArray：长整型数组原子类 AtomicReferenceArray ：引用类型数组原子类 数组类型原子类提供的方法几乎相同，以 AtomicIntegerArray为例子来介绍。 1234567public final int get(int i) //获取 i 位置元素的值public final int getAndSet(int i, int newValue)//返回 i位置的值，并设置为新值：newValuepublic final int getAndIncrement(int i)//获取 i 位置元素的值，并让该位置的元素自增public final int getAndDecrement(int i) //获取 i 位置元素的值，并让该位置的元素自减public final int getAndAdd(int i, int delta) //获取 i 位置元素的值，并加上预期的值boolean compareAndSet(int i, int expect, int update) //如果当前值等于预期值，则以原子方式将 i 位置的元素设置为 updatepublic final void lazySet(int i, int newValue)//将i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 1234567public class TestAtomic &#123; public void test() &#123; int[] value = new int[]&#123;1, 8, 9, 4&#125;; AtomicIntegerArray aia = new AtomicIntegerArray(value); System.out.println(aia.incrementAndGet(0));//2 &#125; &#125; 6.5 引用类型原子类由于基本类型原子类只能更新一个变量，在很多场景中，我们需要更新多个变量，这时候就需要使用到引用类型原子类，包含以下 3 个类。 AtomicReference：原子更新引用类型。 AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题，内部维护一个时间戳，当 AtomicStampedReference 对应的数值被修改时，除了更新数据本身外，还必须要更新时间戳。当AtomicStampedReference 设置对象值时，对象值以及时间戳都必须满足期望值，写入才会成功。因此，即使对象值被反复读写，写回原值，只要时间戳发生变化，就能防止不恰当的写入。 AtomicMarkableReference：原子更新带有标记位的引用类型。 引用类型原子类提供的方法几乎相同，以 AtomicInteger 为例子来介绍。 123456789101112131415161718public class TestAtomic &#123; public void test() &#123; AtomicReference&lt;Book&gt; atomicRefernceBook = new AtomicReference&lt;&gt;(); Book book1 = new Book(&quot;第一行代码&quot;, 80); atomicRefernceBook.set(book1); Book book2 = new Book(&quot;第二行代码&quot;, 180); atomicRefernceBook.compareAndSet(book1, book2); System.out.println(atomicRefernceBook.get().getName()); //第二行代码 System.out.println(atomicRefernceBook.get().getPrice());//180 &#125; &#125;public class Book &#123; private String name; private int price; /***get/set**/&#125; 代码中首先构建一个 Book 对象，然后把 Book 对象设置进 AtomicReferenc 中，最后调用 compareAndSet 方法进行原子更新操作。 CAS 的 ABA 问题： 6.6 对象的属性修改类型使用原子的方式更新引用类型（类）里面的字段，包含以下 3 个类。 AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。 AtomicLongFieldUpdater：原子更新长整型字段的更新器 AtomicStampedReference：原子更新带有版本号的引用类型 要想原子地更新字段类需要两步： 因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法 newUpdater() 创建一个更新器，并且需要设置想要更新的类和属性。 更新类的字段（属性）必须使用 public volatile 修饰符。 1234567891011121314public class TestAtomic &#123; public void test() &#123; AtomicIntegerFieldUpdater&lt;Book&gt; atfu = AtomicIntegerFieldUpdater.newUpdater(Book.class, &quot;price&quot;);//想要更新的类和属性 Book book = new Book(&quot;第一行代码&quot;, 80); System.out.println(atfu.getAndIncrement(book));//80 System.out.println(atfu.get(book));//81 &#125; &#125;public class Book &#123; private String name; public volatile int price; /***get/set**/&#125; 7 JUC-AQSAQS 的全称为（AbstractQueuedSynchronizer），抽象同步队列，在 java.util.concurrent.locks 包下面，是一个抽象类。 123public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable &#123;...&#125; 维护一个 volatile int state（代表共享资源）和一个 FIFO 线程等待队列（CLH）（多线程争用资源被阻塞时会进入此队列） AQS 定义两种资源共享方式 Exclusive：独占，只有一个线程能执行，如 ReentrantLock，分为公平锁和非公平锁 公平锁：按照线程在队列中的排队顺序，先到先得。 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的。 Share：共享，多个线程可同时执行，如 Semaphore &#x2F; CountDownLatch AQS的核心思想： AQS 基于 CLH 队列，用 volatile 修饰共享变量 state，线程通过 CAS 去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。 如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态 如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。（CLH–Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。） 7.1.1 模板同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样： 使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放） 将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。 123456//自定义同步器时需要重写以下 AQS 提供的模板方法：、isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。 7.1.2 AQS 组件 Semaphore(信号量)-允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。 CountDownLatch(倒计时器）： CountDownLatch 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。 CyclicBarrier (循环栅栏)：CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic ）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await() 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。","categories":[{"name":"Java","slug":"Java","permalink":"http://wanke.fun/categories/Java/"},{"name":"concurrent","slug":"Java/concurrent","permalink":"http://wanke.fun/categories/Java/concurrent/"}],"tags":[],"author":"师学"},{"title":"理解HashMap","slug":"理解HashMap","date":"2021-04-10T06:23:00.000Z","updated":"2024-03-12T01:06:15.829Z","comments":true,"path":"Java/理解HashMap/","link":"","permalink":"http://wanke.fun/Java/%E7%90%86%E8%A7%A3HashMap/","excerpt":"HashMap ConcurrentHashMap LinkedHashMap","text":"HashMap ConcurrentHashMap LinkedHashMap HashMap成员变量12345678910111213//最大容量 2的30次方 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //默认的加载因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; //哈希桶，存放链表。 长度是2的N次方，或者初始化时为0. transient Node&lt;K,V&gt;[] table; //加载因子，用于计算哈希表元素数量的阈值。 threshold = 哈希桶.length * loadFactor; final float loadFactor; //哈希表内元素数量的阈值，当哈希表内元素数量超过阈值时，会发生扩容resize()。 int threshold; 桶个数的计算在构造函数中传入了初始大小的话，会根据当前值计算hash桶的个数 123456789101112//根据期望容量cap，返回2的n次方形式的 哈希桶的实际容量 length。 返回值一般会&gt;=cap static final int tableSizeFor(int cap) &#123; //经过下面的 或 和位移 运算， n最终各位都是1。 int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; //判断n是否越界，返回 2的n次方作为 table（哈希桶）的阈值 return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; hash计算12345HashMap: static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; Node的hash值计算12345HashMap#Node: public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; 扩容初始化或加倍哈希桶大小。如果是当前哈希桶是null,分配符合当前阈值的初始容量目标。否则，因为我们扩容成以前的两倍。 在扩容时，要注意区分以前在哈希桶相同index的节点，现在是在以前的index里，还是index+oldlength 里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104final Node&lt;K,V&gt;[] resize() &#123; //oldTab 为当前表的哈希桶 Node&lt;K,V&gt;[] oldTab = table; //当前哈希桶的容量 length int oldCap = (oldTab == null) ? 0 : oldTab.length; //当前的阈值 int oldThr = threshold; //初始化新的容量和阈值为0 int newCap, newThr = 0; //如果当前容量大于0 if (oldCap &gt; 0) &#123; //如果当前容量已经到达上限 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; //则设置阈值是2的31次方-1 threshold = Integer.MAX_VALUE; //同时返回当前的哈希桶，不再扩容 return oldTab; &#125;//否则新的容量为旧的容量的两倍。 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)//如果旧的容量大于等于默认初始容量16 //那么新的阈值也等于旧的阈值的两倍 newThr = oldThr &lt;&lt; 1; // double threshold &#125;//如果当前表是空的，但是有阈值。代表是初始化时指定了容量、阈值的情况 else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr;//那么新表的容量就等于旧的阈值 else &#123;&#125;//如果当前表是空的，而且也没有阈值。代表是初始化时没有任何容量/阈值参数的情况 // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY;//此时新表的容量为默认的容量 16 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);//新的阈值为默认容量16 * 默认加载因子0.75f = 12 &#125; if (newThr == 0) &#123;//如果新的阈值是0，对应的是 当前表是空的，但是有阈值的情况 float ft = (float)newCap * loadFactor;//根据新表容量 和 加载因子 求出新的阈值 //进行越界修复 newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; //更新阈值 threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) //根据新的容量 构建新的哈希桶 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; //更新哈希桶引用 table = newTab; //如果以前的哈希桶中有元素 //下面开始将当前哈希桶中的所有节点转移到新的哈希桶中 if (oldTab != null) &#123; //遍历老的哈希桶 for (int j = 0; j &lt; oldCap; ++j) &#123; //取出当前的节点 e Node&lt;K,V&gt; e; //如果当前桶中有元素,则将链表赋值给e if ((e = oldTab[j]) != null) &#123; //将原哈希桶置空以便GC oldTab[j] = null; //如果当前链表中就一个元素，（没有发生哈希碰撞） if (e.next == null) //直接将这个元素放置在新的哈希桶里。 //注意这里取下标 是用 哈希值 与 桶的长度-1 。 由于桶的长度是2的n次方，这么做其实是等于 一个模运算。但是效率更高 newTab[e.hash &amp; (newCap - 1)] = e; //如果发生过哈希碰撞 ,而且是节点数超过8个，转化成了红黑树（暂且不谈 避免过于复杂， 后续专门研究一下红黑树） else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); //如果发生过哈希碰撞，节点数小于8个。则要根据链表上每个节点的哈希值，依次放入新哈希桶对应下标位置。 else &#123; // preserve order //因为扩容是容量翻倍，所以原链表上的每个节点，现在可能存放在原来的下标，即low位， 或者扩容后的下标，即high位。 high位= low位+原哈希桶容量 //低位链表的头结点、尾节点 Node&lt;K,V&gt; loHead = null, loTail = null; //高位链表的头节点、尾节点 Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next;//临时节点 存放e的下一个节点 do &#123; next = e.next; //这里又是一个利用位运算 代替常规运算的高效点： 利用哈希值 与 旧的容量，可以得到哈希值去模后，是大于等于oldCap还是小于oldCap，等于0代表小于oldCap，应该存放在低位，否则存放在高位 if ((e.hash &amp; oldCap) == 0) &#123; //给头尾节点指针赋值 if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125;//高位也是相同的逻辑 else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125;//循环直到链表结束 &#125; while ((e = next) != null); //将低位链表存放在原index处， if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; //将高位链表存放在新index处 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; 当前容量大于0且不超过最大值(1 &lt;&lt; 30),扩容2倍 如果当前表是空的，但是有阈值,那么新表的容量就等于旧的阈值 如果当前表是空的，而且也没有阈值.新表的容量为默认的容量 16 扩容后赋值先根据原有的桶，进行取值，形成新的链表。如果原桶当前位置只有一个元素 12//使用hashCode和新桶的容量进行位运算，且赋值newTab[e.hash &amp; (newCap - 1)] = e; 如果当前桶发生了hash碰撞，原链表上的每个节点，现在可能存放在原来的下标，即low位， 或者扩容后的下标，即high位。 high位&#x3D; low位+原哈希桶容量。将低位链表存放在原index处，将高位链表存放在新index处 。 put操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; //tab存放 当前的哈希桶， p用作临时链表节点 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //如果当前哈希表是空的，代表是初始化 if ((tab = table) == null || (n = tab.length) == 0) //那么直接去扩容哈希表，并且将扩容后的哈希桶长度赋值给n n = (tab = resize()).length; //如果当前index的节点是空的，表示没有发生哈希碰撞。 直接构建一个新节点Node，挂载在index处即可。 //这里再啰嗦一下，index 是利用 哈希值 &amp; 哈希桶的长度-1，替代模运算 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123;//否则 发生了哈希冲突。 //e Node&lt;K,V&gt; e; K k; //如果哈希值相等，key也相等，则是覆盖value操作 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p;//将当前节点引用赋值给e else if (p instanceof TreeNode)//红黑树暂且不谈 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123;//不是覆盖操作，则插入一个普通链表节点 //遍历链表 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123;//遍历到尾部，追加新节点到尾部 p.next = newNode(hash, key, value, null); //如果追加节点后，链表数量》=8，则转化为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //如果找到了要覆盖的节点 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; //如果e不是null，说明有需要覆盖的节点， if (e != null) &#123; // existing mapping for key //则覆盖节点值，并返回原oldValue V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; //这是一个空实现的函数，用作LinkedHashMap重写使用。 afterNodeAccess(e); return oldValue; &#125; &#125; //如果执行到了这里，说明插入了一个新的节点，所以会修改modCount，以及返回null。 //修改modCount ++modCount; //更新size，并判断是否需要扩容。 if (++size &gt; threshold) resize(); //这是一个空实现的函数，用作LinkedHashMap重写使用。 afterNodeInsertion(evict); return null; &#125; 如果桶是空的，先初始化和扩容，并将元素放到计算的索引上 如果当前index的节点是空的，表示没有发生哈希碰撞。 直接构建一个新节点Node，挂载在index处即可 如果发生了hash冲突 如果哈希值相等，key也相等，则是覆盖value操作 遍历到尾部，追加新节点到尾部 修改modCount 判断是否要扩容 为什么是线程不安全的在并发环境下，可能会形成环状链表（扩容时可能造成，具体原因自行百度google或查看源码分析），导致get操作时，cpu空转，所以，在并发环境中使用HashMap是非常危险的 为什么进行2倍扩容树化最小链表化阈值为 6 最大树化阈值为 8 LinkedHashMap集成自HashMap 1234567891011// Callbacks to allow LinkedHashMap post-actions void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125; void afterNodeInsertion(boolean evict) &#123; &#125; //回调函数，新节点插入之后回调 ， 根据evict 和 判断是否需要删除最老插入的节点。如果实现LruCache会用到这个方法。 void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125; Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e)&#123; &#125; //LinkedHashMap 默认返回false 则不删除节点。 返回true 代表要删除最早的节点。通常构建一个LruCache会在达到Cache的上限是返回true protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return false; &#125; 类里有两个成员变量head tail,分别指向内部双向链表的表头、表尾。 12345678910//双向链表的头结点 transient LinkedHashMap.Entry&lt;K,V&gt; head; //双向链表的尾节点 transient LinkedHashMap.Entry&lt;K,V&gt; tail; //默认是false，则迭代时输出的顺序是插入节点的顺序。若为true，则输出的顺序是按照访问节点的顺序。 //为true时，可以在这基础之上构建一个LruCach final boolean accessOrder; LinkedHashMap重写了newNode(),在每次构建新节点时，通过linkNodeLast(p);将新节点链接在内部双向链表的尾部。 12345678910111213141516171819//在构建新节点时，构建的是`LinkedHashMap.Entry` 不再是`Node`. Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); linkNodeLast(p); return p; &#125; //将新增的节点，连接在链表的尾部 private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123; LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; //集合之前是空的 if (last == null) head = p; else &#123;//将新节点连接在链表的尾部 p.before = last; last.after = p; &#125; &#125; LruCacheLRU为Least Recently Used的缩写，意思也就是近期最少使用算法。LruCache将LinkedHashMap的顺序设置为LRU顺序来实现LRU缓存，每次调用get并获取到值(也就是从内存缓存中命中)，则将该对象移到链表的尾端。调用put插入新的对象也是存储在链表尾端，这样当内存缓存达到设定的最大值时，将链表头部的对象（近期最少用到的）移除。 基于LinkedHashMap的LRUCache的实现，关键是重写LinkedHashMap的removeEldestEntry方法，在LinkedHashMap中该方法默认返回false（LRUCache本身未考虑线程安全的问题），这样此映射的行为将类似于正常映射，即永远不能移除最旧的元素。 ConcurrentHashMap","categories":[{"name":"Java","slug":"Java","permalink":"http://wanke.fun/categories/Java/"}],"tags":[],"author":"师学"},{"title":"Java虚拟机","slug":"Java虚拟机","date":"2021-04-08T02:58:00.000Z","updated":"2024-03-12T01:06:15.825Z","comments":true,"path":"Java/Java虚拟机/","link":"","permalink":"http://wanke.fun/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/","excerpt":"Java内存区域Java内存区域学习Java内存模型理解 程序计数器 虚拟机栈 本地方法栈 堆 方法区","text":"Java内存区域Java内存区域学习Java内存模型理解 程序计数器 虚拟机栈 本地方法栈 堆 方法区 虚拟机栈 ： stack frame 栈帧 程序计数器 ： program counter 本地方法栈 ： c ++ 等实现 堆 ： 最大的一块共享内存区域 , new object 的实例 。通过引用(在栈上) 指向实例。 与堆密切相关的是垃圾收集器， 几乎所有的现在垃圾回收器都采用了分代算法， 堆空间也针对此进行了划分 。 新生代和老年代 Eden， from survivor ，to survivor （默认按照80 ， 10 ，10 的比例进行划分） 方法区 ： 主要存储一些元信息，其中包括 class信息 等 ，有称为永久代 （jdk1.8 开始废弃，进而被元空间取代 ），很少会被垃圾回收 直接内存： 堆外内存，不是jvm直接管理 ，操作系统管理 . nio直接相关，DirectByteBuffer 是堆外内存 虚拟机栈，程序计数器 和 本地方法栈 都是内存私有的 。 堆是虚拟机中最大的一块内存区域，我们通过new关键字创建的对象，绝大多数都会在堆上面分配内存 ，然后会在栈上通过引用去指向它。堆上的对象由 数据区和元数据（比如class对象唯一）2 部分组成 ， 并且在不同的虚拟机上面会有不同的实现 二. new关键字创建对象的流程 在堆内存创建对象实例 为对象实例成员变量赋初值 返回对象引用 对象在内存中的布局： 对象头 实例数据 对齐填充（可选） HotSpot虚拟机 对象的创建及内存分配 对象的内存布局 对象的访问定位 markword 等 Java内存模型java内存模型理解(华为云) 主内存、工作内存 内存间的交互操作 对volatile变量的特殊规则 原子性、可见性、有序性 Happpen-Before原则 单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面 锁的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作。 volatile的happen-before原则：对一个volatile变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)。 happen-before的传递性原则：如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。 线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。 线程中断的happen-before原则：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。 线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测。 对象创建的happen-before原则：一个对象的初始化完成先于他的finalize方法调用。 内存分配策略http://wanke.fun/Jvm/jvm-gc/新生代、老年代 对象优先在 Eden 分配 大对象直接进入老年代 长期存活的对象进入老年代 动态对象年龄判定 虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。空间分配担保 在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。 如果是， Minor GC 可以确认是安全的。 如果不是，虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。 垃圾收集http://wanke.fun/Jvm/jvm-gc/垃圾搜集算法 判断对象是否存活 引用计数器 给对象中添加一个引用计数器，当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；计数器为 0 的对象就是不可能再被使用的。这个方法实现简单、效率高，但是无法解决循环引用问题。 可达性分析通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。 可作为 GC Roots 的对象包括下面几种: 虚拟机栈(栈帧中的本地变量表)中引用的对象 本地方法栈(Native 方法)中引用的对象 方法区中 类静态属性引用的对象 常量引用的对象 引用 强 弱 软 虚 垃圾收集算法 标记清除 该算法分为“标记”和“清除”阶段：先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。有两问题：效率问题空间问题（产生大量不连续的碎片） 复制算法将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。 标记整理根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。 垃圾收集器 分代算法新生代：每次收集都会有大量对象死去，可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。老年代：对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。 G1面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队期望未来可以替换掉 CMS 收集器。G1 可以直接对新生代和老年代一起回收。 Serial串行、单线程 类文件结构类文件结构字节码概述透过字节码看动态代理 类加载机制JVM将class文件字节码文件加载到内存中， 并将这些静态数据转换成方法区中的运行时数据结构，在堆(并不一定在堆中，HotSpot在方法区中)中生成一个代表这个类的java.lang.Class 对象，作为方法区类数据的访问入口。 JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化 加载：加载过程主要完成三件事情： 通过类的全限定名来获取定义此类的二进制字节流 将这个类字节流代表的静态存储结构转为方法区的运行时数据结构 在堆中生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口。 校验此阶段主要确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的自身安全。 文件格式验证：基于字节流验证。 元数据验证：基于方法区的存储结构验证。 字节码验证：基于方法区的存储结构验证。 符号引用验证：基于方法区的存储结构验证。 准备为类变量分配内存，并将其初始化为默认值。（此时为默认值，在初始化的时候才会给变量赋值）即在方法区中分配这些变量所使用的内存空间 解析把类型中的符号引用转换为直接引用。 初始化初始化阶段是执行类构造器方法的过程。java中，对于初始化阶段，有且只有以下五种情况才会对要求类立刻“初始化” 使用new关键字实例化对象、访问或者设置一个类的静态字段（被final修饰、编译器优化时已经放入常量池的例外）、调用类方法，都会初始化该静态字段或者静态方法所在的类。 初始化类的时候，如果其父类没有被初始化过，则要先触发其父类初始化。 使用java.lang.reflect包的方法进行反射调用的时候，如果类没有被初始化，则要先初始化。 虚拟机启动时，用户会先初始化要执行的主类（含有main） jdk 1.7后，如果java.lang.invoke.MethodHandle的实例最后对应的解析结果是 REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄，并且这个方法所在类没有初始化，则先初始化。 双亲委派模型，类加载器http://wanke.fun/Jvm/jvm-%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/ 启动类加载器 BootstrapClassLoader 扩展类加载器 ExtClassLoader 应用类加载器 AppClassLoader 防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。 保证核心.class不能被篡改。通过委托方式，不会去篡改核心.clas，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。 双亲委派机制的工作流程： 当前ClassLoader首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以直接返回了。 当前classLoader的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到bootstrp ClassLoader. 当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。 总结： “双亲委派”机制只是Java推荐的机制，并不是强制的机制。我们可以继承java.lang.ClassLoader类，实现自己的类加载器。如果想保持双亲委派模型，就应该重写findClass(name)方法；如果想破坏双亲委派模型，可以重写loadClass(name)方法 虚拟机1. Hotspot 2. dalvik 3. art 从Android5.0开始废弃了Dalvik，全面推行ART。 在Dalvik下，应用每次运行都需要通过即时编译器（JIT）将字节码转换为机器码，即每次都要编译加运行，这虽然会使安装过程比较快，但是会拖慢应用以后每次启动的效率。而在ART 环境中，应用在第一次安装的时候，字节码就会预编译（AOT）成机器码，这样的话，虽然设备和应用的首次启动（安装慢了）会变慢，但是以后每次启动执行的时候，都可以直接运行，因此运行效率会提高。 ART占用空间比Dalvik大（字节码变为机器码之后，可能会增加10%-20%），这也是著名的“空间换时间大法”。 预编译也可以明显改善电池续航，因为应用程序每次运行时不用重复编译了，从而减少了 CPU 的使用频率，降低了能耗。 ART优点： 系统性能的显著提升 应用启动更快、运行更快、体验更流畅、触感反馈更及时 更长的电池续航能力 支持更低的硬件 ART缺点： 更大的存储空间占用，可能会增加10%-20% 更长的应用安装时间 反射JVM的反射机制是在Java类编译成字节码的时候，通过jdk提供的工具类的反射方式访问类字节码的字段、方法。并且可以进行一些在Java代码中不能够实现的功能。 经典场景： Spring的ioc的依赖注入，以及一些IDE的代码开发联想功能； 缺点：反射机制的效率是很低的 反射性能的开销: 反射的主要操作:Class.forName()和Class.getMethod()调用本地实现，其中，getMethod()则会遍历类中的共有方法，类中没有则遍历父类，所以是非常耗时的，尤其在一些热点代码中可以采用本地缓存的方式来缓存结果。 性能开销主要体现在这几个方面 : (1)数组参数的传入(2)自动装箱和手动装箱的区别(3)逃逸对象的优化(4)动态实现的内联调用 注解JAVA 中有以下几个『元注解』： @Target：注解的作用目标@Retention：注解的生命周期@Documented：注解是否应当被包含在 JavaDoc 文档中@Inherited：是否允许子类继承该注解 @Target 用于指明被修饰的注解最终可以作用的目标是谁，也就是指明，你的注解到底是用来修饰方法的？修饰类的？还是用来修饰字段属性的。 有以下一些值： ElementType.TYPE：允许被修饰的注解作用在类、接口和枚举上 ElementType.FIELD：允许作用在属性字段上 ElementType.METHOD：允许作用在方法上 ElementType.PARAMETER：允许作用在方法参数上 ElementType.CONSTRUCTOR：允许作用在构造器上 ElementType.LOCAL_VARIABLE：允许作用在本地局部变量上 ElementType.ANNOTATION_TYPE：允许作用在注解上 ElementType.PACKAGE：允许作用在包上 @Retention 用于指明当前注解的生命周期，它的基本定义如下： 有以下几个枚举值可取： RetentionPolicy.SOURCE：当前注解编译期可见，不会写入 class 文件 RetentionPolicy.CLASS：类加载阶段丢弃，会写入 class 文件 RetentionPolicy.RUNTIME：永久保存，可以反射获取","categories":[{"name":"Java","slug":"Java","permalink":"http://wanke.fun/categories/Java/"}],"tags":[],"author":"师学"},{"title":"Java并发","slug":"Java并发","date":"2021-04-04T07:58:00.000Z","updated":"2024-03-12T01:06:15.825Z","comments":true,"path":"uncategorized/Java并发/","link":"","permalink":"http://wanke.fun/uncategorized/Java%E5%B9%B6%E5%8F%91/","excerpt":"https://www.yuque.com/docs/share/31deed7b-935a-4cf7-bcf3-8107bee40404?#0ea5e531 1. 线程基础","text":"https://www.yuque.com/docs/share/31deed7b-935a-4cf7-bcf3-8107bee40404?#0ea5e531 1. 线程基础 1.1 实现线程的方法thread，runnable ， callable 1.2 启动和停止线程start stop()方法，它会释放已经锁定的所有监视资源，如果当前任何一个受监视资源保护的对象处于一个不一致的状态（执行了一部分），其他线程线程将会获取到修改了的部分值，这个时候就可能导致程序执行结果的不确定性，并且这种问题很难被定位。 suspend()方法，容易发生死锁。因为调用suspend()方法不会释放锁，这就会导致此线程挂起。鉴于以上两种方法的不安全性，Java语言已经不建议使用以上两种方法来终止线程了。 一般建议采用的方法是让线程自行结束进入Dead状态。一个线程进入Dead状态，既执行完run()方法，也就是说提供一种能够自动让run()方法结束的方式，在实际中，我们可以通过flag标志来控制循环是否执行，从而使线程离开run方法终止线程。123456789public class MyThread implements Runnable&#123; private volatile Boolean flag; public void stop()&#123; flag=false; &#125; public void run()&#123; while(flag);//do something &#125;&#125; 上述通过stop()方法虽然可以终止线程，但同样也存在问题；当线程处于阻塞状态时（sleep()被调用或wait()方法被调用或当被I&#x2F;O阻塞时）,上面介绍的方法就不可用了。此时使用interrupt()方法来打破阻塞的情况，当interrupt()方法被调用时，会跑出interruptedException异常，可以通过在run()方法中捕获这个异常来让线程安全退出 1.3 线程 的六种状态123456NEW - 创建状态，线程创建之后，但是还未启动。RUNNABLE - 运行状态，处于运行状态的线程，但有可能处于等待状态，例如等待CPU、IO等。WAITING - 等待状态，一般是调用了wait()、join()、LockSupport.spark()等方法。BLOCK - 阻塞状态，等待锁的释放，例如调用了synchronized增加了锁。TERMINATED - 终止状态，一般是线程完成任务后退出或者异常终止。 1.4 wait,notify,sleep,join等重要方法wait 阻塞 notify 释放 sleep 睡眠 join 线程没执行完之前,会一直阻塞在join方法处 1.5 守护线程2. 线程安全2.1 各种各样的锁悲观锁和乐观锁 共享锁和独占锁 公平锁和非公平锁 可重入锁和非可重入锁 JVM对synchronized锁的优化 synchronized深入理解JVM synchronize锁ReentrantLock原理解读 2.2 并发容器ConcurrentHashMap CopyOnWriteArrayList 阻塞队列 - BlockingQueue接口 非阻塞队列 - ConcurrentLinkedQueue 2.3 ThreadLocalThreadLocal是一个关于创建线程局部变量的类。使用场景如下所示： 实现单个线程单例以及单个线程上下文信息存储，比如交易id等。 实现线程安全，非线程安全的对象使用ThreadLocal之后就会变得线程安全，因为每个线程都会有一个对应的实例。 承载一些线程相关的数据，避免在方法中来回传递参数。https://blog.csdn.net/weixin_44050144/article/details/113061884https://www.jianshu.com/p/377bb840802f ThreadLocal 对数据的存储通过 Thread 的 ThreadLocalMap完成 ThreadLocal本身作为key ，Entry包装了key和value Entry 继承自WeakReference ，没有Next，也没有链表 开发地址法处理hash冲突 ThreadLocal在没有外部强引用时，发生GC时会被回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。 显示的调用remove来避免内存泄漏 ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏。 2.4 atomic包,6种原子类2.5 线程池避免存在大量Thread,重用线程池内部的线程.从而避免了线程的创建和销毁带来的性能开销,同时能有效控制线程池的最大并发数,避免大量线程因互相抢占系统资源而导致阻塞现象发生Executors , ThreadPoolExecutor , 123456789101112131415public ThreadPoolExecutor(int corePoolSize, // 1 int maximumPoolSize, // 2 long keepAliveTime, // 3 TimeUnit unit, // 4 BlockingQueue&lt;Runnable&gt; workQueue, // 5 ThreadFactory threadFactory, // 6 RejectedExecutionHandler handler ) &#123; //7 if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); &#125; corePoolSize: 核心线程池大小 , 线程池里一直不会被销毁的线程数量 maximumPoolSize: 最大线程池容量 workQueue: 线程等待队列 keepAliveTime: 非核心线程空闲时的存活时间，该参数只有在 线程数量 &gt; corePoolSize情况下才有用 handler: 饱和策略，假如线程池已满，并且没有空闲的线程，这个时候不再允许提交任务 1234AbortPolicy：拒绝提交，直接抛出异常，也是默认的饱和策略；CallerRunsPolicy：线程池还未关闭时，用调用者的线程执行任务；DiscardPolicy：丢掉提交任务；DiscardOldestPolicy：线程池还未关闭时，丢掉阻塞队列最久为处理的任务，并且执行当前任务。 2.5.1 FixedThreadPool适用场景：可用于Web服务瞬时削峰，但需注意长时间持续高峰情况造成的队列阻塞。 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; corePoolSize与maximumPoolSize相等，即其线程全为核心线程，是一个固定大小的线程池 workQueue 为LinkedBlockingQueue（无界阻塞队列），队列最大值为Integer.MAX_VALUE。如果任务提交速度持续大余任务处理速度，会造成队列大量阻塞。因为队列很大，很有可能在拒绝策略前，内存溢出 2.5.2 CachedThreadPool适用场景：快速处理大量耗时较短的任务 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; corePoolSize &#x3D; 0，maximumPoolSize &#x3D; Integer.MAX_VALUE，即线程数量几乎无限制 keepAliveTime &#x3D; 60s，线程空闲60s后自动结束 workQueue 为 SynchronousQueue 同步队列，这个队列类似于一个接力棒，入队出队必须同时传递，因为CachedThreadPool线程创建无限制，不会有队列等待，所以使用SynchronousQueue, 对其的操作必须是放和取交替完成的，典型的生产者-消费者模型，它不存储元素，每一次的插入必须要等另一个线程的移除操作完成。 2.5.3 SingleThreadExecutor123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; 2.6 线程配合CountDownLatch ，CyclicBarrier 2.7 Java内存模型 原子性 - 保证指令不会受到线程上下文切换的影响 可见性 - 保证指令不会受 cpu 缓存的影响 有序性 - 保证指令不会受 cpu 指令并行优化的影响 volatile 原理volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence） 对 volatile 变量的写指令后会加入写屏障 对 volatile 变量的读指令前会加入读屏障 java内存模型 happens-before：happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见 2.8 cas 无锁编程CAS即比较并替换,它是通过硬件来保证操作的原子性.去修改某个值,修改失败则重试. CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果 volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原子性） 无锁效率高： 无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。 线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高 速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。 CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。 synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。 CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一 但如果竞争激烈(写操作多)，可以想到重试必然频繁发生，反而效率会受影响 2.9 AQSAQS：AbstractQuenedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。 AQS的核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。 基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。 注意：AQS是自旋锁：在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功 并发编程（七）J.U.C之AQS原理、ReentrantLock原理Java并发之AQS详解02_可重入锁(递归锁)+LockSupport+AQS源码分析Java 并发一步一脚印(专栏) 3. 生产者消费者三种实现 4. 线程通信 synchronized加wait&#x2F;notify方式 ReentrantLock加Condition方式 闭锁方式、栅栏模式(CountDownLatch，CyclicBarrier) Semaphore 信号量 join Volatile 共享变量","categories":[],"tags":[],"author":"师学"},{"title":"Java基础","slug":"Java基础","date":"2021-04-02T08:30:00.000Z","updated":"2024-03-12T01:06:15.825Z","comments":true,"path":"Java/Java基础/","link":"","permalink":"http://wanke.fun/Java/Java%E5%9F%BA%E7%A1%80/","excerpt":"https://www.yuque.com/docs/share/31deed7b-935a-4cf7-bcf3-8107bee40404?#0ea5e531 1. 面向对象封装，继承，多态 多态是指父类的某个方法被子类重写时，可以产生自己的功能行为，同一个操作作用于不同对象，可以有不同的解释，产生不同的执行结果。 静态方法与静态成员变量可以被继承，但是不能被重写。它对子类隐藏，因此静态方法也不能实现多态 为什么Java里的匿名内部类只能访问final修饰的外部变量？","text":"https://www.yuque.com/docs/share/31deed7b-935a-4cf7-bcf3-8107bee40404?#0ea5e531 1. 面向对象封装，继承，多态 多态是指父类的某个方法被子类重写时，可以产生自己的功能行为，同一个操作作用于不同对象，可以有不同的解释，产生不同的执行结果。 静态方法与静态成员变量可以被继承，但是不能被重写。它对子类隐藏，因此静态方法也不能实现多态 为什么Java里的匿名内部类只能访问final修饰的外部变量？ 123因为匿名内部类最终用会编译成一个单独的类，而被该类使用的变量会以构造函数参数的形式传递给该类，例如：Integer paramInteger，如果变量不定义成final的，paramInteger在匿名内部类被可以被修改，进而造成和外部的paramInteger不一致的问题，为了避免这种不一致的情况，因为Java规定匿名内部类只能访问final修饰的外部变量。 描述一下Java的异常体系？ Error是程序无法处理的错误，比如OutOfMemoryError、ThreadDeath等。这些异常发生时， Java虚拟机（JVM）一般会选择线程终止。 Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常，程序中应当尽可能去处理这些异常。运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的， 程序应该从逻辑角度尽可能避免这类异常的发生。 2. 设计模式3. 集合框架ArrayList , LinkedList , HashMap , LinkedHashMap , SparseArray , ArrayMap , HashMap中的名词解释HashMap源码解析 4. 反射反射慢主要因为反射是动态类型，导致没办法运用JVM的一些优化措施。 如何防止反射、序列化攻击单例？ 5. 注解 注解相当于一种标记，在程序中加了注解就等于为程序打上了某种标记。程序可以利用ava的反射机制来了解你的类及各种元素上有无何种标记，针对不同的标记，就去做相应的事件。标记可以加在包，类，字段，方法，方法的参数以及局部变量上。 6. 泛型泛型是为了参数化类型。 为什么使用泛型？ 相对于使用Object这种简单粗暴的方式，泛型提供了一种参数化的能力，使得数据的类型可以像参数一样被传递进来，这提供了一种扩展能力。 当数据类型确定以后，提供了一种类型检测机制，只有相匹配的数据才可以正常赋值，否则编译错误，增强了安全性。 泛型提高了代码的可读性，不必等到运行时采取执行类型转换，在编写代码阶段，程序员就可以通过参数书写正确的数据类型。 除了用 表示泛型外，还有 &lt;?&gt; 这种形式。？ 被称为通配符。• 被称作无限定的通配符。• 被称作有上限的通配符。• 被称作有下限的通配符。 Java里的反射为何会消耗性能？ 反射慢主要因为反射是动态类型，导致没办法运用JVM的一些优化措施。 Java的类型擦除，知道它的原理吗？ 泛型信息只存在代码编译阶段，在进入JVM之前，与泛型相关的信息都会被擦除掉。","categories":[{"name":"Java","slug":"Java","permalink":"http://wanke.fun/categories/Java/"}],"tags":[],"author":"师学"},{"title":"Android知识体系图","slug":"Android知识体系图","date":"2021-04-01T08:30:00.000Z","updated":"2024-03-12T01:06:15.823Z","comments":true,"path":"Android/Java/Android知识体系图/","link":"","permalink":"http://wanke.fun/Android/Java/Android%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E5%9B%BE/","excerpt":"Android知识体系","text":"Android知识体系","categories":[{"name":"Android","slug":"Android","permalink":"http://wanke.fun/categories/Android/"},{"name":"Java","slug":"Android/Java","permalink":"http://wanke.fun/categories/Android/Java/"}],"tags":[],"author":"师学"},{"title":"谈Handler","slug":"谈Handler","date":"2020-07-15T06:55:00.000Z","updated":"2024-03-12T01:06:15.829Z","comments":true,"path":"Android/谈Handler/","link":"","permalink":"http://wanke.fun/Android/%E8%B0%88Handler/","excerpt":"腾讯：handler源码分析 handler：使APP不再crash","text":"腾讯：handler源码分析 handler：使APP不再crash Android消息机制主要 涉及到 Handler, Message, MessageQueue，Looper 以Handler的sendMessage方法为例，当发送一个消息后，会将此消息加入消息队列MessageQueue中。 Looper负责去遍历消息队列并且将队列中的消息分发给对应的Handler进行处理。 在Handler的handleMessage方法中处理该消息，这就完成了一个消息的发送和处理过程。 消息阻塞和延时Looper 的阻塞主要是靠 MessageQueue 来实现的，在MessageQuese#next 进行阻塞，在 MessageQueue#enqueueMessage 进行唤醒。主要依赖 native 层的 Looper 依靠 epoll 机制进行的。 阻塞和延时，主要是next中nativePollOnce(ptr, nextPollTimeoutMillis)调用naive方法操作管道，由nextPollTimeoutMillis决定是否需要阻塞nextPollTimeoutMillis为0的时候表示不阻塞，为-1的时候表示一直阻塞直到被唤醒，其他时间表示延时。 主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I&#x2F;O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源 其他一个线程只绑定一个Looper，所以在Looper构造方法里面初始化就可以保证mQueue也是唯一的Thread对应一个Looper 对应一个 mQueue。 Handler.post的逻辑在哪个线程执行的，由Looper所在线程决定的。逻辑是在Looper.loop()方法中，从MsgQueue中拿出msg，并且执行其逻辑，这是在Looper中执行的，因此有Looper所在线程决定。 手写handler1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.handlerr;public class Handler &#123; private final Looper looper; private final MssageQueue queue; public void handMessage(Message message) &#123; &#125; public Handler() &#123; looper = Looper.myLooper(); if (looper == null) &#123; throw new IllegalArgumentException(&quot;should call looper.prepare first&quot;); &#125; queue = looper.mQueue(); &#125; public void sendMessage(Message message) &#123; message.target = this; queue.equeueMessage(message); &#125; public void run(Runnable runnable) &#123; Message message = new Message(); message.callback = runnable; queue.equeueMessage(message); &#125; public void dispatch(Message next) &#123; if (next.callback != null) &#123; next.callback.run(); &#125; else &#123; handMessage(next); &#125; &#125;&#125; 123456789101112package com.handlerr;public class Message &#123; public int what; public Object obj; public Handler target; public Runnable callback;&#125; 12345678910111213141516171819202122232425262728293031package com.handlerr;import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;public class MssageQueue &#123; private BlockingQueue&lt;Message&gt; mQueue = new LinkedBlockingQueue&lt;&gt;(); public MssageQueue() &#123; &#125; public Message next() &#123; try &#123; Message take = mQueue.take(); return take; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return null; &#125; public void equeueMessage(Message message) &#123; mQueue.add(message); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839package com.handlerr;public class Looper &#123; private static ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal(); MssageQueue queue; private Looper() &#123; queue = new MssageQueue(); &#125; public static void prepare() &#123; sThreadLocal.set(new Looper()); &#125; public static final Looper myLooper() &#123; return sThreadLocal.get(); &#125; public MssageQueue mQueue() &#123; return queue; &#125; public static void loop() &#123; while (true) &#123; Message next = Looper.myLooper().mQueue().next(); if (next != null) &#123; next.target.dispatch(next); &#125; &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://wanke.fun/categories/Android/"}],"tags":[],"author":"师学"},{"title":"FBO的一点理解","slug":"FBO的一点理解","date":"2020-06-11T09:08:00.000Z","updated":"2024-03-12T01:06:15.824Z","comments":true,"path":"OpenGL/FBO的一点理解/","link":"","permalink":"http://wanke.fun/OpenGL/FBO%E7%9A%84%E4%B8%80%E7%82%B9%E7%90%86%E8%A7%A3/","excerpt":"在使用glsurfaceView渲染图片和摄像头采集的视频数据时候，之前默认的使用直接渲染的方式。但是在实际的开发使用中，我们很多时候并不想要直接渲染，而是先做一些额外的工作，比如滤镜 。 fbo可以帮我们更好的实现这个需求，FBO可以让不渲染到屏幕当中去，而是渲染到离屏的buffer中。","text":"在使用glsurfaceView渲染图片和摄像头采集的视频数据时候，之前默认的使用直接渲染的方式。但是在实际的开发使用中，我们很多时候并不想要直接渲染，而是先做一些额外的工作，比如滤镜 。 fbo可以帮我们更好的实现这个需求，FBO可以让不渲染到屏幕当中去，而是渲染到离屏的buffer中。 这里我们不再去赘述一些基本的概念 ，基于OpenGL es 30 版本，在Android上的实现，描述一次 fbo的实现过程。 就以渲染一张bitmap为例 。 1. 创建bitmap纹理 生成并绑定纹理 12345678910 final int[] textureIds = new int[1];GLES30.glGenTextures(1, textureIds, 0);// 绑定纹理到OpenGLGLES30.glBindTexture(GLES30.GL_TEXTURE_2D,textureIds[0]);//设置默认的纹理过滤参数GLES30.glTexParameteri(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MIN_FILTER,GLES30.GL_LINEAR_MIPMAP_LINEAR);GLES30.glTexParameteri(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MAG_FILTER,GLES30.GL_LINEAR); 2: 渲染bitmap到纹理 在上一步绑定纹理以后，后续的操作都会在此纹理完成 1234// 加载bitmap到纹理中 GLUtils.texImage2D(GLES30.GL_TEXTURE_2D, 0, bitmap, 0); GLES30.glGenerateMipmap(GLES30.GL_TEXTURE_2D); 3 : 一定要记得解绑 1234// 数据如果已经被加载进OpenGL,则可以回收该bitmap bitmap.recycle(); // 取消绑定纹理 GLES30.glBindTexture(GLES30.GL_TEXTURE_2D, 0); 2. fbo的创建 创建frameBuffer 123//创建FrameBuffer mFrameBuffers = new int[1]; GLES30.glGenFramebuffers(mFrameBuffers.length, mFrameBuffers, 0); 创建并绑定纹理 12345678910mFBOTextures = new int[1];GLES30.glGenTextures(mFBOTextures.length, mFBOTextures, 0);GLES30.glBindTexture(GLES30.GL_TEXTURE_2D, mFBOTextures[0]);//设置参数GLES30.glTexParameteri(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MAG_FILTER, GLES30.GL_NEAREST);GLES30.glTexParameteri(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MIN_FILTER, GLES30.GL_NEAREST);GLES30.glTexParameteri(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_WRAP_S, GLES30.GL_REPEAT);GLES30.glTexParameteri(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_WRAP_T, GLES30.GL_REPEAT); 设置纹理格式 123//指定FBO纹理的输出图像的格式 RGBAGLES30.glTexImage2D(GLES30.GL_TEXTURE_2D, 0, GLES30.GL_RGBA, mWidth, mHeight, 0, GLES30.GL_RGBA, GLES30.GL_UNSIGNED_BYTE, null); 绑定framebuffer 12345GLES30.glBindFramebuffer(GLES30.GL_FRAMEBUFFER, mFrameBuffers[0]);//将fbo绑定到2d的纹理上GLES30.glFramebufferTexture2D(GLES30.GL_FRAMEBUFFER, GLES30.GL_COLOR_ATTACHMENT0, GLES30.GL_TEXTURE_2D, mFBOTextures[0], 0); 取消绑定 12GLES30.glBindTexture(GLES30.GL_TEXTURE_2D, 0);GLES30.glBindFramebuffer(GLES30.GL_FRAMEBUFFER, 0); 绘制 1234567891011121314151617181920public int draw(int textureId) &#123; //锁定绘制的区域 绘制是从左下角开始的 GLES30.glViewport(0, 0, mWidth, mHeight); //绑定FBO，在FBO上操作 GLES30.glBindFramebuffer(GLES30.GL_FRAMEBUFFER, mFrameBuffers[0]) //使用着色器 GLES30.glUseProgram(mProgram); ....... //激活纹理 GLES30.glActiveTexture(GLES30.GL_TEXTURE0); //绑定纹理 GLES30.glBindTexture(GLES30.GL_TEXTURE_2D, textureId); GLES30.glDrawArrays(GLES30.GL_TRIANGLE_STRIP, 0, 4); GLES30.glBindFramebuffer(GLES30.GL_FRAMEBUFFER, 0); GLES30.glBindTexture(GLES30.GL_TEXTURE_2D, 0); return mFBOTextures[0]; &#125; DEMO 地址","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://wanke.fun/categories/OpenGL/"}],"tags":[],"author":"师学"},{"title":"seetaFace集成使用","slug":"seetaFace集成使用","date":"2020-06-09T09:04:00.000Z","updated":"2024-03-12T01:06:15.827Z","comments":true,"path":"Android/seetaFace集成使用/","link":"","permalink":"http://wanke.fun/Android/seetaFace%E9%9B%86%E6%88%90%E4%BD%BF%E7%94%A8/","excerpt":"seeta::FaceAlignment 是中科视拓开放的商用级人脸识别库 。包括，识别，检测，对齐等多个核心模块 。 https://github.com/seetafaceengine/SeetaFace6","text":"seeta::FaceAlignment 是中科视拓开放的商用级人脸识别库 。包括，识别，检测，对齐等多个核心模块 。 https://github.com/seetafaceengine/SeetaFace6 集成环境 ndk-r14b , makelist文件： 123add_subdirectory(src/main/cpp/alignment)target_link_libraries 添加 seeta_fa_lib build.gradle文件 ： 12// arguments &quot;-DANDROID_STL=c++_shared&quot; arguments &quot;-DANDROID_STL=gnustl_static&quot; 使用 ： 初始化 ： Ptrseeta::FaceAlignment faceAlignment; faceAlignment &#x3D; makePtrseeta::FaceAlignment(“seeta_fa_v1.1.bin”); 123456789101112131415 seeta::FacialLandmark points[5]; seeta::ImageData imageData(gray.cols, gray.rows);// imageData.data = gray.data; seeta::FaceInfo faceInfo; seeta::Rect bbox; bbox.x = x; bbox.y = y; bbox.width = width; bbox.height = height; faceInfo.bbox = bbox; //检测 人眼 等五个点 faceAlignment-&gt;PointDetectLandmarks(imageData, faceInfo, points); error： htapp.cc:3026:9: error: call to ‘abs’ is ambiguous ：abs 改成 fabs 即可 https://github.com/kongxs/tomato/tree/camera2","categories":[{"name":"Android","slug":"Android","permalink":"http://wanke.fun/categories/Android/"}],"tags":[],"author":"师学"},{"title":"dlib在android端的集成","slug":"dlib在android端的集成","date":"2020-05-27T08:06:00.000Z","updated":"2024-03-12T01:06:15.825Z","comments":true,"path":"Android/dlib/DIP/dlib在android端的集成/","link":"","permalink":"http://wanke.fun/Android/dlib/DIP/dlib%E5%9C%A8android%E7%AB%AF%E7%9A%84%E9%9B%86%E6%88%90/","excerpt":"http://dlib.net dlib 源码下载。 环境参考： android-ndk-r14b ，opencv 3.4 , dlib 19.19","text":"http://dlib.net dlib 源码下载。 环境参考： android-ndk-r14b ，opencv 3.4 , dlib 19.19 opencv官方编译好了可用于android平台的so以及jni header 提供了jni和java版本的SDK两中调用方式，集成比较简单，不走赘述。 1. dlib 集成 下载dlib源码，我使用19.19 解压后的目录如下 1234dlib docs examples tools 将 dlib 目录整体拷贝到 studio 的 src&#x2F;main&#x2F;cpp 目录下 配置 build.gradle文件 123456externalNativeBuild &#123; cmake &#123; arguments &quot;-DCMAKE_BUILD_TYPE=Release ..&quot; cppFlags &quot;-std=c++11 -frtti -fexceptions -Os -O2&quot; &#125; &#125; cmake 文件处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273cmake_minimum_required(VERSION 3.4.1)# Creates and names a library, sets it as either STATIC# or SHARED, and provides the relative paths to its source code.# You can define multiple libraries, and CMake builds them for you.# Gradle automatically packages shared libraries with your APK.# 设置native目录set(NATIVE_DIR $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp)# 设置dlibinclude($&#123;NATIVE_DIR&#125;/dlib/cmake)include_directories($&#123;JNI_LIBS_DIR&#125;/includes)set(JNI_LIBS_DIR $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp)add_library( # Sets the name of the library. native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/native-lib.cpp src/main/cpp/matutil.cpp src/main/cpp/effective.cpp src/main/cpp/face_detector.cpp )include_directories($&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp)# Searches for a specified prebuilt library and stores the path as a# variable. Because CMake includes system libraries in the search path by# default, you only need to specify the name of the public NDK library# you want to add. CMake verifies that the library exists before# completing its build.add_library(libopencv_java # 库名字 SHARED IMPORTED)set_target_properties( libopencv_java PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/libs/armeabi-v7a/libopencv_java.so)find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log )# Specifies libraries CMake should link to your target library. You# can link multiple libraries, such as libraries you define in this# build script, prebuilt third-party libraries, or system libraries.target_link_libraries( # Specifies the target library. native-lib libopencv_java android jnigraphics dlib # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125; )# 指定release编译选项set(CMAKE_C_FLAGS_RELEASE &quot;$&#123;CMAKE_C_FLAGS_RELEASE&#125; -s -O3 -Wall&quot;)set(CMAKE_CXX_FLAGS_RELEASE &quot;$&#123;CMAKE_CXX_FLAGS_RELEASE&#125; -s -O3 -Wall&quot;) 添加cpp源文件处理 在 dlib 文件夹下添加文件 opencv_dlib_bridge.h 内容如下 1234567891011121314151617#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;namespace std&#123; template &lt;typename T&gt; std::string to_string(const T&amp; n) &#123; std::ostringstream stm; stm &lt;&lt; n; return stm.str(); &#125; template &lt;typename T&gt; T round(T v) &#123; return (v&gt;0)?(v+0.5):(v-0.5); &#125;&#125; demo 参考: https://github.com/kongxs/face","categories":[{"name":"Android","slug":"Android","permalink":"http://wanke.fun/categories/Android/"},{"name":"dlib","slug":"Android/dlib","permalink":"http://wanke.fun/categories/Android/dlib/"},{"name":"DIP","slug":"Android/dlib/DIP","permalink":"http://wanke.fun/categories/Android/dlib/DIP/"}],"tags":[],"author":"师学"},{"title":"数字图形处理一","slug":"数字图形处理一","date":"2020-05-15T09:13:00.000Z","updated":"2024-03-12T01:06:15.828Z","comments":true,"path":"DIP/数字图形处理一/","link":"","permalink":"http://wanke.fun/DIP/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E4%B8%80/","excerpt":"Digital Image Processing 图形和图像的区别 图形是由指令集构成，指令就是命令，由 位置 形状，颜色等进行描述 。记录和显示的是坐标，颜色是隐含的 。 moveTo lineTo 等。。 图像 更加直观，坐标是隐含的，显示的是颜色值 。 《计算机图形学》《计算机图像处理学》","text":"Digital Image Processing 图形和图像的区别 图形是由指令集构成，指令就是命令，由 位置 形状，颜色等进行描述 。记录和显示的是坐标，颜色是隐含的 。 moveTo lineTo 等。。 图像 更加直观，坐标是隐含的，显示的是颜色值 。 《计算机图形学》《计算机图像处理学》 图像空间分辨率指图像数字化的空间精细成都， 灰度级分辨率即颜色深度，每一像素颜色值锁占的二进制位数，颜色深度越大，标识颜色的数目越多 数字图像处理的目的图像降噪，改变亮度颜色，增强或者抑制某些成分，几何变换，进而改善图像质量。 一般的图像处理流程 预处理(统一大小等) 图像分割 (边缘检测，区域分割等) 特征提取 图像识别 图像分析 1. 图像的灰度化处理在图像处理中，灰度化是一种很常用的图片处理手段 。 方法1：求出每个像素点的RGB三个分量的平均值，然后将这个平均值赋予给这个像素的三个分量方法2：求RGB和YUV颜色空间的变化关系，建立亮度Y与RGB三个颜色分量的对应关系：Y&#x3D;0.3R+0.59G+0.11B，以这个亮度值表达图像的灰度值。OpenCV的cvtColor函数，可以直接完成灰度化操作。 123456789101112131415for (int i = 1 ; i &lt; src.rows; i++) &#123; for (int j = 1 ; j &lt; src.cols; j++) &#123; int b = src.at&lt;Vec3b&gt;(i , j)[0]; int g = src.at&lt;Vec3b&gt;(i , j)[1]; int r = src.at&lt;Vec3b&gt;(i , j)[2]; uchar gray = 0.11f*r + 0.59f*g + 0.30f*b; src.at&lt;Vec3b&gt;(i , j)[0] = gray; src.at&lt;Vec3b&gt;(i , j)[1] = gray; src.at&lt;Vec3b&gt;(i , j)[2] = gray; &#125; &#125; 2. 图像的二值化图像的二值化就是将图像上的像素点的灰度值设置为0或255，这样将使整个图像呈现出明显的黑白效果。在数字图像处理中，二值图像占有非常重要的地位，图像的二值化使图像中数据量大为减少，从而能凸显出目标的轮廓。 1234567891011121314151617181920212223242526for (int i = 1; i &lt; src.rows; i++) &#123; for (int j = 1; j &lt; src.cols; j++) &#123; int b = src.at&lt;Vec3b&gt;(i ,j)[0]; int g = src.at&lt;Vec3b&gt;(i ,j)[1]; int r = src.at&lt;Vec3b&gt;(i ,j)[2]; if (b &gt; 100) &#123; src.at&lt;Vec3b&gt;(i ,j)[0] =255; &#125; else &#123; src.at&lt;Vec3b&gt;(i ,j)[0] = 0; &#125; if (g &gt; 100) &#123; src.at&lt;Vec3b&gt;(i ,j)[1] =255; &#125; else &#123; src.at&lt;Vec3b&gt;(i ,j)[1] = 0; &#125; if (r &gt; 100) &#123; src.at&lt;Vec3b&gt;(i ,j)[2] =255; &#125; else &#123; src.at&lt;Vec3b&gt;(i ,j)[2] = 0; &#125; &#125; &#125; 3. 图形变换基础平移，比例缩放，旋转，镜像 齐次坐标表示法： 用N+1维向量标识N维向量的方法 ，（x，y）投影在 xyz三维立体空间的z&#x3D;1的平面上 。 4. 图像增强和灰度变换利用 点运算 输入图像 f(x,y) 输出图像 g(x,y) ， gx &#x3D; T(f(x,y)) 。 不改变空间和位置，逐点运算进行转换。 点运算 又称为 对比度增强，对比度拉伸，灰度变换 。 线性变换 输入和输出呈线性比例关系，g(x,y) &#x3D; T(f(x,y)) &#x3D; a f(x,y) + b a &gt; 0 输出图像对比度增大 ，a &lt; 0 输出图像对比度减小 a&#x3D;1 ,b ≠ 0 ，灰度值上下移，对应变亮或者变暗 a &lt; 0 相反的，亮变暗，暗变亮 5. 平滑处理的概念 线性平滑每一个像素的灰度值用它的邻域值代替，邻域为 n✖️n (n取奇数) 非线性平滑取一个阈值，当像素与邻域平均值之间的差大于阈值已均值代替，否则不变 自适应平滑 6. 图像去噪和添加椒盐噪声二值图像的去噪用3✖️3的模板进行均值滤波，当f(x,y)周围的8个像素平均值为 a 时候若 |f(x,y) -a | &gt; 127.5 则对f(x,y)进行黑白翻转，否则不变 邻域平均法： 算法简单，计算速度快，但是会造成一定程度的模糊改进： 选择邻域的大小，形状，方向， 邻域加权平均法将模板系数与对应像素的灰度值相乘，将所有乘积累加，用所得结果代替原中心像素。&lt;例如：高斯离散模板&gt; 超限邻域平均法给定一个灰度值作为阈值，如果像素点大于邻域8个像素平均值并且超过了阈值，用平均灰度替换。 N✖️N均值滤波器: f(x,y)为中心的 N✖️N的窗口，当平均灰度为a时，f(x,y) &#x3D; a。 N 越大，那么噪声消除越明显 。 均值滤波器以图像的模糊为代价 。 均值滤波法对n✖️n的窗口进行取平均数 中值滤波法对n✖️n的窗口进行排序，取中间值 . 对椒盐噪声有很好的效果 6. 图像边缘锐化锐化的基本方法 ： 微分运算 边缘检测 梯度锐化 锐化的目的： 增强边界信息 提取物体边界 单向微分运算： 纵向： G(i,j) &#x3D; f(i,j) - f(i-1,j)横向： G(i,j) &#x3D; f(i,j) - f(i,j-1) 双向微分，同时增强两个方向的边缘： G(i ,j) &#x3D; sqrt { [f(i,j) - f(i-1,j) * f(i,j) - f(i-1,j)] + [f(i,j) - f(i,j-1) * f(i,j) - f(i,j-1) ] } 通常情况下，边缘上的灰度变化平缓，而边缘两侧灰度变化较快。一般是亮度变化最显著的部分。 高斯拉普拉斯算子，是更好的边缘检测，把高斯平滑器和拉普拉斯锐化结合起来，先平滑掉噪声，再进行边缘检测。 7. 图像边缘检测7. 图像阈值分割 直方图门限选择 迭代阈值分割 阈值选择： 可通过输出直方图来确定。 假设只有背景和物体组成，那么直方图灰度具有明显的双峰值。 - 找到谷底即可 8. 形态学基本概念腐蚀，膨胀，开运算 - 先腐蚀后膨胀 闭运算 - 先膨胀后腐蚀 细化，粗化，中轴变换","categories":[{"name":"DIP","slug":"DIP","permalink":"http://wanke.fun/categories/DIP/"}],"tags":[],"author":"师学"},{"title":"常用命令行commands","slug":"commands","date":"2020-05-08T05:59:00.000Z","updated":"2024-03-20T10:05:33.362Z","comments":true,"path":"Android/commands/","link":"","permalink":"http://wanke.fun/Android/commands/","excerpt":"一些常用的基础命令","text":"一些常用的基础命令 mac wechat123直接使用命令行： nohup /Applications/WeChat.app/Contents/MacOS/WeChat &gt; /tmp/wechat.txt 2&gt;&amp;1 &amp; class2jar1234561. jar -cvf result.jar classPath 生成jar包2. jar umf MANIFEST.MF hello.jar 更新清单，可以指定入口类，生成可执行jar包 Manifest-Version: 1.0 Main-Class: xxxx.class jar2dex1dx --dex --output result.dex source.jar zip,unzip123zip -q -r *.jar ./dirunzip source -d ./dir zipalign apk对齐1234zipalign -v -p 4 source.apk aligned.apk4字节 也就是32位对齐 apksigner 签名12345678910apksigner sign --ks [xx.keystore] --ks-key-alias [证书名] --ks-pass pass:[xx] --out sign.apk unsign.apk--ks //jks签名证书路径--ks-key-alias 你的alias 名字 //生成jks时指定的alias--ks-pass pass:你的密码 //KeyStore密码--out output.apk //输出路径input.apk //被签名的apk 1234567891011java -jar apksigner_30.0.2.jar sign -verbose --ks game8u.keystore --v1-signing-enabled true --v2-signing-enabled false --v3-signing-enabled false --v4-signing-enabled false --ks-key-alias game8u --ks-pass pass:admin0A --key-pass pass:admin0A --out 7944_sign.apk 7944_unsign.apk --ks 签名文件位置 --v1-signing-enabled true|false --v2-signing-enabled true|false --v3-signing-enabled true|false --v4-signing-enabled true|false --ks-key-alias 签名别名 --ks-pass pass: 签名文件密码 --key-pass pass:签名别名密码 --out 输出文件 apkTools12345678910111213141516171819 DecodingThe decode option can be invoked either from d or decode like shown below.$ apktool d foo.jar# decodes foo.jar to foo.jar.out folder$ apktool decode foo.jar# decodes foo.jar to foo.jar.out folder$ apktool d bar.apk# decodes bar.apk to bar folder$ apktool decode bar.apk# decodes bar.apk to bar folder$ apktool d bar.apk -o baz# decodes bar.apk to baz folder 1234567891011121314151617181920212223 BuildingThe build option can be invoked either from b or build like shown below$ apktool b foo.jar.out# builds foo.jar.out folder into foo.jar.out/dist/foo.jar file$ apktool build foo.jar.out# builds foo.jar.out folder into foo.jar.out/dist/foo.jar file$ apktool b bar# builds bar folder into bar/dist/bar.apk file$ apktool b .# builds current directory into ./dist$ apktool b bar -o new_bar.apk# builds bar folder into new_bar.apk$ apktool b bar.apk# WRONG: brut.androlib.AndrolibException: brut.directory.PathNotExist: apktool.yml# Must use folder, not apk/jar file dex &amp; smali12345dex2malijava -jar baksmali-2.5.2.jar d classes.dex -o tmpsmali2dexjava -jar smali-2.5.2.jar a tmp -o tmp.dex 反编译实例123456789101112131415把apk文件反编译java -jar apktool.jar d *.apk jar转为dexdx --dex --output *.dex classes.jar反编译 dex java -jar baksmali.jar d *.dex -o /dir 替换文件以后 把 app-debug 回编译为 apk java -jar apktool.jar b /dir -o unsign.apk签名： apksigner sign --ks *.keystore --ks-key-alias [alias] --ks-pass pass:[admin] --out sign.apk unsign.apk python1234567windows ： py2exe ,mac ： py2app : py2applet --make-setup xxx.py 修改setup文件，写入要执行的py源文件python setup.py py2app -A 生成可执行文件 adb12345678910111213141516171819202122//遍历设备安装packageadb shell pm list package//安装包base.apkadb shell pm path [pkgName]//将移动设备中的文件传送到PC上adb pull 移动设备路径 PC路径//将PC中的文件传送到移动设备端adb push PC路径 移动设备路径adb push PC路径 /sdcard/启动appadb shell am start -D -S -W [pkg]/[mainActivity]获取app pidadb shell ps | grep [pkg]端口转发adb forward tcp:5005 jdwp:3013","categories":[{"name":"Android","slug":"Android","permalink":"http://wanke.fun/categories/Android/"}],"tags":[],"author":"师学"},{"title":"mvp","slug":"mvp","date":"2020-04-20T10:26:00.000Z","updated":"2024-03-12T01:06:15.827Z","comments":true,"path":"Android/mvp/mvp/","link":"","permalink":"http://wanke.fun/Android/mvp/mvp/","excerpt":"在更早做Android项目中，一直在使用mvc这种模式进行开发 。","text":"在更早做Android项目中，一直在使用mvc这种模式进行开发 。 从2017年开始接触mvp在项目中应用以来，关于mvc和mvp两种开发模式一直在 混合使用， 个人理解开发模式只有相对的合适，而没有绝对的好坏，每一种模式都有存在的好与坏 。结合项目规模协作等具体实际进行选择就好。 在传统的mvc模式中，activity承担了更多的职责， 更主要的是作为 controller这种角色，控制逻辑和view的操作都在此完成，是的 activity变得臃肿 。 在一个复杂的页面中动辄上千行代码 ，既不美观，更无优雅可言。 对于后期的维护和扩展更是加大了难度 。 mvp的思想，将 controller的职能从 activity解放到presenter， activity作为view层的输入和输出同 presenter进行交互，presenter作为view和model的桥梁，承上启下。model — presenter — view mvp对于多人协同的项目更加适用 ，方便进行view视图管理 ， model数据处理 ，presenter逻辑进行多人协作。 于此同时，mvp也会带来类接口的爆炸，内存泄漏风险 。 https://github.com/kongxs/PluginProject ： mvp","categories":[{"name":"Android","slug":"Android","permalink":"http://wanke.fun/categories/Android/"},{"name":"mvp","slug":"Android/mvp","permalink":"http://wanke.fun/categories/Android/mvp/"}],"tags":[],"author":"师学"},{"title":"Android 换肤技术点","slug":"Android-换肤技术点","date":"2020-04-09T01:25:00.000Z","updated":"2024-03-12T01:06:15.823Z","comments":true,"path":"Android/Android-换肤技术点/","link":"","permalink":"http://wanke.fun/Android/Android-%E6%8D%A2%E8%82%A4%E6%8A%80%E6%9C%AF%E7%82%B9/","excerpt":"1. 切换自定义Theme优点： 实现简单 ，无侵入，易于理解 ,兼容性能好 缺点： 不能实时生效，静态更新，要在setContentView之前切换theme , 自定义属性 ：","text":"1. 切换自定义Theme优点： 实现简单 ，无侵入，易于理解 ,兼容性能好 缺点： 不能实时生效，静态更新，要在setContentView之前切换theme , 自定义属性 ： 12345&lt;resources&gt; &lt;attr name=&quot;textColor&quot; format=&quot;reference|color&quot;/&gt; &lt;attr name=&quot;background&quot; format=&quot;reference|color&quot;/&gt;&lt;/resources&gt; 自定义样式： 12345678910&lt;style name=&quot;AppTheme_Light&quot; &gt; &lt;item name=&quot;textColor&quot;&gt;@android:color/black&lt;/ item&gt; &lt;item name=&quot;android:background&quot;&gt;@android:color/white&lt;/ item&gt;&lt;/style&gt; &lt;style name=&quot;AppTheme_Night&quot;&gt; &lt;item name=&quot;textColor&quot;&gt;@android:color/white&lt;/ item&gt; &lt;item name=&quot;android:background&quot;&gt;@android:color/black&lt;/ item&gt;&lt;/style&gt; 应用： 1234567&lt;TextView android :layout_width=&quot;wrap_content&quot; android :layout_height=&quot;wrap_content&quot; android :text=&quot;Hello World!&quot; android :background=&quot;?attr/background&quot; android :textColor=&quot;?attr/textColor&quot;/&gt; 123456789protected void skinChange() &#123; TypedValue background = new TypedValue(); TypedValue textColor = new TypedValue(); Resources.Theme theme = getTheme(); theme.resolveAttribute(R.attr.background, background, true); theme.resolveAttribute(R.attr.textColor, textColor, true); mTextView .setTextColor(textColor.data); mTextView.setBackgroundResource(background.resourceId);&#125; 2. 侵入式换肤框架主要介绍一种侵入式方案的实现 优点： 使用简单，可以动态替换网络上下载的皮肤包 缺点： 侵入式 可能存在兼容性问题 2.1 LayoutInflater加载首先是view的加载流程 activity.java123public void setContentView(int layoutResID) &#123; getWindow().setContentView(layoutResID); &#125; PhoneWindow.java 12345678@Override public void setContentView(int layoutResID) &#123; ... mLayoutInflater.inflate(layoutResID, mContentParent); ... &#125; LayoutInflater.java 12345678910111213141516171819202122232425262728293031323334353637public View inflate(int resource, ViewGroup root, boolean attachToRoot) &#123; ... XmlResourceParser parser = getContext().getResources().getLayout(resource); try &#123; return inflate(parser, root, attachToRoot); &#125; finally &#123; parser.close(); &#125; &#125; public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) &#123; ... View temp = createViewFromTag(name, attrs); ...&#125;View createViewFromTag(String name, AttributeSet attrs) &#123; ... View view = (mFactory == null) ? null : mFactory.onCreateView(name, mContext, attrs); if (view == null) &#123; if (-1 == name.indexOf(&#x27;.&#x27;)) &#123; view = onCreateView(name, attrs); &#125; else &#123; view = createView(name, null, attrs); &#125; &#125; if (DEBUG) System.out.println(&quot;Created view is: &quot; + view); return view; ... &#125; 我们重点看 createViewFromTag ， 经过上面一系列步骤，我们看到了view的创建，首先会通过 mFactory ， 1public void setFactory(Factory factory) 通过 设置 factory，我们可以接管view的创建流程 2.2 加载外部资源皮肤包皮肤包就是一个空的apk文件，只有 drawable，color 等 123456789101112131415161718192021Resources skinResource = null; try &#123; File file = new File(skinPath); if(file == null || !file.exists())&#123; return null; &#125; PackageManager mPm = mContext.getPackageManager(); PackageInfo mInfo =mPm.getPackageArchiveInfo(skinPath, PackageManager.GET_ACTIVITIES); mSkinPackageName = mInfo.packageName; AssetManager assetManager = AssetManager.class.newInstance(); Method addAssetPath = assetManager.getClass().getMethod(&quot;addAssetPath&quot;, String.class); addAssetPath.invoke(assetManager, skinPath); Resources superRes = mContext.getResources(); skinResource = new Resources(assetManager,superRes.getDisplayMetrics(),superRes.getConfiguration()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 代码托管： https://github.com/kongxs/PluginProject","categories":[{"name":"Android","slug":"Android","permalink":"http://wanke.fun/categories/Android/"}],"tags":[],"author":"师学"},{"title":"Lock 锁的理解","slug":"Lock-锁的理解","date":"2020-01-02T07:11:00.000Z","updated":"2024-03-12T01:06:15.825Z","comments":true,"path":"Java/Lock-锁的理解/","link":"","permalink":"http://wanke.fun/Java/Lock-%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"不同于 synchronize关键字 ，从 1.5开始 lock是jdk提供给我们的api","text":"不同于 synchronize关键字 ，从 1.5开始 lock是jdk提供给我们的api Lock 锁:lock 和 synchronize的区别： 前者通过开发者调用代码手工获取，后者通过jvm自动获取 前者务必通过unlock在finally中手工释放，后者jvm自动释放 前者通过java代码实现，后者jvm底层实现 前者提供了多种 ，入公平锁，非公平锁。前后两者都提供了可重入锁 Condition:传统上我们实现对于线程的调度和控制，是基于 wait和notify实现。 lock 给我们提供了 await 和 singalAll来实现线程调度，这种方式更加灵活，可控对于传统的synchronize来说，所有的等待都是在同一个集合中的，而Condition则可以拥有多个 。","categories":[{"name":"Java","slug":"Java","permalink":"http://wanke.fun/categories/Java/"}],"tags":[],"author":"师学"},{"title":"谈谈单例 ","slug":"谈谈单例","date":"2019-12-23T02:39:00.000Z","updated":"2024-03-12T01:06:15.829Z","comments":true,"path":"Java/谈谈单例/","link":"","permalink":"http://wanke.fun/Java/%E8%B0%88%E8%B0%88%E5%8D%95%E4%BE%8B/","excerpt":"DCLdcl 实现的单例模式的一种可靠方式是添加 volatile关键字 。","text":"DCLdcl 实现的单例模式的一种可靠方式是添加 volatile关键字 。 volatile 有如下的特点： 有序性，防止重排序 可见性 ，屏蔽local cache，变量的操作对于主存立即可见 在java中，对象的创建有如下的几个步骤 分配对象内存空间 初始化对象 设置instance指向刚刚分配的内存地址, 此时instance !&#x3D; null (重点) 只有这三个步骤完成了，才算是一个对象的初始化完成。 计算机指令 CPU 和编译器为了提高执行效率，会对代码进行优化 即重排序 ，只要最终的输出结果是正确的即可。 那么在对象创建的过程中，有可能编程了如下的顺序 分配对象内存空间 设置instance指向刚刚分配的内存地址, 此时instance !&#x3D; null (重点) 初始化对象 当第一个线程拿到锁并且进入到第二个if方法后, 先分配对象内存空间, 然后再instance指向刚刚分配的内存地址, instance 已经不等于null, 但此时instance还没有初始化完成。如果这个时候又有一个线程来调用getInstance方法, 在第一个if的判断结果就为false, 于是直接返回还没有初始化完成的instance, 那么就很有可能产生异常。 12345678910111213141516public class Singleton &#123; private volatile static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 在new关键字背后，有如下步骤与 在堆内存中创建对象实例 为实例对象赋初值 返回对象引用 静态内部类模式123456789101112public class CustomManager&#123; private CustomManager()&#123;&#125; private static class CustomManagerHolder &#123; private static final CustomManager INSTANCE = new CustomManager(); &#125; public static CustomManager getInstance() &#123; return CustomManagerHolder.INSTANCE; &#125; &#125; 静态内部类的原理是： 当 SingleTon 第一次被加载时，并不需要去加载 SingleTonHoler，只有当 getInstance() 方法第一次被调用时，才会去初始化 INSTANCE，这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。getInstance 方法并没有多次去 new 对象，取的都是同一个 INSTANCE 对象。 虚拟机会保证一个类的 () 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 () 方法，其他线程都需要阻塞等待，直到活动线程执行 () 方法完毕 缺点在于无法传递参数，如Context等","categories":[{"name":"Java","slug":"Java","permalink":"http://wanke.fun/categories/Java/"}],"tags":[],"author":"师学"},{"title":"synchronized 深入理解","slug":"synchronized-深入理解","date":"2019-12-12T03:29:00.000Z","updated":"2024-03-12T01:06:15.827Z","comments":true,"path":"Java/JavaConcurrent/synchronized-深入理解/","link":"","permalink":"http://wanke.fun/Java/JavaConcurrent/synchronized-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/","excerpt":"synchronize是jdk提供的进行辅助同步的关键字。它可以修饰一个 方法体，可以同步代码块修饰一个对象。","text":"synchronize是jdk提供的进行辅助同步的关键字。它可以修饰一个 方法体，可以同步代码块修饰一个对象。 修饰一个成员函数 会对当前对象实例进行加锁， 每一个对象实例只有一把锁，也就是说在同一时刻只会有一个方法被执行 。 修饰一个静态函数 修饰静态函数时 ，会对当前对象的class对象进行枷锁，不管生成多少个对象实例，它的calss对象是唯一的 当使用synchronize在函数内修饰一个代码块时 ，会在底层字节码生成一个 monitorenter 以及一个或者多个 monitorexit指令与之相对应，保障锁被释放 当使用synchronize修饰一个函数时候，会在方法添加一个 acc_synchronize 。jvm来使用acc_synchronize来来表示这个同步方法 。 当方法被调用时，jvm会先持有当前对象的monitor方法，然后在去执行方法体，在方法执行期间，其他线程均无法获取次monitor ，当线程执行完该方法，就会释放monitor flags: ACC_SYNCHRONIZED jvm中是基于进入和退出监视器对象( Monitor) 来实现的，每个对象实例都会有一个Monitor对象会和java对象一起创建(c++)和销毁 。 当多个线程同时访问一个同步代码时候，代码会被放到一个EetryList集合中，处于阻塞的线程都会放到该列表当中，接下里，当线程获取到Monitor时候依赖底层操作系统的 mutex lock来实现互斥 ，线程获取mutex成功，会持有它，其他线程就无法获取到该mutex 。 如果该线程中调用了 wait方法，那么就会释放掉它持有的mutex ，并且该线程进入waitset集合当中，等待被其他线程唤醒，如果方法执行完毕也会释放mutex 同步锁的这种实现方式，因为Monitor依赖底层操作系统的实现 ， 所以存在用户态和内核态之间的切换， 会增加内存开销。 自旋锁： 因为内核态和用户态之前的切换会增加内存开销，所以jvm引入了自旋的方式。 其原理是当发生对monitor的争夺时，如果owner会很快执行结束，那么就让参与争夺的线程稍微等待一下(所谓的自旋) ，不进入内存态 。 自旋会增加cpu消耗 在 owner释放monitor后，争夺的线程可能会立刻获取到锁去执行代码 ，从而避免阻塞。 不过，当owner执行时间超过临界以后， 会停止自旋进入阻塞。 总体思想是 ： 先自旋(spin)，不成功再阻塞，尽量降低阻塞的可能性 。对于执行时间短的代码有很大的提升，在多处理器的上会有意义。 互斥锁的属性： pthread_mutext_timed_np : 普通锁，当一个线程获取到锁以后，其余线程会进入阻塞队列 ，当锁被释放以后，会按照优先级获取到锁 。 pthread_mutext_rersursive_np : 嵌套锁，允许一个线程对通一把锁获取多次，并通过unlock进行解锁， 如果是不同线程请求，那么则在加锁线程执行结束以后再重新进行竞争 。 pthread_mutext_errorcheck_np : 检错锁， 如果一个线程请求同一把锁，那么返回edeadlk， 否则和 pthread_mutext_timed_np 相同， 保证了不允许多次加锁会后的死锁问题。 pthread_mutext_adaptive_np : 适应锁： 仅仅等待解锁后进行竞争。 在jdk1.5之前，只能通过synchronize关键字来实现线程同步 。在底层java也是通过synchronize关键字来实现原子操作的。它是一种内置锁， 是jvm进行隐式实现的。 从jdk1.5开始引入了java并发包 lock相关的锁 。lock本身是基于java来实现的，锁的获取和释放都是通过java来实现的，然而synchronize是通过系统底层的mutex_lock实现的，每次对锁的获取和释放都会带来用户态和内核态的切换，增加系统开销。在并发较高或者锁竞争很激烈的时候，synchronize的性能会很差。 从jdk1.6开始，synchronize的实现发生很大的优化。 引入了【偏向锁，轻量级锁，重量级锁】的概念 ， 从而减少在用户态和内核态之间的切换 ，使得尽量发生在用户态。 这种锁的优化，实际上是通过java对象头中的一些标志位来实现的 ，对于锁的访问和改变都与对象头息息相关。 从jdk1.6开始，对象实例划分为三部分，对象头，实例数据， 对齐填充 。 对象头的组成： mark word 指向类的指针 数组长度 其中mark word 里面记录了对象的锁和垃圾回收相关的信息，在64位jvm中长度是64bit，包括如下信息： 无锁标记 偏向锁标记 轻量锁标记 重量锁标记 GC标记 对于synchronize来说，锁的升级主要是通过mark word中的锁标志位和是否偏向锁标志位来实现的。 synchronize中的锁都是从偏向锁开始逐步升级，演化成轻量级锁，最后变成了重量级锁。 对于锁的演化有如下阶段： 无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁我们也可以通过jvm参数来决定是否要是哪种锁。 偏向锁 (偏向锁标记，对应的线程id ):针对于一个线程来说的 , 优化同一个线程多次获取一个锁的情况，如果一个synchronize方法被一个线程访问，那么这个方法所在的对象，会在其mark word中将偏向锁进行标记，同时还会存储该线程的id ，当这个线程访问同一个synchronize方法，会检查mark word 的偏向锁标记和线程id ，如果是同一个，那么不会进入管程(monitor)，而直接执行方法体 。如果另外一个线程访问了同步方法，如果获取锁失败，偏向锁会被取消，升级成轻量级锁。如果是大量的并发，那偏向锁性能开销反而会更大，可以通过jvm参数关闭偏向锁。 轻量级锁 :如果当前锁已经被第一个线程获取，那么这时候还有其他线程尝试去争夺锁，由于锁已经被第一个线程获取，第二个线程去争夺时候，会发现mark word中已经是偏向锁，里面存储的线程id并不是自己，那么会进入CAS(compare and swap) ,从而获取到锁，这里存在2中情况： 获取锁成功，将mak word中的线程id修改为自己 ，保持偏向锁状态。 获取失败，表示有多个线程进行争夺，那么升级成轻量级锁。 比较理想的情况是适合 2个线程互相的轮流进行访问 自旋锁（轻量的一种实现方式）： 当自旋依然失败， 转为重量级锁，无法获取到锁的线程都会进入到monitor 内核态。 自旋最大的特点是避免进入内核态，但是会增加cpu开销 。 重量级锁 :线程最终从用户态进入内核态。 锁消除 :使用逃逸分析的技术检测是否锁对象只会被一个线程使用，不会散布到其他线程。 那么不会生成synchronize关键字对应的申请与释放机器码， 从而消除锁的使用流程。 123456public void tet() &#123; Object object = new Object(); synchronized (object) &#123; throw new RuntimeException(); &#125; &#125; 锁粗化 :jit若发现相邻的同步代码块锁的是同一个对象，就会合并成一个大的同步代码 ， 从而达到无需频繁的申请和释放锁 ，从而提高性能。 123456789public void tet() &#123; synchronized (object) &#123; &#125; synchronized (object) &#123; &#125; synchronized (object) &#123; &#125; &#125; Lock 锁:lock 和 synchronize的区别： 前者通过开发者调用代码手工获取，后者通过jvm自动获取 前者务必通过unlock在finally中手工释放，后者jvm自动释放 前者通过java代码实现，后者jvm底层实现 前者提供了多种 ，入公平锁，非公平锁。前后两者都提供了可重入锁","categories":[{"name":"Java","slug":"Java","permalink":"http://wanke.fun/categories/Java/"},{"name":"JavaConcurrent","slug":"Java/JavaConcurrent","permalink":"http://wanke.fun/categories/Java/JavaConcurrent/"}],"tags":[],"author":"师学"},{"title":"写一个死锁","slug":"写一个死锁","date":"2019-12-11T12:16:00.000Z","updated":"2024-03-12T01:06:15.827Z","comments":true,"path":"Java/写一个死锁/","link":"","permalink":"http://wanke.fun/Java/%E5%86%99%E4%B8%80%E4%B8%AA%E6%AD%BB%E9%94%81/","excerpt":"死锁","text":"死锁 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Test03 &#123; Object lock1 = new Object(); Object lock2 = new Object(); public void method1() &#123; synchronized (lock1) &#123; synchronized (lock2) &#123; System.out.println(&quot;method 1 .... &quot;); &#125; &#125; &#125; public void method2() &#123; synchronized (lock2) &#123; synchronized (lock1) &#123; System.out.println(&quot;method 2 .... &quot;); &#125; &#125; &#125; public static void main(String[] args) &#123; Test03 test03 = new Test03(); new Thread(() -&gt; &#123; while (true) &#123; test03.method1(); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); new Thread(() -&gt; &#123; while (true) &#123; test03.method2(); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125;&#125; 执行结果： 123&gt; Task :Test03.main()method 1 .... method 2 .... 发生死锁，打印也被阻塞 检测死锁： jvisualvm 工具 ， 命令行工具 jps 找到我们运行的程序 pid jstck pid","categories":[{"name":"Java","slug":"Java","permalink":"http://wanke.fun/categories/Java/"}],"tags":[],"author":"师学"},{"title":"wait notify 深入理解","slug":"wait-notify-深入理解","date":"2019-12-11T01:47:00.000Z","updated":"2024-03-12T01:06:15.827Z","comments":true,"path":"Java/JavaConcurrent/wait-notify-深入理解/","link":"","permalink":"http://wanke.fun/Java/JavaConcurrent/wait-notify-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/","excerpt":"wait 和 notify 是object类的方法 ，也就是说在java世界里，所有的class对象都会持有这2个方法。在使用过程中，wait 和 notify一定是成对出现的。 在调用wait时候，线程必须持有被调用对象的锁。当wait被调用，线程就会释放持有的对象锁 。 sleep方法并不会释放锁。","text":"wait 和 notify 是object类的方法 ，也就是说在java世界里，所有的class对象都会持有这2个方法。在使用过程中，wait 和 notify一定是成对出现的。 在调用wait时候，线程必须持有被调用对象的锁。当wait被调用，线程就会释放持有的对象锁 。 sleep方法并不会释放锁。 关于wait 和 notify方法的总结： 调用wait时候，首先要保证线程是有了对象的锁 调用了wait后，线程释放当前对象锁，并且进入等待 进入等待状态后，会等待其他线程调用 notify或者notifyAll 进行唤醒 当线程被唤醒后，就会和线程一起竞争对象锁(公平竞争)，只有当线程获取到锁，才会继续执行 调用wait的代码需要放在 synchronize 方法或者 synchronize代码块中，保证代码在调用wait时候，已经获取锁。 当调用notify方法时候，会随机唤醒正在等待唤醒线程集合中的一个，一旦获取到锁，才会继续往下执行 在某一时刻，只会有一个线程会持有对对象锁 需求： 使用线程按照101010…..这种顺序打印下面的代码实现中，利用 wait和 notify ，在2线程中分别进行数据的加和减 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class Test01 &#123; public static void main(String[] args) &#123; Bucket bucket = new Bucket(); new Thread(new Product(bucket) , &quot;product - 1&quot;).start(); new Thread(new Consumer(bucket), &quot;consumer - 1&quot;).start(); &#125;&#125;class Bucket &#123; private int count = 0 ; public synchronized void getCount() &#123; if (count != 1) &#123; try &#123; System.out.println(&quot;线程： &quot; + Thread.currentThread().getName() + &quot;进入等待 &quot;); wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; count--; System.out.println(&quot;线程： &quot; + Thread.currentThread().getName() + &quot; count = &quot; + count); notify(); &#125; public synchronized void setCount() &#123; if (count!= 0) &#123; //wait try &#123; System.out.println(&quot;线程： &quot; + Thread.currentThread().getName() + &quot;进入等待 &quot;); wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; count++; System.out.println(&quot;线程： &quot; + Thread.currentThread().getName() + &quot; count = &quot; + count); notify(); &#125;&#125;class Consumer implements Runnable &#123; private final Bucket bucket; public Consumer(Bucket bucket) &#123; this.bucket = bucket; &#125; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(new Random().nextInt(1000) + 100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; bucket.getCount(); &#125; &#125;&#125;class Product implements Runnable &#123; private final Bucket bucket; public Product(Bucket bucket) &#123; this.bucket = bucket; &#125; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(new Random().nextInt(1000) + 100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; bucket.setCount(); &#125; &#125;&#125; 执行结果，如预期 ： 线程： consumer - 1进入等待 线程： product - 1 count = 1 线程： consumer - 1 count = 0 线程： product - 1 count = 1 线程： consumer - 1 count = 0 线程： product - 1 count = 1 下面我们对程序做一次改造 ，在main方法里面 各自使用2个线程进行操作。 1234567891011public static void main(String[] args) &#123; Bucket bucket = new Bucket(); new Thread(new Product(bucket) , &quot;product - 1&quot;).start(); new Thread(new Product(bucket) , &quot;product - 2&quot;).start(); new Thread(new Consumer(bucket), &quot;consumer - 1&quot;).start(); new Thread(new Consumer(bucket), &quot;consumer - 2&quot;).start(); &#125; 执行结果： 线程： product - 2 count = 1 线程： consumer - 2 count = 0 线程： consumer - 2进入等待 线程： consumer - 1进入等待 线程： product - 1 count = 1 线程： consumer - 2 count = 0 线程： consumer - 1 count = -1 线程： product - 2进入等待 线程： product - 1进入等待 线程： consumer - 2进入等待 线程： consumer - 1进入等待 ...... 线程进入了挂起状态，也不再打印结果 在使用了多个线程以后，我们的程序执行结果失控了 。。。下面我们对2种情况进行分析 ，首先是单个线程： 在Bucket中 ，我们调用了wait和notify ，因为只有2个线程，所以当我们其中一个线程进入wait，另外一个线程一定会被唤醒 ，所以 product-1 和 consum-1 有序的进行增加和减少，保证了我们的运行结果 。 在多个product和consume线程的模式下， 担当product-1获取到锁，如果满足 count !&#x3D; 0 那么进入wait，唤醒其他等待队列中的任意一个线程。 假如product-2被唤醒，这时候也满足了 count!&#x3D;0 这个条件，product-2也进入wait 这时候等待队列中的任意一个被欢迎，如果是product-1 那么继续往下执行，count++，并唤醒等待队列中的线程 product-2被唤醒，也执行 count++ ，那么就出现了我们上面失控的结果 解决方案： 12345public synchronized void getCount() &#123; if (count != 1) &#123; public synchronized void getCount() &#123; while (count != 1) &#123; 将 if 修改为while ， 让程序获取到锁以后，再次检查count的状态即可","categories":[{"name":"Java","slug":"Java","permalink":"http://wanke.fun/categories/Java/"},{"name":"JavaConcurrent","slug":"Java/JavaConcurrent","permalink":"http://wanke.fun/categories/Java/JavaConcurrent/"}],"tags":[],"author":"师学"},{"title":"jvm gc实践","slug":"jvm-gc实践","date":"2019-12-10T08:41:00.000Z","updated":"2024-03-12T01:06:15.826Z","comments":true,"path":"Jvm/jvm-gc实践/","link":"","permalink":"http://wanke.fun/Jvm/jvm-gc%E5%AE%9E%E8%B7%B5/","excerpt":"gc实践","text":"gc实践 1.编写代码如下 12345678public static void main(String[] args) &#123; int size = 1024 * 1024 ; byte[] alloc = new byte[2 * size] ; byte[] alloc2 = new byte[2 * size] ; byte[] alloc3 = new byte[2 * size] ; byte[] alloc4 = new byte[2 * size] ; System.out.println(&quot;hello world&quot;); &#125; jvm参数配置： vm option : -verbose:gc // 详细gc日志 -Xms20m // 堆初始大小 -Xmx20m // 堆最大值 -Xmn10m //新生代10m -XX:+PrintGCDetails // 详细垃圾回收信息 -XX:SurvivorRatio=8 // eden 和 survivor 占比 为 8 : 1 : 1 输出结果： 123456789101112[GC (Allocation Failure) [PSYoungGen: 6651K-&gt;480K(9216K)] 6651K-&gt;6632K(19456K), 0.0092862 secs] [Times: user=0.04 sys=0.00, real=0.01 secs] [Full GC (Ergonomics) [PSYoungGen: 480K-&gt;0K(9216K)] [ParOldGen: 6152K-&gt;6434K(10240K)] 6632K-&gt;6434K(19456K), [Metaspace: 2642K-&gt;2642K(1056768K)], 0.0048153 secs] [Times: user=0.02 sys=0.01, real=0.01 secs] hello worldHeap PSYoungGen total 9216K, used 2374K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000) eden space 8192K, 28% used [0x00000007bf600000,0x00000007bf851838,0x00000007bfe00000) from space 1024K, 0% used [0x00000007bfe00000,0x00000007bfe00000,0x00000007bff00000) to space 1024K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007c0000000) ParOldGen total 10240K, used 6434K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000) object space 10240K, 62% used [0x00000007bec00000,0x00000007bf248a90,0x00000007bf600000) Metaspace used 2650K, capacity 4486K, committed 4864K, reserved 1056768K class space used 286K, capacity 386K, committed 512K, reserved 1048576K 观测执行结果，我们发现，发生了一次minor gc，原因是 Allocation Failure PSYoungGen ： parallel scavenge 发生在新生代的gc 。 [PSYoungGen: 6651K-&gt;480K(9216K)] 6651K-&gt;6632K(19456K), 0.0092862 secs] ，minor gc 只会对新生代进行回收。 在年轻代gc前 存活对象占据的大小为6651 gc后为480 ，总容量 9216 gc前堆空间存活对象占据的大小为6651 执行后为6632 ， 总容量为 19456 发生了一次 full gc ： fullgc 会针对新生代，老年代，和元空间都进行gc 。 fullgc 应该尽量避免 。 老年代空间存对象反而增加了 。 直接在老年代去分配对象 。 在第一个例子的基础上 ，增加jvm启动参数： -XX:PretenureSizeThreshold&#x3D;3145728&#x2F;&#x2F; 1024 * 1024 * 3 -XX:+UseSerialGC 设定当新创建的对象超过我们设置的阈值，那么就会直接在老年代去分配内存。 这个参数要搭配 串行gc收集器才会起作用 代码： 1234public static void main(String[] args) &#123; int size = 1024 * 1024 ; byte[] alloc = new byte[size * 4]; &#125; 输出结果： 123456789Heapdef new generation total 9216K, used 656K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000) eden space 8192K, 8% used [0x00000007bec00000, 0x00000007beca4028, 0x00000007bf400000) from space 1024K, 0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000) to space 1024K, 0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)tenured generation total 10240K, used 5136K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000) the space 10240K, 50% used [0x00000007bf600000, 0x00000007bfb04020, 0x00000007bfb04200, 0x00000007c0000000)Metaspace used 2648K, capacity 4486K, committed 4864K, reserved 1056768K class space used 286K, capacity 386K, committed 512K, reserved 1048576K 设置可以晋升到老年代的对象最大存活年龄-XX:MaxTenuringThreshold&#x3D;5-XX:+PrintTenuringDistribution 我们设置 最大的新生代年龄超过5 的时候就晋升到老年代，注意：(有可能2岁就晋升，取决于jvm的实现，但是最大不超过我们设置的5 ) 在jvm中默认值为15 ，cms垃圾收集器中为6，G1中为15 (在jvm中使用4 bit 来标识年龄，1111 ，所以最大年龄为15) 经历过多次 minior GC 以后，存活的对象会在 from survivor 和 to survivor 中来回移动， 而且有一个前提是要有足够的控件来存放这些数据 。 在GC算法中会计算每个对象的年龄大小，当达到某个年后以后发现总大小已经超过 一个survivor空间的50% ，那么会调整阈值，而不是等到默认的年龄才完成晋升。 实战：MaxTenuringThreshold阈值动态调整12345678910-verbose:gc-Xmx200M-Xmn50M-XX:TargetSurvivorRatio=60-XX:+PrintTenuringDistribution-XX:+PrintGCDetails-XX:+PrintGCDateStamps-XX:+UseConcMarkSweepGC-XX:+UseParNewGC-XX:MaxTenuringThreshold=3 1234567891011121314151617181920212223public class Test04 &#123; public static void main(String[] args) &#123; int size = 1024 * 1024 ; byte[] alloc = new byte[512 * 1024]; byte[] alloc2 = new byte[512 * 1024]; gc(); System.out.println(&quot;1111&quot;); gc(); System.out.println(&quot;2222&quot;); gc(); System.out.println(&quot;3333&quot;); gc(); System.out.println(&quot;4444&quot;); gc(); System.out.println(&quot;55555&quot;); &#125; static void gc() &#123; for (int i = 0; i &lt; 30; i++) &#123; byte[] alloc = new byte[1024 * 1024]; &#125; &#125;&#125;","categories":[{"name":"Jvm","slug":"Jvm","permalink":"http://wanke.fun/categories/Jvm/"}],"tags":[],"author":"师学"},{"title":"jvm gc","slug":"jvm-gc","date":"2019-12-07T05:19:00.000Z","updated":"2024-03-12T01:06:15.826Z","comments":true,"path":"Jvm/jvm-gc/","link":"","permalink":"http://wanke.fun/Jvm/jvm-gc/","excerpt":"jvm gc","text":"jvm gc 一. 小例子说明 123void method() &#123; Object obj = new Object();&#125; 对于以上代码，会生成2部分内存区域： obj 这个引用变量，会放到jvm stack 里面。 真正的object的class实例对象，会放到 heap 里面 当方法执行结束以后，stack里面的变量会马上被回收，而heap上的class实例，则会等待下一次gc的时候被回收 。 二. 垃圾的判断 哪些对象是垃依据什么进行判断的 ？ 引用计数算法 给对象添加一个计数器 每一次引用 计数器加1，每一次引用失效，计数器减1 当计数器为0的时候，那么就可以被回收掉 一个很重要的缺陷就是 ，引用计数算法无法解决循环引用的问题 根搜索算法 使用根搜索算法判断对象是否存活，通过一系列被称为‘GC roots’ 的根为起点进行向下搜索，当一个对象到 gc roots 没有任何引用链相连，曾明此对象不可用。 gc roots 包括： vm栈中（帧的本地变量）的引用 。 方法区的静态引用 。 jvm不要求实现，商业垃圾jvm基本都会实现。回收无用类和废弃常量 。 类的回收需满足如下条件 ： 所有的实例都已经被回收 ，加载该类的classloader已经被回收 ， 加载该类的 java.lang.Class对象已经没有在任何对象 被引用，包括反射 jni本地方法引用 三. 常见 GC 算法 标记清除 分为【标记】和【清除】 2个阶段，先标记可以被回收的对象，然后再去逐一清除。 缺点： 效率低下 2. 会产生不连续的的内存碎片 ， 可能会导致后续操作无法找到足够的内存空间而触发二次的gc 。 3. 扫描所有对象，堆越大，时间越长。 gc次数越多，碎片化越严重。 标记整理 标记过程和之前是一样的，而后续步骤不是直接进行清理，而是将所以有存活对象一端移动，然后清理掉这这端边界以外的内存。 相比标记清除，不会产生碎片，但是所需时间更长。 复制搜集算法 将可用的内存划分为两块，每次只是用其中的一块，当半区内存用完了，仅仅将存活的对象赋值到另一块上面，然后将原来的空间一次性清除掉 优点： 实现简单，高效 不会产生碎片。 缺点： 将原来的内存空间缩小为原来的一半，带价也是挺高昂的。在对象存活高的时候，效率下降 在现代商业vm中常用来回收新生代 。 新生代中划分为 Eden 和 2块较小的survivor ，每次使用 Eden和其中的一块survivor ，当回收时，将Eden和survivor中的存活对象，赋值到另一块啊 survivor中，然后清理 Eden和使用过的survivor。 hotspot中 eden和survivor 默认比例为 8 : 1 分代算法 当前商业虚拟机都是采用分代算法来实现，根据对象不同一般划分为如下区域: java堆分为新生代和老年代，根据各个年代的特点采用不同的收集算法 。 譬如新生带每次gc都只有少量存活，那么选用复制算法 。 老年代采用 标记清除或者标记整理算法 新生成的对象被存放在年轻代 ， 年轻代采用复制算法 算法（理论上年轻代的对象生命周期都非常短，适合复制算法） 年轻代分为三个区域 Eden 和 两个 survivor 区 。对象在Eden生成，当Eden区满了时候，此区域的存活对象会被复制到其中的一个 survivor区域，，当这个survivor区域也满了的时候，会存活的对象复制到另外一个survivor区域，。当第二个survivor也满了的时候，从第一个survivor复制过来的还存活的对象会被放到老年代 。 老年代存放经过一次或者多次gc还存活的对象，采用 标记清除或者标记整理算法进行gc 永久代，在jdk 8 中已经被取消。 它并不属于堆，gc也会涉及到这个区域 。它存放了每个class的结构信息，包括常量池，字段描述，方法描述 。 内存分配： 堆上分配： 大多数情况下，会在Eden生进行分配，偶尔会分配到old上 栈上分配： 原子类型的局部变量 内存回收：在 full gc 的时候会对reference类型的引用进行特殊处理 soft： 内存不够时一定会被gc ，长期不用也会被gc weak： 一定会被gc，当被mark为dead，会在referencequeue中通知 phantom： 本来就没引用，当jvm heap释放 会通知 垃圾收集算法： young generation： serial， parnewe ，parallel scavenge old generation： cms ， serial old ， parallel old minor gc： 时间短，频繁，复制算法执行效率高，当 Eden满了会触发 full gc：对整个jvm进行整理。触发的实际： old满了，perm满了，system.gc。 他的效率很低，应当尽量避免 垃圾回收器的并行和并发： 并行： 多个收集器同事同做，但用户线程处于等待状态 并发： 在收集器工作的时候，用户线程也可以工作。但是在关键的步骤还是要暂停，比如标记阶段。 在清理阶段用户线程和gc线程可以同时工作 。 serial收集器：会暂停用户线程 ， 默认的新生代收集器， 单线程实现。 在新生代采用 复制算法，老年代采用标记算法 。 parNew收集器： serial的多线程版本，使用多线程。其余的行为（对象份额 ，回收策略等）和serial一样 parallel scavenge 收集器： 多线程， 复制算法，吞吐量最大化 允许较长时间的stop the world。 parallel old ： jvm 1.6 ， 多线程，标记整理算法，注重吞吐量，gc停顿不太理想。","categories":[{"name":"Jvm","slug":"Jvm","permalink":"http://wanke.fun/categories/Jvm/"}],"tags":[],"author":"师学"},{"title":"jvm 内存区域学习","slug":"jvm-内存区域学习","date":"2019-12-03T09:04:00.000Z","updated":"2024-03-12T01:06:15.826Z","comments":true,"path":"Jvm/jvm-内存区域学习/","link":"","permalink":"http://wanke.fun/Jvm/jvm-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%AD%A6%E4%B9%A0/","excerpt":"classLoader 字节码 内存区域划分 垃圾回收","text":"classLoader 字节码 内存区域划分 垃圾回收 一. jvm 内存划分为以下几个区域 虚拟机栈 ： stack frame 栈帧 程序计数器 ： program counter 本地方法栈 ： c ++ 等实现 堆 ： 最大的一块共享内存区域 , new object 的实例 。通过引用(在栈上) 指向实例。 与堆密切相关的是垃圾收集器， 几乎所有的现在垃圾回收器都采用了分代算法， 堆空间也针对此进行了划分 。 新生代和老年代 Eden， from survivor ，to survivor （默认按照80 ， 10 ，10 的比例进行划分） 方法区 ： 主要存储一些元信息，其中包括 class信息 等 ，有称为永久代 （jdk1.8 开始废弃，进而被元空间取代 ），很少会被垃圾回收 直接内存： 堆外内存，不是jvm直接管理 ，操作系统管理 . nio直接相关，DirectByteBuffer 是堆外内存 虚拟机栈，程序计数器 和 本地方法栈 都是内存私有的 。 堆是虚拟机中最大的一块内存区域，我们通过new关键字创建的对象，绝大多数都会在堆上面分配内存 ，然后会在栈上通过引用去指向它。堆上的对象由 数据区和元数据（比如class对象唯一）2 部分组成 ， 并且在不同的虚拟机上面会有不同的实现 如图所示： 堆上实例指向数据空间和元数据 堆上的实指向元数据并包括数据空间 二. new关键字创建对象的流程 在堆内存创建对象实例 为对象实例成员变量赋初值 返回对象引用 对象在内存中的布局： 对象头 实例数据 对齐填充（可选） 引用对象的方式 使用句柄 使用直接指针 通过实例模拟一个outofmemory configuration : vmoptions : -Xms5m -Xmx5m -XX:+HeapDumpOnOutOfMemoryError 12345678910 public class Test01 &#123; public static void main(String[] args) &#123; List&lt;Test01&gt; list = new ArrayList&lt;&gt;(); for (;;) &#123; list.add(new Test01()); &#125; &#125;&#125; java.lang.OutOfMemoryError: GC overhead limit exceeded Dumping heap to java_pid19782.hprof ... Heap dump file created [8972643 bytes in 0.075 secs] Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded at com.java.memory.Test01.main(Test01.java:25) 一些重要工具的使用： jvisualvm 进行实例分析 jconsole 进行实例分析 jmap命令行工具的使用，可以查看当前运行的java进程的 classloader ，heap信息 等 jstat 命令行工具 可以 查看gc等。 mc（current metaspace capcity） ，mu（metaspace used 已经使用的）信息 jcmd 命令 jcmd pid VM.flags jvm信息 jcmd pid help 列而可以对当前pid进行的操作 jps 列出所有java进程的信息 jstack 查看，导出堆栈信息 jmc java misson control jhat 查看hprof 文件信息","categories":[{"name":"Jvm","slug":"Jvm","permalink":"http://wanke.fun/categories/Jvm/"}],"tags":[],"author":"师学"},{"title":"音视频开发2","slug":"音视频开发2","date":"2019-11-21T08:26:00.000Z","updated":"2024-03-12T01:06:15.829Z","comments":true,"path":"FFmpeg/音视频开发2/","link":"","permalink":"http://wanke.fun/FFmpeg/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%912/","excerpt":"作者：灰色飘零 链接： https://www.cnblogs.com/renhui/p/7452572.html","text":"作者：灰色飘零 链接： https://www.cnblogs.com/renhui/p/7452572.html 一直欠大家一篇音视频入门之路的文章，这篇文章是我见过写的最详细的一篇了，今天算还了哈。作者从入门、进阶、探究分别编写了一系列文章。 Android 音视频开发这块目前的确没有比较系统的教程或者书籍，网上的博客文章也都是比较零散的。只能通过一点点的学习和积累把这块的知识串联积累起来。 1 初级入门篇 Android 音视频开发(一) : 通过三种方式绘制图片 http://www.cnblogs.com/renhui/p/7456956.html Android 音视频开发(二)：使用 AudioRecord 采集音频PCM并保存到文件 http://www.cnblogs.com/renhui/p/7457321.html Android 音视频开发(三)：使用 AudioTrack 播放PCM音频 http://www.cnblogs.com/renhui/p/7463287.html Android 音视频开发(四)：使用 Camera API 采集视频数据 http://www.cnblogs.com/renhui/p/7472778.html Android 音视频开发(五)：使用 MediaExtractor 和 MediaMuxer API 解析和封装 mp4 文件 http://www.cnblogs.com/renhui/p/7474096.html Android 音视频开发(六)： MediaCodec API 详解 http://www.cnblogs.com/renhui/p/7478527.html Android 音视频开发(七)： 音视频录制流程总结 http://www.cnblogs.com/renhui/p/7520690.html 初级入门篇主要是接触Android多媒体展示相关的API，通过单独的列举和使用这些API，对Android音视频处理有一个基本的轮廓，虽然知识点相对来说是比较散的，但是点成线,线称面，基本的基础掌握了，通过学习Android音视频核心的API将音视频的流程串联起来，这样对于音视频的了解和控制就不仅仅局限于最外层的API了，而是能够通过相对底层的方式来加深对Android 音视频开发的认知。 2 中级进阶篇 OpenGL ES 学习记录 学习 Android 平台 OpenGL ES API，了解 OpenGL 开发的基本流程，使用 OpenGL 绘制基本图形，并了解相关的API的简单使用 Android OpenGL ES 开发（一）: OpenGL ES 介绍 http://www.cnblogs.com/renhui/p/7994261.html Android OpenGL ES 开发（二）: OpenGL ES 环境搭建 http://www.cnblogs.com/renhui/p/7997557.html Android OpenGL ES 开发（三）: OpenGL ES 定义形状 http://www.cnblogs.com/renhui/p/8000345.html Android OpenGL ES 开发（四）: OpenGL ES 绘制形状 http://www.cnblogs.com/renhui/p/8004987.html Android OpenGL ES 开发（五）: OpenGL ES 使用投影和相机视图 http://www.cnblogs.com/renhui/p/8005512.html Android OpenGL ES 开发（六）: OpenGL ES 添加运动效果 http://www.cnblogs.com/renhui/p/8005518.html Android OpenGL ES 开发（七）: OpenGL ES 响应触摸事件 http://www.cnblogs.com/renhui/p/8005528.html Android OpenGL ES 开发（八）: OpenGL ES 着色器语言GLSL http://www.cnblogs.com/renhui/p/8126121.html Android OpenGL ES 开发（九）: OpenGL ES 纹理贴图 http://www.cnblogs.com/renhui/p/8145734.html Android OpenGL ES 开发（十）: 通过GLES20与着色器交互 http://www.cnblogs.com/renhui/p/8302434.html 动手实践，积累实战经验： 使用 OpenGL 显示一张图片 GLSurfaceviw 绘制 Camera 预览画面及实现拍照https://github.com/renhui/OpenGLES20Study 使用OpenGL ES 完成视频的录制，并实现视频水印效果https://github.com/renhui/OpenGLVideoRecord/tree/master 个人学习成果展示： 音视频录制流程总结： https://github.com/renhui/AndroidRecorder OpenGL ES 学习笔记： https://github.com/renhui/OpenGLES20Study OpenGL音视频录制项目： https://github.com/renhui/OpenGLVideoRecord OpenSL ES 学习记录 学习 Android 平台 OpenSL ES API，了解 OpenSL 开发的基本流程，使用OpenSL播放PCM数据，并了解相关API的简单使用。 Android OpenSL ES 开发：Android OpenSL 介绍和开发流程说明 https://www.cnblogs.com/renhui/p/9567332.html Android OpenSL ES 开发：使用 OpenSL 播放 PCM 数据 https://www.cnblogs.com/renhui/p/9565464.html Android OpenSL ES 开发：Android OpenSL 录制 PCM 音频数据 https://www.cnblogs.com/renhui/p/9604550.html Android OpenSL ES 开发：OpenSL ES利用SoundTouch实现PCM音频的变速和变调 https://www.cnblogs.com/renhui/p/9620400.html 3 高级探究篇 深入研究音视频相关的网络协议，如 rtmp，hls，以及封包格式，如：flv，mp4 深入学习一些音视频领域的开源项目，如 webrtc，ffmpeg，ijkplayer，librtmp 等等 将 ffmpeg 库移植到 Android 平台，结合上面积累的经验，编写一款简易的音视频播放器 将 x264 库移植到 Android 平台，结合上面积累的经验，完成视频数据 H264 软编功能 将 librtmp 库移植到 Android 平台，结合上面积累的经验，完成 Android RTMP 推流功能 FFmpeg 学习记录 FFmpeg命令行工具学习(一)：查看媒体文件头信息工具ffprobe http://www.cnblogs.com/renhui/p/9209664.html FFmpeg命令行工具学习(二)：播放媒体文件的工具ffplay http://www.cnblogs.com/renhui/p/8458802.html FFmpeg命令行工具学习(三)：媒体文件转换工具ffmpeg http://www.cnblogs.com/renhui/p/9223969.html FFmpeg 学习(一)：FFmpeg 简介 http://www.cnblogs.com/renhui/p/6922971.html FFmpeg 学习(二)：Mac下安装FFmpeg http://www.cnblogs.com/renhui/p/8458150.html FFmpeg 学习(三)：将 FFmpeg 移植到 Android平台 http://www.cnblogs.com/renhui/p/6934397.html FFmpeg 学习(四)：FFmpeg API 介绍与通用 API 分析 http://www.cnblogs.com/renhui/p/9293057.html FFmpeg 学习(五)：FFmpeg 编解码 API 分析 http://www.cnblogs.com/renhui/p/9328893.html FFmpeg 学习(六)：FFmpeg 核心模块 libavformat 与 libavcodec 分析 http://www.cnblogs.com/renhui/p/9343098.html FFmpeg 结构体学习 FFmpeg 结构体学习(一)： AVFormatContext 分析 https://www.cnblogs.com/renhui/p/9361276.html FFmpeg 结构体学习(二)： AVStream 分析 https://www.cnblogs.com/renhui/p/9469856.html FFmpeg 结构体学习(三)： AVPacket 分析 https://www.cnblogs.com/renhui/p/9488751.html FFmpeg 结构体学习(四)： AVFrame 分析 https://www.cnblogs.com/renhui/p/9493393.html FFmpeg 结构体学习(五)： AVCodec 分析 https://www.cnblogs.com/renhui/p/9493690.html FFmpeg 结构体学习(六)： AVCodecContext 分析 https://www.cnblogs.com/renhui/p/9494286.html FFmpeg 结构体学习(七)： AVIOContext 分析 https://www.cnblogs.com/renhui/p/9494887.html FFmpeg 结构体学习(八)：FFMPEG中重要结构体之间的关系 https://www.cnblogs.com/renhui/p/9494890.html 4 高级探究篇 GPUImage https://github.com/CyberAgent/android-gpuimage IjkPlayer https://github.com/Bilibili/ijkplayer librestreaming https://github.com/lakeinchina/librestreaming RTMPDump http://rtmpdump.mplayerhq.hu/ SoundTouch http://www.surina.net/soundtouch/sourcecode.html 5 学习展望 完成上面的学习后，可以尝试做一款音视频相关的APP，这个APP尽可能多的用上你学习的知识，看看能做到什么程度。如果你能很好的做出来，并认真的把上面列举的所有的点都完成和整理了，相信你在Android音视频领域会越走越好。 推荐的学习资料： 《雷霄骅的专栏》： http://blog.csdn.net/leixiaohua1020 《Android音频开发》： http://ticktick.blog.51cto.com/823160/d-15 《FFMPEG Tips》 http://ticktick.blog.51cto.com/823160/d-17 《Learn OpenGL 中文》 https://learnopengl-cn.github.io/ 《Android Graphic 架构》 https://source.android.com/devices/graphics/ 《Jhuster的专栏》： http://blog.51cto.com/ticktick 《ywl5320的专栏》： https://blog.csdn.net/ywl5320 有句古话，师傅领进门，修行靠个人。 音视频有着一定的门槛，一个看似简单的例子实现起来可能因为一两个参数的问题都会浪费非常久的时间，不过这些经历都是比较宝贵的，可以让你更好的去理解各个 API。 光靠看绝对是不可能精通音视频的，技术都是一步步积累的，有个正确的方向，坚持去做才可能做好。","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://wanke.fun/categories/FFmpeg/"}],"tags":[],"author":"师学"},{"title":"FFmpeg 相关博客","slug":"FFmpeg-相关博客","date":"2019-11-21T08:20:00.000Z","updated":"2024-03-12T01:06:15.824Z","comments":true,"path":"FFmpeg/FFmpeg-相关博客/","link":"","permalink":"http://wanke.fun/FFmpeg/FFmpeg-%E7%9B%B8%E5%85%B3%E5%8D%9A%E5%AE%A2/","excerpt":"blog：清华大学计算机系毕业，专注于流媒体技术https://blog.piasy.com/","text":"blog：清华大学计算机系毕业，专注于流媒体技术https://blog.piasy.com/ 华科，七牛直播sdkAndroid开发组长，专注于流媒体技术http://blog.51cto.com/ticktick 剑西http://blog.csdn.net/mabeijianxi/article/category/6833978 https://www.jianshu.com/u/1502591a1753 雷霄骅(leixiaohua1020)的专栏http://blog.csdn.net/leixiaohua1020 博主的流媒体系列http://www.cnblogs.com/my_life/category/282307.html 金山视频云https://www.jianshu.com/u/b2227c3472fd ijk相关https://yhaolpz.github.io/ijkplayer-学习笔记/ 微信公众号逆流的鱼yuiop 何俊林 书籍资料音视频开发进阶指南：基于 Android 与 iOS 平台的实践 （知乎书店有）https://www.zhihu.com/pub/reader/119560110/chapter/944985777545916416FFmpeg从入门到精通（纸质）Android音视频开发 何俊林（纸质已买） 学习路线Android 音视频开发入门指南http://blog.51cto.com/ticktick/1956269 先学习基础播放器，再看解析 深入理解Android音频框架AudioTrack到AudioFlinger及Mix过程https://mp.weixin.qq.com/s/GB77ZyPXmL4Q8PAXunAwvg 开源项目EXOplayer肯定优先看源码https://github.com/yangchaojiang/yjPlay blog✔️公众号✔️简书✔️开源项目视频见腾讯云课堂慕课网✔️http://www.imooc.com/article/19700http://www.imooc.com/t/2327155 https://coding.imooc.com/class/84.html 网易云课堂✔️http://study.163.com/course/introduction.htm?courseId=1003413003#/courseDetail?tab=1 http://study.163.com/course/introduction/1004203018.htm这个人专门讲解音视频 同事zhugejiao、huangbin优质的路线和你的资源可以提升你的速度的 https://blog.csdn.net/zuo_er_lyf/article/details/82629847 https://github.com/google/grafika————————————————版权声明：本文为CSDN博主「红涛在反思」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/a910626/article/details/79443975","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://wanke.fun/categories/FFmpeg/"}],"tags":[],"author":"师学"},{"title":"Kotlin 知识简要","slug":"Kotlin-知识简要","date":"2019-11-21T05:57:00.000Z","updated":"2024-03-12T01:06:15.825Z","comments":true,"path":"Kotlin/Kotlin-知识简要/","link":"","permalink":"http://wanke.fun/Kotlin/Kotlin-%E7%9F%A5%E8%AF%86%E7%AE%80%E8%A6%81/","excerpt":"增强for循环","text":"增强for循环 for(it in list ) println(it) 2. 数据类 data class Stu(var name : String) 数据类可以只有属性，在字节码底层会生成get 和set 方法 3. 可空属性 对于kotlin 类中的属性是强初始化的，否则可以用可空属性标识 eg: var address : String? = null 4. 集合遍历 for (i in array.indices) &#123;&#125; for ((index ,value ) in array.withIndex()) &#123;&#125; for (i in maps.keys) &#123;&#125; for (i in maps.values) &#123;&#125; for ((key ,value) in maps) &#123;&#125; 5. when 关键字 var result = when(a) &#123; 1 -&gt; &#123; 10 &#125; 3, 4 ,5 -&gt; &#123; 45 &#125; in 6..10 -&gt; &#123; 345 &#125; else -&gt; 10 &#125; 6. Range 区间 var a : Int = 10; if (a in 2 ..49) &#123;&#125; for (i in 2.rangeTo(10)) &#123; println(&quot;range to 10&quot;) &#125; for (i in 2 .. 20 step 3 ) &#123;&#125; for (i in 20 downTo 2 step 10) &#123;&#125; 7. 面向对象 1. class 默认是final的，父类用open修饰，标识可继承 2. 方法和属性扩展 class Person fun Person.value():String &#123; return &quot;hello word&quot; &#125; var Person.fullName : String set(value) &#123; fullName = value&#125; get() &#123;return fullName &#125; 8. 对象表达式 可以替代大量的匿名实现类 var obj = object : interface1, interface2 &#123;&#125; 对象表达式可以添加方法和属性 9. kotlin 中的枚举 enum class Color constructor(var va : String) &#123; READ(&quot;red&quot;), BLUE(&quot;blue&quot;) ; &#125; enum class Demo11 &#123; session1 &#123; override fun get(): String &#123; return &quot;hello &quot; &#125; &#125;; abstract fun get() : String &#125;","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://wanke.fun/categories/Kotlin/"}],"tags":[],"author":"师学"},{"title":"Kotlin 中的协变和逆变","slug":"Kotlin-中的协变和逆变","date":"2019-11-18T12:44:00.000Z","updated":"2024-03-12T01:06:15.825Z","comments":true,"path":"Kotlin/Kotlin-中的协变和逆变/","link":"","permalink":"http://wanke.fun/Kotlin/Kotlin-%E4%B8%AD%E7%9A%84%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/","excerpt":"泛型的概念对于java 并不陌生 。 所谓的协变和逆变其实有点类似于类型转换的 ， 虽然不准确，姑且这么理解，毕竟是概念上的东西。","text":"泛型的概念对于java 并不陌生 。 所谓的协变和逆变其实有点类似于类型转换的 ， 虽然不准确，姑且这么理解，毕竟是概念上的东西。 我们知道java中的root class 为 java.lang.object， 所有的java类默认的父类 实现。 在java的泛型中，比如 List《object》 , List《string》 虽然 string 是 object的子类，但是 list《object》 却并不是 list《string》 的子类在java中我们可以使用 通配符类做类型转换 ? 和 super 例如 123456789101112list&lt;object&gt; objs; list&lt;string&gt; strs ; objs = strs ;是错误的 修改为 list&lt; ？ extends object&gt; objs; // 重点是 ？ 通配符 list&lt;string&gt; strs ; objs = strs ;正确做法 在kotlin ，没有提供通配符的概念，但是给我们提供了两个 关键字 out 和 in 作为协变和逆变的处理其中out 可读 只能用于返回值输出 in 可写 只能用于入参输入 1234567891011121314151617181920 class MyClass&lt;out T ,in E&gt;(t : T , e: E) &#123; fun get(): T? &#123; return variable &#125; fun setVal(e: E) &#123; this.var2 = e &#125; private var variable : T private var var2 : E; init &#123; this.variable = t this.var2 = e; &#125;&#125; java 和 kotlin 中的区别 ： java 在使用时协变， kotlin在类声明时候协变java使用 ？通配符， kotlin 使用out，在类声明时候作为修饰符","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://wanke.fun/categories/Kotlin/"}],"tags":[],"author":"师学"},{"title":"FFmpeg 编译 for Android 2","slug":"FFmpeg-编译-for-Android-2","date":"2019-11-18T02:16:00.000Z","updated":"2024-03-12T01:06:15.824Z","comments":true,"path":"FFmpeg/FFmpeg-编译-for-Android-2/","link":"","permalink":"http://wanke.fun/FFmpeg/FFmpeg-%E7%BC%96%E8%AF%91-for-Android-2/","excerpt":"在前面 FFmpeg编译for Android 这篇文章中，我们介绍了 基于 ndk-r14 和 ffmpeg 3.3.9 版本的编译工作。 并且生成了 8个 so文件 。在使用过程中由于so文件太多，引入繁琐，这里特记录 如何将8个so打包编译成一个so库的问题 。","text":"在前面 FFmpeg编译for Android 这篇文章中，我们介绍了 基于 ndk-r14 和 ffmpeg 3.3.9 版本的编译工作。 并且生成了 8个 so文件 。在使用过程中由于so文件太多，引入繁琐，这里特记录 如何将8个so打包编译成一个so库的问题 。 其他步骤，参考上篇文章 。脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 #!/bin/bashexport TMPDIR=/Users/kongxiangshu/Desktop/ffmpeg-4.0.4/outputs# NDK的路径，根据自己的安装位置进行设置NDK=/Users/kongxiangshu/Desktop/android-ndk-r14b# 编译针对的平台，可以根据自己的需求进行设置# 这里选择最低支持android-14, arm架构，生成的so库是放在# libs/armeabi文件夹下的，若针对x86架构，要选择arch-x86PLATFORM=$NDK/platforms/android-14/arch-arm# 工具链的路径，根据编译的平台不同而不同# arm-linux-androideabi-4.9与上面设置的PLATFORM对应，4.9为工具的版本号，# 根据自己安装的NDK版本来确定，一般使用最新的版本TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64function build_one&#123;./configure \\ --prefix=$PREFIX \\ --target-os=linux \\ --cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \\ --arch=arm \\ --sysroot=$PLATFORM \\ --extra-cflags=&quot;-I$PLATFORM/usr/include&quot; \\ --cc=$TOOLCHAIN/bin/arm-linux-androideabi-gcc \\ --nm=$TOOLCHAIN/bin/arm-linux-androideabi-nm \\ --disable-shared \\ --enable-runtime-cpudetect \\ --enable-gpl \\ --enable-small \\ --enable-cross-compile \\ --disable-debug \\ --enable-static \\ --disable-doc \\ --disable-asm \\ --disable-ffmpeg \\ --disable-ffplay \\ --disable-ffprobe \\ --disable-ffserver \\ --disable-postproc \\ --disable-avdevice \\ --disable-symver \\ --disable-stripping \\$ADDITIONAL_CONFIGURE_FLAGsed -i &#x27;&#x27; &#x27;s/HAVE_LRINT 0/HAVE_LRINT 1/g&#x27; config.hsed -i &#x27;&#x27; &#x27;s/HAVE_LRINTF 0/HAVE_LRINTF 1/g&#x27; config.hsed -i &#x27;&#x27; &#x27;s/HAVE_ROUND 0/HAVE_ROUND 1/g&#x27; config.hsed -i &#x27;&#x27; &#x27;s/HAVE_ROUNDF 0/HAVE_ROUNDF 1/g&#x27; config.hsed -i &#x27;&#x27; &#x27;s/HAVE_TRUNC 0/HAVE_TRUNC 1/g&#x27; config.hsed -i &#x27;&#x27; &#x27;s/HAVE_TRUNCF 0/HAVE_TRUNCF 1/g&#x27; config.hsed -i &#x27;&#x27; &#x27;s/HAVE_CBRT 0/HAVE_CBRT 1/g&#x27; config.hsed -i &#x27;&#x27; &#x27;s/HAVE_RINT 0/HAVE_RINT 1/g&#x27; config.hmake cleanmake -j4make install$TOOLCHAIN/bin/arm-linux-androideabi-ld \\-rpath-link=$PLATFORM/usr/lib \\-L$PLATFORM/usr/lib \\-L$PREFIX/lib \\-soname libffmpeg.so -shared -nostdlib -Bsymbolic --whole-archive --no-undefined -o \\$PREFIX/libffmpeg.so \\ libavcodec/libavcodec.a \\ libavfilter/libavfilter.a \\ libswresample/libswresample.a \\ libavformat/libavformat.a \\ libavutil/libavutil.a \\ libswscale/libswscale.a \\ -lc -lm -lz -ldl -llog --dynamic-linker=/system/bin/linker \\ $TOOLCHAIN/lib/gcc/arm-linux-androideabi/4.9.x/libgcc.a \\&#125;# arm v7vfpCPU=armv7-aOPTIMIZE_CFLAGS=&quot;-mfloat-abi=softfp -mfpu=vfp -marm -march=$CPU &quot;PREFIX=./android/$CPU-vfpADDITIONAL_CONFIGURE_FLAG=build_one 执行完毕会在 脚本当前目录 下 android&#x2F;armv7-a-vfp 下生成 libffmpeg.so 引入工程即可，替换以前的8个so 。","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://wanke.fun/categories/FFmpeg/"}],"tags":[],"author":"师学"},{"title":"FFmpeg 从视频中提取图片","slug":"FFmpeg-从视频中提取图片","date":"2019-11-09T01:59:00.000Z","updated":"2024-03-12T01:06:15.824Z","comments":true,"path":"FFmpeg/FFmpeg-从视频中提取图片/","link":"","permalink":"http://wanke.fun/FFmpeg/FFmpeg-%E4%BB%8E%E8%A7%86%E9%A2%91%E4%B8%AD%E6%8F%90%E5%8F%96%E5%9B%BE%E7%89%87/","excerpt":"从视频中提取图片，涉及到以下流程的处理 。","text":"从视频中提取图片，涉及到以下流程的处理 。 打开输出文件，解封装，找到视频流索引 通过视频context初始化decoder 对视频帧进行解码 初始化输出环境，新建输出流 获取图片编码器 对帧进行编码 并写到图片文件中 了解以上处理流程以后，对于代码的编写就会了然于胸。 https://github.com/kongxs/ffmpeg_demos/tree/master/toPics 1. 找到视频流 123456789101112131415161718192021222324252627282930313233343536373839 char *file = &quot;/Users/kongxiangshu/Desktop/1111.mp4&quot;; char *outDir = &quot;/Users/kongxiangshu/Desktop/pics&quot;; AVFormatContext *in_context ; in_context = avformat_alloc_context(); if (avformat_open_input(&amp;in_context, file, NULL, NULL) &lt; 0 ) &#123; LOGE(&quot;can not open file %s \\n&quot; , file); exit(1); &#125; if( avformat_find_stream_info(in_context, NULL) &lt; 0 ) &#123; LOGE(&quot;can not find media info \\n&quot;); exit(1); &#125; // av_dump_format(in_context, -1, file, 0); int best_stream_index = -1; if(best_stream_index = av_find_best_stream(in_context, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0) &lt; 0 )&#123; LOGE(&quot;can not find video stream \\n &quot;); exit(1); &#125; LOGE(&quot;best stream index : %d , \\n&quot; , best_stream_index); for(int i = 0; i&lt; in_context-&gt;nb_streams;i++) &#123; AVStream *stream = in_context-&gt;streams[i]; if (stream-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123; best_stream_index = i; &#125; &#125; 2. 通过视频流 获取并打开解码器 12345678910111213141516171819202122232425262728AVStream *beststream = in_context-&gt;streams[best_stream_index]; AVCodec *codec = avcodec_find_decoder(beststream-&gt;codecpar-&gt;codec_id); if( codec == NULL) &#123; LOGE(&quot;can not find codec \\n&quot;); exit(1); &#125; AVCodecContext *codec_context = avcodec_alloc_context3(codec); if (codec_context == NULL) &#123; LOGE(&quot;can not alloc codec context \\n &quot;); exit(1); &#125; // param if(avcodec_parameters_to_context(codec_context, beststream-&gt;codecpar) &lt; 0)&#123; LOGE(&quot;copy codec param error &quot;); exit(1); &#125; if ( avcodec_open2(codec_context, codec, NULL) &lt; 0 ) &#123; LOGE(&quot;can not open codec \\n&quot;); exit(1); &#125; 3. 解码frame 123456789101112131415161718192021222324252627282930313233 while (av_read_frame(in_context, &amp;pkt) &gt;= 0) &#123; if (pkt.stream_index == best_stream_index) &#123; AVStream *stream = in_context-&gt;streams[pkt.stream_index] ; if (stream == NULL) &#123; LOGE(&quot;error to get stream in read freme \\n &quot;); exit(1); &#125; // decode frame if (avcodec_send_packet(codec_context, &amp;pkt) &lt; 0) &#123; LOGE(&quot;packet decode failed \\n&quot;) ; exit(1); &#125; avcodec_receive_frame(codec_context, frame); // ready to save pics snprintf(buf, sizeof(buf), &quot;%s/Demo-%d.jpg&quot;, outDir, frame_count); // sprintf(name,&quot;asdffasd&quot;); if (frame_count % 25 == 0) &#123; savePics(frame,buf); &#125; frame_count ++ ; av_packet_unref(&amp;pkt); &#125; &#125; 4. 编码并输出图片文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 void savePics(AVFrame *frame, char *name) &#123; //对frame进行编码 ，并保存到文件中 printf(&quot;%s \\n&quot; , name); AVFormatContext *out_context ; out_context = avformat_alloc_context(); if ( avformat_alloc_output_context2(&amp;out_context, NULL, NULL, name)) &#123; LOGE(&quot;输出环境初始化失败 \\n &quot;); exit(1); &#125; AVStream *stream = avformat_new_stream(out_context, 0) ; if (stream == NULL) &#123; LOGE(&quot;scan not get new stream \\n&quot;); &#125; AVCodec *codec = avcodec_find_encoder(AV_CODEC_ID_MJPEG); if (codec == NULL) &#123; LOGE(&quot;can not find jpeg codec&quot;); exit(1); &#125; AVCodecContext *avcodec_context = avcodec_alloc_context3(codec); if (avcodec_context == NULL) &#123; LOGE(&quot;codec context failed &quot;); exit(1); &#125; avcodec_context-&gt;width = frame-&gt;width; avcodec_context-&gt;height = frame-&gt;height; avcodec_context-&gt;time_base.num = 100; avcodec_context-&gt;time_base.den = 1000; avcodec_context-&gt;pix_fmt = AV_PIX_FMT_YUVJ420P; avcodec_context-&gt;codec_id = codec-&gt;id; avcodec_context-&gt;codec_type = AVMEDIA_TYPE_VIDEO; avcodec_open2(avcodec_context, codec, NULL); //writer heaer avformat_write_header(out_context, NULL); //编码帧 int ret = avcodec_send_frame(avcodec_context, frame); if (ret &lt; 0) &#123; LOGE(&quot;encode error \\n&quot;); exit(1); &#125; int y_size = frame-&gt;width * frame-&gt;height; //Encode // 给AVPacket分配足够大的空间 AVPacket pkt; av_new_packet(&amp;pkt, y_size * 3); ret = avcodec_receive_packet(avcodec_context, &amp;pkt); if (ret &lt; 0) &#123; LOGE(&quot;receive frame error \\n &quot;); exit(1); &#125; av_write_frame(out_context, &amp;pkt); av_write_trailer(out_context); av_packet_unref(&amp;pkt); avformat_free_context(out_context); &#125;","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://wanke.fun/categories/FFmpeg/"}],"tags":[],"author":"师学"},{"title":"FFmpeg 抽取 音视频","slug":"FFmpeg-抽取-音视频","date":"2019-11-07T08:19:00.000Z","updated":"2024-03-12T01:06:15.824Z","comments":true,"path":"FFmpeg/FFmpeg-抽取-音视频/","link":"","permalink":"http://wanke.fun/FFmpeg/FFmpeg-%E6%8A%BD%E5%8F%96-%E9%9F%B3%E8%A7%86%E9%A2%91/","excerpt":"利用ffmpeg 分别抽取音频和视频 ， 两者 在处理流程和代码 基本大同小异 。","text":"利用ffmpeg 分别抽取音频和视频 ， 两者 在处理流程和代码 基本大同小异 。 流程如下： 1. 解封装 2. 初始化 输出环境 3. 获取输出流 3. 封装 此过程不涉及到解码操作 。 代码： https://github.com/kongxs/ffmpeg_demos/tree/master/ffmpeg 1. 解封装，并打印视频信息 1234567891011121314151617//定义 宏信息 #define LOGE(FORMAT,...) av_log(NULL, AV_LOG_ERROR, FORMAT, ##__VA_ARGS__);char *file = &quot;/Users/kongxiangshu/Desktop/1111.mp4&quot;; char *outfile = &quot;/Users/kongxiangshu/Desktop/1111_out.avi&quot;; AVFormatContext *inputContext; if (avformat_open_input(&amp;inputContext, file, NULL, NULL) &lt; 0) &#123; LOGE(&quot;scan not open file %s &quot;, file); &#125; //找到视频和音频流信息 if(avformat_find_stream_info(inputContext, NULL) &lt; 0) &#123; LOGE(&quot;没找到音视频信息&quot;); &#125; av_dump_format(inputContext, 0, file, 0); 2. 获取我们想要处理的音频/视频流 1234567//AVMEDIA_TYPE_VIDEO 是获取视频流类型 //如果想要获取音频流的话，只需要修改为 AVMEDIA_TYPE_AUDIOint best_video_stream_index = av_find_best_stream(inputContext,AVMEDIA_TYPE_VIDEO , -1, -1, NULL, 0); if (best_video_stream_index &gt;= 0) &#123; LOGE(&quot;find best stream index : %d \\n&quot; , best_video_stream_index); &#125; 3. 准备输出环境 1234567891011121314151617181920212223//输出的上下文 AVFormatContext *outContext = NULL; //初始化上下文，并guess输出格式 if( avformat_alloc_output_context2(&amp;outContext, NULL, NULL, outfile) &lt; 0) &#123; LOGE(&quot;输出文件上下文失败 &quot;) ; &#125; //新建输出流 AVStream *outStream = avformat_new_stream(outContext, NULL) ; if (!outStream) &#123; LOGE(&quot;can not create out stream &quot;) ; &#125; //输出流 编码信息 if(avcodec_parameters_copy(outStream-&gt;codecpar, inputContext-&gt;streams[best_video_stream_index]-&gt;codecpar) &lt; 0) &#123; LOGE(&quot;输出环境编码失败. .. &quot;) ; &#125; //打开输出流 if(avio_open(&amp;outContext-&gt;pb, outfile, AVIO_FLAG_WRITE) &lt; 0) &#123; LOGE(&quot;输出文件创建失败 .... &quot;); &#125; 4. 不断的从输入流总读取 frame 并写到输出文件中 *in_stream 12345678910111213141516171819202122232425//写入头部信息avformat_write_header(outContext, NULL);//读取未解码的framewhile (av_read_frame(inputContext,&amp;pkt) &gt;= 0) &#123; if (pkt.stream_index == best_video_stream_index) &#123; //时间基转换 pkt.pts = av_rescale_q_rnd(pkt.pts, in_stream-&gt;time_base, outStream-&gt;time_base, AV_ROUND_NEAR_INF); pkt.dts = av_rescale_q_rnd(pkt.dts, in_stream-&gt;time_base, outStream-&gt;time_base, AV_ROUND_NEAR_INF ); pkt.duration = av_rescale_q(pkt.duration, in_stream-&gt;time_base, outStream-&gt;time_base); pkt.pos = -1; pkt.stream_index = 0; //将包写到输出媒体文件 av_interleaved_write_frame(outContext, &amp;pkt); //减少引用计数，避免内存泄漏 av_packet_unref(&amp;pkt); &#125;&#125;av_write_trailer(outContext); 5. 至此，所有流程处理完毕，我们虽然涉及到不少的api，但总体还是有迹可循的 。 只要稍加练习，必能了然于胸","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://wanke.fun/categories/FFmpeg/"}],"tags":[],"author":"师学"},{"title":"FFmpeg 资料汇总","slug":"FFmpeg-资料汇总","date":"2019-11-07T02:56:00.000Z","updated":"2024-03-12T01:06:15.824Z","comments":true,"path":"FFmpeg/FFmpeg-资料汇总/","link":"","permalink":"http://wanke.fun/FFmpeg/FFmpeg-%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/","excerpt":"ffmpeg 是个牛x的库，只要是做音视频开发，基本上就绕不过它的。 对于没有接触过音视频开发的人来说，或许会觉得无从下手 ，更何况ffmpeg api还挺多 。 万变不离其宗，在看似纷杂无章的api中，我们可以根据 ffmpeg的api固定使用套路结合音视频处理的流程进行梳理 。","text":"ffmpeg 是个牛x的库，只要是做音视频开发，基本上就绕不过它的。 对于没有接触过音视频开发的人来说，或许会觉得无从下手 ，更何况ffmpeg api还挺多 。 万变不离其宗，在看似纷杂无章的api中，我们可以根据 ffmpeg的api固定使用套路结合音视频处理的流程进行梳理 。 1. ffmpeg 扫盲 从整体来说，音视频相关的操作有着固定的套路 ， 例如 解协议，解封装，解码，等流程 。 参考： 《FFmpeg 视频播放的原理》 2. 编译篇 《FFmpeg 编译 for Mac os》 《FFmpeg 编译 for Android》 3. ffmpeg api讲解 ffmpeg处理音视频相关的api，看似杂乱，实则遵循一定的道理 比如初始化，编解码 . 参考： 《FFmpeg api 讲解》 4. 以下为单个功能的具体实现： ffmpeg 4.2.1 ， macOS 代码库： https://github.com/kongxs/ffmpeg_demos 1. 抽取音视频 project： ffmpeg 《FFmpeg 抽取 音视频》 2. 转换视频格式， 支持mp4 转mov ， 转 flv project： transMedia 3. 从视频中抽取图片 project： toPics","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://wanke.fun/categories/FFmpeg/"}],"tags":[],"author":"师学"},{"title":"FFmpeg 视频播放的原理","slug":"FFmpeg-视频播放的原理","date":"2019-11-04T03:08:00.000Z","updated":"2024-03-12T01:06:15.824Z","comments":true,"path":"FFmpeg/FFmpeg-视频播放的原理/","link":"","permalink":"http://wanke.fun/FFmpeg/FFmpeg-%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E7%9A%84%E5%8E%9F%E7%90%86/","excerpt":"视音频技术主要包含以下几点：封装技术，视频压缩编码技术以及音频压缩编码技术。如果考虑到网络传输的话，还包括流媒体协议技术。","text":"视音频技术主要包含以下几点：封装技术，视频压缩编码技术以及音频压缩编码技术。如果考虑到网络传输的话，还包括流媒体协议技术。 如果要播放一个互联网上的视频文件，需要经过以下几个步骤： 解协议 - 解封装 - 解码视音频 - 视音频同步 如果播放本地文件则不需要解协议，为以下几个步骤： 解封装 - 解码视音频 - 视音频同步。 他们的过程如图所示。 解协议 就是将流媒体协议的数据，解析为标准的相应的封装格式数据。视音频在网络上传播的时候，常常采用各种流媒体协议，例如HTTP，RTMP，或是MMS等等。这些协议在传输视音频数据的同时，也会传输一些信令数据。这些信令数据包括对播放的控制（播放，暂停，停止），或者对网络状态的描述等。解协议的过程中会去除掉信令数据而只保留视音频数据。例如，采用RTMP协议传输的数据，经过解协议操作后，输出FLV格式的数据。 解封装 将输入的封装格式的数据，分离成为音频流压缩编码数据和视频流压缩编码数据。封装格式种类很多，例如MP4，MKV，RMVB，TS，FLV，AVI等等，它的作用就是将已经压缩编码的视频数据和音频数据按照一定的格式放到一起。例如，FLV格式的数据，经过解封装操作后，输出H.264编码的视频码流和AAC编码的音频码流。 解码 就是将视频&#x2F;音频压缩编码数据，解码成为非压缩的视频&#x2F;音频原始数据。音频的压缩编码标准包含AAC，MP3，AC-3等等，视频的压缩编码标准则包含H.264，MPEG2，VC-1等等。解码是整个系统中最重要也是最复杂的一个环节。通过解码，压缩编码的视频数据输出成为非压缩的颜色数据，例如YUV420P，RGB等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据。 视音频同步根据解封装模块处理过程中获取到的参数信息，同步解码出来的视频和音频数据，并将视频音频数据送至系统的显卡和声卡播放出来。 基本概念扫盲 ： 1. 视频播放原理 2. 流媒体协议 3. 视频封装 &amp; 解封装 4. 音视频编解码 参考文章 雷神 ： https://blog.csdn.net/leixiaohua1020/article/details/18893769 文章来源以及参考: 雷霄骅 - 视频播放器原理","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://wanke.fun/categories/FFmpeg/"}],"tags":[],"author":"师学"},{"title":"FFmpeg api 讲解","slug":"FFmpeg-api讲解","date":"2019-10-31T02:23:00.000Z","updated":"2024-03-12T01:06:15.824Z","comments":true,"path":"FFmpeg/FFmpeg-api讲解/","link":"","permalink":"http://wanke.fun/FFmpeg/FFmpeg-api%E8%AE%B2%E8%A7%A3/","excerpt":"1. 相关 api","text":"1. 相关 api 1. void av_register_all(void); 注册所有的muxers ， demuxers 和 protocoal ，也可以选择具体的某一个来单独注册 。 固定写法 2. void avcodec_register_all(void); 注册所有的编解码器，固定写法即可。 3. AVFormatContext *avformat_alloc_context(void); 初始化一个 AVFormatContext 分配内存存并初始化默认值。 AVFormatContext 结构体封装了av的一些基本信息，不可以外部初始化 4. int avformat_open_input(AVFormatContext **ps, const char *url, AVInputFormat *fmt, AVDictionary **options); 打开一个流并读取它的头信息 ， 这时候并没有打开 codecs 。 url： 硬盘文件或者网络路径 fmt： NULL options ： NULL 5. int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options); 6. int av_find_best_stream(AVFormatContext *ic, enum AVMediaType type, int wanted_stream_nb, int related_stream, AVCodec **decoder_ret, int flags); 在文件中找到最好的那路 音频或者视频 流 type ： 枚举类型，常用的有 音频 ， 视频 wanted_stream_nb ： -1 related_stream： -1 decoder_ret ： 不知道可以写 NULL flags ： 0 7. AVOutputFormat *av_guess_format(const char *short_name, const char *filename, const char *mime_type); 从已经注册过的格式里面选择一个最匹配的 short_name : NULL filename : 输出文件的全路径 mime_type ：NULL 8. AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c); 添加一个新的流到媒体文件中， 9. int avcodec_parameters_copy(AVCodecParameters *dst, const AVCodecParameters *src); 从原始的media里面拷贝codec到目标文件里 10. int avformat_write_header(AVFormatContext *s, AVDictionary **options); 创建一个新的流，并且将header信息说不出到给定的文件 11. void av_init_packet(AVPacket *pkt); 初始化一个 给定的packet ,为可选的参数赋默认值。 ，这里并不涉及到数据大小内存变化。 12. int avio_open(AVIOContext **s, const char *url, int flags); 使用给定的 url 和 flag 打开一个输出环境 。 flags： AVIO_FLAG_WRITE ， AVIO_FLAG_READ 13. int av_read_frame(AVFormatContext *s, AVPacket *pkt); 给流中不断的获取frame ， note： 此 frame是未解码的原始数据 14. int64_t av_rescale_q_rnd(int64_t a, AVRational b, AVRational cq, enum AVRounding c) av_const; 时间刻度转换 。 将以 &quot;时钟基c&quot; 表示的 数值a 转换成以 &quot;时钟基b&quot; 来表示。 15. int64_t av_rescale_q(int64_t a, AVRational b, AVRational c) av_const; 具体来说是将以 &quot;时钟基c&quot; 表示的 数值a 转换成以 &quot;时钟基b&quot; 来表示。 16. int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt); （Write a packet to an output media file ensuring correct interleaving.） 17. int av_write_trailer(AVFormatContext *s); 18. int avcodec_send_packet(AVCodecContext *avctx, const AVPacket *avpkt); 解码 并将解码后的数据放到 avpkt 中。 19. int avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame); 从decoder中获取已经解码后的数据帧 20. int avformat_alloc_output_context2(AVFormatContext **ctx, AVOutputFormat *oformat, const char *format_name, const char *filename); 给 输出 文件初始化 ， 创建上下文并且根据输出文件格式生成容器 本质上调用了avformat_alloc_context、av_guess_format 这两个函数 21. AVCodec *avcodec_find_encoder(enum AVCodecID id); 获取一个已经注册过的encoder ， ig： AVCodec *codec = avcodec_find_encoder(AV_CODEC_ID_MJPEG); 22. int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options); 使用给定的codec 来初始化一个 avctx ，以便于后续使用 23. int avcodec_send_frame(AVCodecContext *avctx, const AVFrame *frame); 将 frame 使用给定的 encoder 进行编码 24. int avcodec_receive_packet(AVCodecContext *avctx, AVPacket *avpkt); 从encoder中读取已经编码后的数据包，放到avpkt中。 25. int av_image_alloc(uint8_t *pointers[4], int linesizes[4], int w, int h, enum AVPixelFormat pix_fmt, int align); 参数说明： pointers[4]：保存图像通道的地址。如果是RGB，则前三个指针分别指向R,G,B的内存地址。第四个指针保留不用 linesizes[4]：保存图像每个通道的内存对齐的步长，即一行的对齐内存的宽度，此值大小等于图像宽度。 w: 要申请内存的图像宽度。 h: 要申请内存的图像高度。 pix_fmt: 要申请内存的图像的像素格式。 align: 用于内存对齐的值。 返回值：所申请的内存空间的总大小。如果是负值，表示申请失败。 26. int av_image_get_buffer_size(enum AVPixelFormat pix_fmt, int width, int height, int align) 通过指定像素格式、图像宽、图像高来计算所需的内存大小 重点说明一个参数align:此参数是设定内存对齐的对齐数，也就是按多大的字节进行内存对齐。比如设置为1，表示按1字节对齐，那么得到的结果就是与实际的内存大小一样。再比如设置为4，表示按4字节对齐。也就是内存的起始地址必须是4的整倍数。 27. int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4], const uint8_t *src, enum AVPixelFormat pix_fmt, int width, int height, int align); av_image_fill_arrays()函数自身不具备内存申请的功能，此函数类似于格式化已经申请的内存，即通过av_malloc()函数申请的内存空间。 参数具体说明： dst_data[4]： 对申请的内存格式化为三个通道后，分别保存其地址 dst_linesize[4]: 格式化的内存的步长（即内存对齐后的宽度) *src: av_alloc()函数申请的内存地址。 pix_fmt: 申请 src内存时的像素格式 width: 申请src内存时指定的宽度 height: 申请scr内存时指定的高度 align: 申请src内存时指定的对齐字节数。 通过以上实例可以看到， （a)计算所需内存大小av_image_get_bufferz_size() --&gt; (b) 按计算的内存大小申请所需内存 av_malloc() --&gt; (c) 对申请的内存进行格式化 av_image_fill_arrays();","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://wanke.fun/categories/FFmpeg/"}],"tags":[],"author":"师学"},{"title":"FFmpeg 编译 for Mac os","slug":"FFmpeg-编译-for-Mac-os","date":"2019-10-30T07:54:00.000Z","updated":"2024-03-12T01:06:15.824Z","comments":true,"path":"FFmpeg/FFmpeg-编译-for-Mac-os/","link":"","permalink":"http://wanke.fun/FFmpeg/FFmpeg-%E7%BC%96%E8%AF%91-for-Mac-os/","excerpt":"介于mac上强大的home brew功能，在macOS 开发ffmpeg还是很简单的。 下面记录下，在macOS上面配置 开发环境的要点","text":"介于mac上强大的home brew功能，在macOS 开发ffmpeg还是很简单的。 下面记录下，在macOS上面配置 开发环境的要点 1. 安装homebrew 执行 brew install ffmpeg 命令，会自动下载安装 。 但是，考虑到网络的情况，如有失败多试几次就好了，此过程全自动完成，不需要进行多余配置。 安装以后，使用 brew info ffmpeg 查看是否安装完成 也可以使用 ffmpeg 命令查看安装信息 。 默认安装路径在 /usr/local/Cellar/ffmpeg 文件夹中(此文件夹默认不可见，在 finder中 可通过 shift + command + g 进行跳转)，推荐使用命令行操作 2. 配置 xcode 开发环境 xcode新建 command line tools 工程，选择c语言 3. 引入 library 和 header文件所在的目录 library 目录： /usr/local/Cellar/ffmpeg/4.2.1_2/lib header 目录： /usr/local/Cellar/ffmpeg/4.2.1_2/include 4. 添加动态链接库 动态链接库位于： /usr/local/Cellar/ffmpeg/4.2.1_2/lib 中 将.a 结尾的文件 添加进来即可 如此，我们完成了环境配置，就可以开始进入了代码的世界 。","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://wanke.fun/categories/FFmpeg/"}],"tags":[],"author":"师学"},{"title":"FFmpeg 编译 for Android ","slug":"FFmpeg-编译-for-Android","date":"2019-10-29T02:09:00.000Z","updated":"2024-03-12T01:06:15.824Z","comments":true,"path":"FFmpeg/FFmpeg-编译-for-Android/","link":"","permalink":"http://wanke.fun/FFmpeg/FFmpeg-%E7%BC%96%E8%AF%91-for-Android/","excerpt":"环境 ： macOS Mojave ndk - android-ndk-r14b ffmpeg - V3.3.9 在实操的过程中发现，别的版本编译不成功，没有过多做深入的研究，找到了这个可以编译的版本使用。","text":"环境 ： macOS Mojave ndk - android-ndk-r14b ffmpeg - V3.3.9 在实操的过程中发现，别的版本编译不成功，没有过多做深入的研究，找到了这个可以编译的版本使用。 编译产物和demo已经放到github ： https://github.com/kongxs/ffmpegDemo 1. 编译1. 替换configure 中的内容 主要是为了修改编译完的产物和命名，以便于Android平台使用 1234567891011 SLIBNAME_WITH_MAJOR=&#x27;$(SLIBNAME).$(LIBMAJOR)&#x27; LIB_INSTALL_EXTRA_CMD=&#x27;$$(RANLIB)&quot;$(LIBDIR)/$(LIBNAME)&quot;&#x27; SLIB_INSTALL_NAME=&#x27;$(SLIBNAME_WITH_VERSION)&#x27; SLIB_INSTALL_LINKS=&#x27;$(SLIBNAME_WITH_MAJOR)$(SLIBNAME)&#x27;替换为 SLIBNAME_WITH_MAJOR=&#x27;$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)&#x27; LIB_INSTALL_EXTRA_CMD=&#x27;$$(RANLIB)&quot;$(LIBDIR)/$(LIBNAME)&quot;&#x27; SLIB_INSTALL_NAME=&#x27;$(SLIBNAME_WITH_MAJOR)&#x27; SLIB_INSTALL_LINKS=&#x27;$(SLIBNAME)&#x27; 2. 编写脚本文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 #!/bin/bashmake clean# NDK的路径，根据自己的安装位置进行设置export TMPDIR=替换为自己的一个路径export NDK=替换为自己的ndk路径export SYSROOT=$NDK/platforms/android-21/arch-arm/export TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64export CPU=armexport PREFIX=$(pwd)/android/$CPUexport ADDI_CFLAGS=&quot;-marm&quot;function build_one&#123;./configure \\ --prefix=$PREFIX \\ --target-os=linux \\ --cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \\ --arch=arm \\ --sysroot=$SYSROOT \\ --extra-cflags=&quot;-Os -fpic $ADDI_CFLAGS&quot; \\ --extra-ldflags=&quot;$ADDI_LDFLAGS&quot; \\ --cc=$TOOLCHAIN/bin/arm-linux-androideabi-gcc \\ --nm=$TOOLCHAIN/bin/arm-linux-androideabi-nm \\ --enable-shared \\ --enable-runtime-cpudetect \\ --enable-gpl \\ --enable-small \\ --enable-cross-compile \\ --disable-debug \\ --disable-static \\ --disable-doc \\ --disable-asm \\ --disable-ffmpeg \\ --disable-ffplay \\ --disable-ffprobe \\ --disable-ffserver \\ --enable-postproc \\ --enable-avdevice \\ --disable-symver \\ --disable-stripping \\$ADDITIONAL_CONFIGURE_FLAGsed -i &#x27;&#x27; &#x27;s/HAVE_LRINT 0/HAVE_LRINT 1/g&#x27; config.hsed -i &#x27;&#x27; &#x27;s/HAVE_LRINTF 0/HAVE_LRINTF 1/g&#x27; config.hsed -i &#x27;&#x27; &#x27;s/HAVE_ROUND 0/HAVE_ROUND 1/g&#x27; config.hsed -i &#x27;&#x27; &#x27;s/HAVE_ROUNDF 0/HAVE_ROUNDF 1/g&#x27; config.hsed -i &#x27;&#x27; &#x27;s/HAVE_TRUNC 0/HAVE_TRUNC 1/g&#x27; config.hsed -i &#x27;&#x27; &#x27;s/HAVE_TRUNCF 0/HAVE_TRUNCF 1/g&#x27; config.hsed -i &#x27;&#x27; &#x27;s/HAVE_CBRT 0/HAVE_CBRT 1/g&#x27; config.hsed -i &#x27;&#x27; &#x27;s/HAVE_RINT 0/HAVE_RINT 1/g&#x27; config.hmake clean# 这里是定义用几个CPU编译，我用4个，一般在5分钟之内编译完成make -j4make install&#125;build_one 其中： TMPDIR为编译生成的临时文件存放的目录 SYSROOT为so文件支持的最低Android版本的平台目录 CPU为指定so文件支持的平台 PREFIX为生成的so文件存放目录 TOOLCHAIN为编译所使用的工具链目录 cross-prefix为编译所使用的工具链文件 enable和disable指定了需要编译的项 target-os为目标操作系统； 3. 执行脚本 ./build_android.sh 等待执行结束会在 目录下生成编译产物 。 位于 android/arm 文件夹下 include // c语言头文件 lib // android可用的so 2. 引入Androidstudio开发环境1. build.gradle 脚本配置 1234567891011121314externalNativeBuild &#123; cmake &#123; cppFlags &quot;&quot; &#125; ndk &#123; abiFilters &quot;armeabi-v7a&quot;//添加平台过滤 &#125; &#125; //指定libs文件夹 sourceSets.main &#123; jniLibs.srcDirs = [&#x27;libs&#x27;] jni.srcDirs = [] &#125; 1. 添加依赖文件 我们将第一步编译好的so放入libs文件夹，将 include文件中的头文件放到cpp文件夹 . 如下所示 2. CMakeLists.txt 文件编写 按照如下进行编写，将我们所有的so都在cmakelist文件中进行注册，联合编译 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129 # For more information about using CMake with Android Studio, read the# documentation: https://d.android.com/studio/projects/add-native-code.html# Sets the minimum version of CMake required to build the native library.cmake_minimum_required(VERSION 3.4.1)# Creates and names a library, sets it as either STATIC# or SHARED, and provides the relative paths to its source code.# You can define multiple libraries, and CMake builds them for you.# Gradle automatically packages shared libraries with your APK.add_library( # Sets the name of the library. native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/native-lib.cpp src/main/cpp/Utils.c )include_directories($&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp)add_library(avcodec-57 # 库名字 SHARED IMPORTED)set_target_properties( avcodec-57 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/libs/armeabi-v7a/libavcodec-57.so)add_library(libavdevice-57 # 库名字 SHARED IMPORTED)set_target_properties( libavdevice-57 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/libs/armeabi-v7a/libavdevice-57.so)add_library(libavfilter-6 # 库名字 SHARED IMPORTED)set_target_properties( libavfilter-6 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/libs/armeabi-v7a/libavfilter-6.so)add_library(libavformat-57 # 库名字 SHARED IMPORTED)set_target_properties( libavformat-57 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/libs/armeabi-v7a/libavformat-57.so)add_library(libavutil-55 # 库名字 SHARED IMPORTED)set_target_properties( libavutil-55 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/libs/armeabi-v7a/libavutil-55.so)add_library(libpostproc-54 # 库名字 SHARED IMPORTED)set_target_properties( libpostproc-54 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/libs/armeabi-v7a/libpostproc-54.so)add_library(libswresample-2 # 库名字 SHARED IMPORTED)set_target_properties( libswresample-2 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/libs/armeabi-v7a/libswresample-2.so)add_library(libswscale-4 # 库名字 SHARED IMPORTED)set_target_properties( libswscale-4 PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/libs/armeabi-v7a/libswscale-4.so)# Searches for a specified prebuilt library and stores the path as a# variable. Because CMake includes system libraries in the search path by# default, you only need to specify the name of the public NDK library# you want to add. CMake verifies that the library exists before# completing its build.find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log )# Specifies libraries CMake should link to your target library. You# can link multiple libraries, such as libraries you define in this# build script, prebuilt third-party libraries, or system libraries.target_link_libraries( # Specifies the target library. native-lib avcodec-57 libavdevice-57 libavfilter-6 libavformat-57 libavutil-55 libpostproc-54 libswresample-2 libswscale-4 # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125; ) 3. 一些问题1. 比如include 12345extern &quot;C&quot;&#123; #include &quot;libavformat/avformat.h&quot; #include &quot;libavutil/log.h&quot;&#125;","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://wanke.fun/categories/FFmpeg/"}],"tags":[],"author":"师学"},{"title":"Flutter 和原生APP进行交互","slug":"Flutter-和原生APP进行交互","date":"2019-10-09T02:19:00.000Z","updated":"2024-03-12T01:06:15.824Z","comments":true,"path":"Flutter/Flutter-和原生APP进行交互/","link":"","permalink":"http://wanke.fun/Flutter/Flutter-%E5%92%8C%E5%8E%9F%E7%94%9FAPP%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92/","excerpt":"在混合开发中，flutter避免不掉的需要和我们原生的Android代码进行交互，例如获取设备电量，或者使用APP已有的功能代码。","text":"在混合开发中，flutter避免不掉的需要和我们原生的Android代码进行交互，例如获取设备电量，或者使用APP已有的功能代码。 本文记录 flutter 和 Android 进行交互的过程！ 创建工程 pluginmy flutter create -t plugin -a java --org com.example pluginmy 1. Flutter调用Java代码( MethodChannel)1.1 java部分代码编写在Java端，首先通过studio 单独打开Android项目 ，然后在 MainActivity中注入MethodChannel 这里的 CHANNEL 需要和我们dart使用的协议保持一致 12345678910111213141516171819202122MethodChannel methodChannel = new MethodChannel(getFlutterView(), CHANNEL); methodChannel.setMethodCallHandler( (call, result) -&gt; &#123; // 在这个回调里处理从Flutter来的调用 if (call.method.equals(&quot;getResult&quot;)) &#123; String batteryLevel = &quot; 这是从Android端返回的结果~ &quot;; result.success(batteryLevel); new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; methodChannel.invokeMethod(&quot;a&quot; , &quot;times = &quot; + times); &#125; &#125;,1000); &#125; else &#123; result.notImplemented(); &#125; &#125;); 1.2 dart部分进行调用如下代码，我们完成了 通过 协议名为 【pluginmy】 调用方法名为 【getPlatformVersion】的功能 只需要在需要的时机，调用 platformVersion方法即可！！！ 12345678910class Pluginmy &#123; static const MethodChannel _channel = const MethodChannel(&#x27;pluginmy&#x27;); static Future&lt;String&gt; get platformVersion async &#123; final String version = await _channel.invokeMethod(&#x27;getPlatformVersion&#x27;); return version; &#125;&#125; 在dart中对methodChannel也可以进行被动接收 . 通过这种方式，可以接收对应的MethodChannel 在 native端进行的方法调用 1234567891011 @override void initState() &#123; super.initState(); platform.setMethodCallHandler((handler) &#123; setState(() &#123;// _callback = handler.arguments; &#125;); &#125;); &#125; 1.3 java调用dart代码参考上一步，第15行代码 2. Flutter 接收Java代码回调(EventChannel)2.1 dart部分进行注册监听1. 首先创建 EventChannel 1static const EventChannel eventChannel = EventChannel(&quot;Event_Channel&quot;); 2. state init 时机注册接收流 12345678910111213eventChannel.receiveBroadcastStream().listen(_onEnvent,onError: _onError)//接收activity传递来的参数obj void _onEnvent(Object obj)&#123;// Fluttertoast.showToast(msg: &quot;from android&quot;); setState(() &#123; _callback = obj; &#125;); &#125; void _onError(Object obj)&#123; &#125; 2.2 Java部分事件派发给dart在mainActivity中创建 EventChannel 12345678910111213EventChannel eventChannel = new EventChannel(getFlutterView(), &quot;Event_Channel&quot;); eventChannel.setStreamHandler(new EventChannel.StreamHandler() &#123; @Override public void onListen(Object o, EventChannel.EventSink eventSink) &#123; sink = eventSink; eventSink.success(&quot;times = sss &quot;); &#125; @Override public void onCancel(Object o) &#123; &#125; &#125;); Flutter中和原生的交互有主动调用和被动接收2种，分别应用于不同的场景中。 MethodChannel提供给dart端进行主动调用，并且可以异步等待此methodChannel返回值。 EventChannel类似于注册一个回调给原生代码，当原生有变动就可以主动广播到我们的dart端。 参考文档： https://www.yuque.com/xytech/flutter/fu7h25","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://wanke.fun/categories/Flutter/"}],"tags":[],"author":"师学"},{"title":"Flutter Android混合开发","slug":"Flutter-Android混合开发","date":"2019-09-27T02:56:00.000Z","updated":"2024-03-12T01:06:15.824Z","comments":true,"path":"Flutter/Flutter-Android混合开发/","link":"","permalink":"http://wanke.fun/Flutter/Flutter-Android%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/","excerpt":"马上国庆节了！！！！！！！","text":"马上国庆节了！！！！！！！ 虽然flutter提供给我们一套十分完善的开发环境，但事实上，在真实的开发中，我们更需要的是如何将flutter集成到我们已有的Android项目。 可喜可贺，在 最近的 flutter版本中，给我们提供了一套更加方便的工具，让我们在已有项目中集成flutter 。 flutter version ： 1.9.1 dart version ： 2.5 根据flutter文档，集成进现有项目，并记录在集成过程中遇到的一些问题 1. 集成步骤1.1 创建flutter moduleflutter create -t module --org com.example my_flutter 通过以上命令，创建了一个名字为 my_flutter 的 module 或者在 Androidstudio 中创建 flutter module 一样 1.2 创建或者使用原有Android工程就是一个普通Android工程，但是要保证 1. minSdkVersion &gt; 16 2. java 版本 1.8 12345678910android &#123; defaultConfig &#123; minSdkVersion 16 &#125; //... compileOptions &#123; sourceCompatibility 1.8 targetCompatibility 1.8 &#125;&#125; 1.3 使用aar的方式集成flutter进入我们的 my_flutter module目录 执行 1flutter build aar 正常情况，会在 my_flutter/build/host/outputs/repo... 得到aar文件，正常添加进Android工程即可 1.4 Android工程中使用 flutter1. activity方式使用 12345678910View flutterView = Flutter.createView( MainActivity.this, getLifecycle(), &quot;route1&quot; ); FrameLayout.LayoutParams layout = new FrameLayout.LayoutParams(600, 800); layout.leftMargin = 100; layout.topMargin = 200; addContentView(flutterView, layout); &#125; 2. fragment 方式使用 123FragmentTransaction tx = getSupportFragmentManager().beginTransaction(); tx.replace(R.id.someContainer, Flutter.createFragment(&quot;route1&quot;)); tx.commit(); 至此，经过以上几个步骤，完成了Android工程通过aar方式集成flutter的全部流程。正常我们可以运行Android 项目看到以下界面 2. 集成遇到的问题2.1 设置镜像在 执行 flutter build aar 的过程中，发现以下错误信息 。 我在解决此问题过程中发现，虽然使用了 vpn代理工具，还是不可以执行，所以要设置阿里镜像 1234567 * What went wrong:A problem occurred evaluating project &#x27;:app&#x27;.&gt; Could not resolve all files for configuration &#x27;classpath&#x27;. &gt; Could not find lint-gradle-api.jar (com.android.tools.lint:lint-gradle-api:26.1.2). Searched in the following locations: https://jcenter.bintray.com/com/android/tools/lint/lint-gradle-api/26.1.2/lint-gradle-api-26.1.2.jar 解决方案： 1. 修改 my_flutter/.android/build.gradle .将 google 和 jcenter两个仓库设置为阿里镜像地址 1234567891011121314151617181920212223 buildscript &#123; repositories &#123; //google() //jcenter() maven &#123; url &#x27;https://maven.aliyun.com/repository/google&#x27; &#125; maven &#123; url &#x27;https://maven.aliyun.com/repository/jcenter&#x27; &#125; maven &#123; url &#x27;http://maven.aliyun.com/nexus/content/groups/public&#x27; &#125; &#125; dependencies &#123; classpath &#x27;com.android.tools.build:gradle:3.1.2&#x27; &#125;&#125;allprojects &#123; repositories &#123; //google() //jcenter() maven &#123; url &#x27;https://maven.aliyun.com/repository/google&#x27; &#125; maven &#123; url &#x27;https://maven.aliyun.com/repository/jcenter&#x27; &#125; maven &#123; url &#x27;http://maven.aliyun.com/nexus/content/groups/public&#x27; &#125; &#125;&#125; 2. flutter sdk 目录下 packages⁩/flutter_tools⁩/⁨gradle⁩找到下 flutter.gradle文件 替换 jcenter 和 maven 仓库 【也有说，这一步其实不用做修改，我自己再做的过程中也没改，多试试吧】 1234567891011121314151617buildscript &#123; repositories &#123; //jcenter() //maven &#123; // url &#x27;https://dl.google.com/dl/android/maven2&#x27; //&#125; maven&#123; url &#x27;https://maven.aliyun.com/repository/jcenter&#x27; &#125; maven&#123; url &#x27;http://maven.aliyun.com/nexus/content/groups/public&#x27; &#125; &#125; dependencies &#123; classpath &#x27;com.android.tools.build:gradle:3.1.2&#x27; &#125; &#125; 至此经过大半天的折腾，总算完成了aar的集成 。 大功告成，来之不易 ~~ 参考： Add Flutter to existing apps","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://wanke.fun/categories/Flutter/"}],"tags":[],"author":"师学"},{"title":"Flutter 状态管理provider","slug":"Flutter-状态管理provider","date":"2019-09-26T07:09:00.000Z","updated":"2024-03-12T01:06:15.824Z","comments":true,"path":"Flutter/Flutter-状态管理provider/","link":"","permalink":"http://wanke.fun/Flutter/Flutter-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86provider/","excerpt":"前端开发者或者reactNative开发者 对于状态管理应该不会陌生，例如前端大名鼎鼎的redux框架 。","text":"前端开发者或者reactNative开发者 对于状态管理应该不会陌生，例如前端大名鼎鼎的redux框架 。 在flutter中，对于状态的同步管理是一项很繁琐的申请，比如我们需要将一个值传入后续的N个widget中，需要一层层的传递，并且对于值同步也很麻烦。 在这样的背景下，各种状态管理框架应运而生了，它可以让我们更方便的管理state，同步数据，等操作 在2019年google io大会，用 provider 取代了之前 的provide 框架 ，provider框架很健壮也有灵活，配置简单，本文主要介绍 provider框架的用法 1. 添加依赖在pubspec.yaml文件中添加以下依赖 ,然后执行 flutter pub get 进行下载安装 1provider: ^3.1.0 2.1 简单使用相比较于之前的写法，这里我们用Provider.value()的方式进行构件一个APP flutter APP 入口处添加一下代码 12345678910111213void main() =&gt; runApp(new ZhiHu());class ZhiHu extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Provider&lt;String&gt;.value( value: &quot;hello from provider&quot;, child: MaterialApp( title: &quot;知乎-高仿版&quot;, home: Index(), ), ); &#125;&#125; 在这里，我们将一个 值为 ‘hello from provider’ 的字符串设置为共享，并返回一个materialApp 2.2 获取值1. 使用consumer的方式获取并返回一个widget 12345Consumer( builder: (BuildContext c,String value,Widget child)&#123; return Text(&quot;text : $value&quot;); &#125; ), 2. 直接获取 1Provider.of&lt;String&gt;(context) 3. 结合ChangeNotifier 接收监听变化使用场景如下： 我们在首页有一个按钮显示初始值1，点击跳转到第二个页面，然后改变这个值，返回到首页，看到值同步。 1. 首先定义我们的 Count类金西行数据监听 12345678910class Count with ChangeNotifier &#123;//1 int _count; Count(this._count); void add() &#123; _count++; notifyListeners();//2 &#125; get count =&gt; _count;//3&#125; 2. 注册provider. 将我们的count注册进去 12345return MultiProvider( providers: [ ChangeNotifierProvider(builder: (_) =&gt; Count(1)), ], child: MaterialApp() 3. 设置 FloatActionButton 12345678910111213 floatingActionButton: Consumer&lt;Count&gt;( builder: (BuildContext context, Count snapshot, Widget child) &#123; return FloatingActionButton( onPressed: () &#123;// snapshot.add() Navigator.pushNamed(context, &quot;/home&quot;); &#125;, child: Text(// &#x27;$&#123;Store.value&lt;Count&gt;(context).count&#125;&#x27; &#x27;$&#123;snapshot.count&#125;&#x27; ), ); 到此为止，完成了首页的开发工作。下面进行第二页的开发，我们显示 count中的数字，使用按钮进行 1 的递加 ，当我们点击按钮，回到首页会发现，按钮上的文字已经改变为我们修改后的值 1234567891011121314Builder( builder: (context) &#123; return Text( &#x27;second page: $&#123;Store.value&lt;Count&gt;(context).count&#125;&#x27; ); &#125;, ), RaisedButton( child: Text(&quot;button&quot;), onPressed: () =&gt; &#123; Store.value&lt;Count&gt;(context).add() &#125;, ), 4. provider的简单封装12345678910111213141516171819202122class Store &#123; static BuildContext context; static BuildContext widgetCtx; static init(&#123;context, child&#125;) &#123; return MultiProvider( providers: [// Provider&lt;Count&gt;.value(value: Count(1)), ChangeNotifierProvider(builder: (_) =&gt; Count(1)), ], child: child, ); &#125; static T value&lt;T&gt;(context) &#123; return Provider.of(context); &#125; static Consumer connect&lt;T&gt;(&#123;builder, child&#125;) &#123; return Consumer&lt;T&gt;(builder: builder, child: child); &#125;&#125; 参考：pub.dev&#x2F;packages&#x2F;provider","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://wanke.fun/categories/Flutter/"}],"tags":[],"author":"师学"},{"title":"Flutter 页面路由","slug":"Flutter-页面路由","date":"2019-09-24T02:03:00.000Z","updated":"2024-03-12T01:06:15.825Z","comments":true,"path":"Flutter/Flutter-页面路由/","link":"","permalink":"http://wanke.fun/Flutter/Flutter-%E9%A1%B5%E9%9D%A2%E8%B7%AF%E7%94%B1/","excerpt":"路由跳转在flutter中是一个非常重要的概念 。我们在开发中不可避免的需要涉及到页面之间的交互，传参，出参等操作 。 这就引出了我们的路由，在flutter中，有两种实现路由的方式，分别是 基本路由和router命名路由。 本节针对路由做一次系统的梳理和记录","text":"路由跳转在flutter中是一个非常重要的概念 。我们在开发中不可避免的需要涉及到页面之间的交互，传参，出参等操作 。 这就引出了我们的路由，在flutter中，有两种实现路由的方式，分别是 基本路由和router命名路由。 本节针对路由做一次系统的梳理和记录 1. navigator 基本路由使用很简单的， 首先新建一个页面 widget 例如 class TextDemo extends StatefulWidget &#123; ······ ······ &#125; 假如说我们的页面中有一个按钮被触发的时候，我们通过如下代码即可 跳转至 TextDemo页面 12Navigator.push( context, new MaterialPageRoute(builder: (context) =&gt; TextDemo())); 2. route 命名路由1. 首先新建routes列表，我们已经创建了 HomeTabs,和SearchTabs两个页面 1234var routes = &#123; &#x27;/home&#x27;:(context,&#123;arguments&#125;) =&gt; HomeTabs(arguments:arguments),= &#x27;/search&#x27;:(context) =&gt; SearchTabs(),= &#125;; 2. MaterialApp 通过重写 routes属性，进行route注册 12345MaterialApp( title: &#x27;Flutter Demo&#x27;, home: MyHomePage(title: &#x27;Flutter Demo Home Page&#x27;), routes: routes, ） 3. 最后就是在触发的时候进行跳转.一行代码搞定 1Navigator.pushNamed(context, &quot;/home&quot;); 3. 替换路由在当前页面加载目标页面，用目标页面替换当前 1Navigator.pushReplacementNamed(context, &quot;/home&quot; 4. 返回根路由在 A widget打开多个页面以后，返回 A 1. 参考替换路由 2. 12345Navigator.pop(context,&quot;result from route&quot;), Navigator.of(context).pushAndRemoveUntil( MaterialPageRoute( builder: (context) =&gt; MyApp(), ), (routes) =&gt; routes == null) 5. router 传参route传参的做法和上一步基本类似 1. 首先定义route列表，参考上一步做法 2. MaterialApp 通过重写 onGenerateRoute，进行route接管。 基本是固定写法 12345678910111213141516171819MaterialApp( onGenerateRoute: (RouteSettings settings) &#123; final String name = settings.name; final Function pageBuilder = this.routes[name]; if (pageBuilder != null) &#123; if (settings.arguments != null) &#123; final Route route = MaterialPageRoute( builder: (context) =&gt; pageBuilder(context,arguments: settings.arguments), ); return route; &#125; else &#123; final Route route = MaterialPageRoute( builder: (context) =&gt; pageBuilder(context), ); return route; &#125; &#125; return null; &#125;, 3. 最后就是在触发的时候进行跳转 123Navigator.pushNamed(context, &quot;/home&quot;,arguments: &#123; &quot;id&quot; : &quot;11sasdfasdfasdfadfafdafasdfadfafdasdfafa&quot;, &#125;) 4. 在目标页面接收传入的参数 12345678910111213141516171819202122232425262728293031 class HomeTabs extends StatefulWidget &#123; final arguments; HomeTabs(&#123;this.arguments&#125;); @override State&lt;StatefulWidget&gt; createState() &#123; // TODO: implement createState return HomTabsState(); &#125;&#125;class HomTabsState extends State&lt;HomeTabs&gt; &#123; @override Widget build(BuildContext context) &#123; var argu = widget.arguments; var va = &quot;&quot;; if (argu != null) &#123; va = argu[&quot;id&quot;]; &#125; return Text(&quot;home = $va &quot; ); &#125;&#125; 6. 接收返回值1. 开启一个新的页面(widget)，当目标页面被关闭，我们需要接收返回值的时候， 12345void toRouteDemo(BuildContext context) async &#123; final result = await Navigator.push(context,MaterialPageRoute(builder:(context) =&gt; RouteDemo() )); Fluttertoast.showToast(msg: result); &#125; 2. 目标页面关闭，并返回值 1Navigator.pop(context,&quot;result from route&quot;), 代码https://github.com/kongxs/flutter_demp 参考：https://api.flutter.dev/flutter/widgets/Navigator-class.html","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://wanke.fun/categories/Flutter/"}],"tags":[],"author":"师学"},{"title":"Flutter helloWorld","slug":"Flutter-helloWorld","date":"2019-09-23T03:28:00.000Z","updated":"2024-03-12T01:06:15.824Z","comments":true,"path":"Flutter/Flutter-helloWorld/","link":"","permalink":"http://wanke.fun/Flutter/Flutter-helloWorld/","excerpt":"作为一个Android开发者，学习flutter的过程中，看看这篇文章，会有不小的收获flutter for android developer 国际惯例，先来一个helloWorld Androidstudio创建一个Flutter project","text":"作为一个Android开发者，学习flutter的过程中，看看这篇文章，会有不小的收获flutter for android developer 国际惯例，先来一个helloWorld Androidstudio创建一个Flutter project 1. flutter项目结构认识一个flutter项目以下目录结构(如图) 1. lib 文件夹存放我们的dart源文件 2. pubspec.yaml文件 2. pubspec.yaml 文件配置文件，声明了我们项目的依赖，第三方库，assets资源 图片等 点击packages get 下载依赖，然后使用 3. 第一个flutter项目构件一个material风格的app -&gt; MaterialApp home: 即显示的主内容，MyHomePage 123456789101112131415 void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &#x27;Flutter Demo&#x27;, theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(title: &#x27;Flutter Demo Home Page&#x27;), ); &#125;&#125; 主界面展示： 1. Scaffold 是flutter提供给我们的一个widget，它包含了appbar，floatActionButton，drawer，等一些列功能 12345678910111213141516171819202122232425262728293031323334353637383940414243 class MyHomePage extends StatelessWidget &#123; MyHomePage(&#123;Key key, this.title&#125;) : super(key: key); final String title; @override Widget build(BuildContext context) &#123; // TODO: implement build return Scaffold( appBar: AppBar( // Here we take the value from the MyHomePage object that was created by // the App.build method, and use it to set our appbar title. title: Text(&quot;title&quot;), ), body: Center( // Center is a layout widget. It takes a single child and positions it // in the middle of the parent. child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( &#x27;You have pushed the button this many times:&#x27;, ), Text( &#x27;times&#x27;, style: Theme.of(context).textTheme.display1, ), ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: &#x27;Increment&#x27;, child: Icon(Icons.add), ), // This trailing comma makes auto-formatting nicer for build methods. ); &#125; void _incrementCounter() &#123; &#125;&#125; 运行效果： 4. 项目剖析在flutter中，入口函数为main ，我们通过runapp构件一个material风格的app，并通过scaffold设置了 appBar等 flutter中万物皆widget，我们常用的widget分为有状态和无状态两种， StatelessWidget，StateFulWidget 其中，stateFulWidget可以让我们更新widget显示，比如图片，文字，等 项目源码已上传至 github lib&#x2F;helloWorld.dart","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://wanke.fun/categories/Flutter/"}],"tags":[],"author":"师学"},{"title":"Flutter 架构的认识","slug":"Flutter-架构的认识","date":"2019-09-21T02:48:00.000Z","updated":"2024-03-12T01:06:15.824Z","comments":true,"path":"Flutter/Flutter-架构的认识/","link":"","permalink":"http://wanke.fun/Flutter/Flutter-%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AE%A4%E8%AF%86/","excerpt":"flutter 是一个优秀的跨平台UI组件库，Google 强大的支持，横跨 Android ，iOS，web 等平台。 基于dart开发语言，skia 引擎 直接通过 GPU渲染，极低的性能损耗 material 设计风格 （ios 为 Cupertino） 视觉统一更优美","text":"flutter 是一个优秀的跨平台UI组件库，Google 强大的支持，横跨 Android ，iOS，web 等平台。 基于dart开发语言，skia 引擎 直接通过 GPU渲染，极低的性能损耗 material 设计风格 （ios 为 Cupertino） 视觉统一更优美 flutter 有着良好的架构设计，framework使用dark开发语言 底层的 dart、skia引擎 和 Text(纹理) 使用 c++实现，有着良好的性能 flutter 概述，整体架构等， flutter示例，包括widget控件等常用功能实现 开始flutter学习，所有代码存放至githubhttps://github.com/kongxs/flutter_demp 1. flutter 架构分层 2. flutter GPU渲染下图可以看出flutter的渲染是直接调用GPU完成的，由此达到高性能。媲美原生体验，在某些方面做了优化，甚至可以做到更好。 3. flutter 状态管理 参考： https://flutterchina.club https://flutter.io","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://wanke.fun/categories/Flutter/"}],"tags":[],"author":"师学"},{"title":"Android target升级","slug":"Android-target升级","date":"2019-09-16T02:18:00.000Z","updated":"2024-03-12T01:06:15.823Z","comments":true,"path":"Android/Android-target升级/","link":"","permalink":"http://wanke.fun/Android/Android-target%E5%8D%87%E7%BA%A7/","excerpt":"targetSdkVersion 从23(6.0) 升级到 26(8.0) 适配记录","text":"targetSdkVersion 从23(6.0) 升级到 26(8.0) 适配记录 1. Android 7.0 适配主要适配内容 1. FileProvider 在官方7.0的以上的系统中，尝试传递 file://URI可能会触发FileUriExposedException 可能的应用场景： 例如 拍照获取图片，图片裁剪等 ，官方也给出了适配方案，那么就是 使用fileProvider 1.1 FileProvider声明 1. 首先在清单文件中注册 provider 123456789&lt;provider android:name=&quot;android.support.v4.content.FileProvider&quot; android:authorities=&quot;$&#123;packageName&#125;.fileProvider&quot; android:exported=&quot;false&quot; android:grantUriPermissions=&quot;true&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/nt_file_paths&quot; /&gt; &lt;/provider&gt; 2. 在res/xml 新建 nt_file_paths.xml 文件 123456789101112131415 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;paths&gt; &lt;external-path name=&quot;external_storage_root&quot; path=&quot;.&quot; /&gt; &lt;cache-path name=&quot;cache&quot; path=&quot;.&quot; /&gt; &lt;external-cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt;&lt;/paths&gt; 以上是FileProvider的声明，以上声明了我们要使用 sdcard下所有目录，cache所有目录 ，具体请查阅 官网文档 1.2 FileProvider的使用1. 创建了工具类方便uri的转换 1234567891011121314151617181920212223242526272829303132333435 /** * * 适配android 7.0 N * * */public class AndroidNCompat &#123; public static Uri transform(Context context,Uri origin)&#123; return isAndroidN() ? FileProvider.getUriForFile(context, context.getPackageName() + &quot;.fileProvider&quot;, new File(origin.getPath())) : origin; &#125; public static Uri transform(Context context,File file) &#123; return isAndroidN() ? FileProvider.getUriForFile(context, context.getPackageName() + &quot;.fileProvider&quot;, file) : Uri.fromFile(file); &#125; public static Uri transform(Context context,String path) &#123; return transform(context,new File(path)); &#125; public static boolean isAndroidN() &#123; return Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N; &#125;&#125; 2. 就以调用系统相册进行图片裁剪为例 1234567891011121314151617181920212223242526272829 public static void cropImageFile(Activity activity, Uri inputUri, Uri outputUri, int length, int requestCode) &#123; inputUri = AndroidNCompat.transform(activity, inputUri);// outputUri = AndroidNCompat.transform(activity, outputUri); activity.grantUriPermission(activity.getPackageName(),inputUri,Intent.FLAG_GRANT_READ_URI_PERMISSION | FLAG_GRANT_WRITE_URI_PERMISSION); activity.grantUriPermission(activity.getPackageName(),outputUri,Intent.FLAG_GRANT_READ_URI_PERMISSION | FLAG_GRANT_WRITE_URI_PERMISSION); Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);// intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | FLAG_GRANT_WRITE_URI_PERMISSION); intent.setDataAndType(inputUri, &quot;image/*&quot;); intent.putExtra(&quot;crop&quot;, &quot;true&quot;); intent.putExtra(&quot;aspectX&quot;, 1); intent.putExtra(&quot;aspectY&quot;, 1); intent.putExtra(&quot;outputX&quot;, length); intent.putExtra(&quot;outputY&quot;, length); intent.putExtra(&quot;scale&quot;, true); intent.putExtra(MediaStore.EXTRA_OUTPUT, outputUri); intent.putExtra(&quot;return-data&quot;, false); intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG.toString()); intent.putExtra(&quot;noFaceDetection&quot;, true); activity.startActivityForResult(intent, requestCode); &#125; 2. Android 8.0 适配1. 本文主要说 通知栏，为了更好的管理通知，google推出了channel的概念，更方便用于进行更精细化的通知管理。 123456789101112131415161718192021222324252627282930313233public static void sendSimpleNotification2(Context context) &#123; String id = &quot;channel_001&quot;; String name = &quot;name&quot;; NotificationManager notificationManager = (NotificationManager) context.getSystemService(context.NOTIFICATION_SERVICE); Notification.Builder notificationBuilder = new Notification.Builder(context); //重点 if (AndroidOCompat.isAndroidO()) &#123; NotificationChannel mChannel = new NotificationChannel(id, name, NotificationManager.IMPORTANCE_HIGH); notificationManager.createNotificationChannel(mChannel); notificationBuilder.setChannelId(id); &#125; notificationBuilder .setContentTitle(&quot;活动11&quot;) .setContentText(&quot;您有一项新活动&quot;) .setSmallIcon(R.drawable.ic_launcher); notificationManager.notify(1, notificationBuilder.build()); &#125; 通知的适配比较简单，重点关注 isAndroidO 方法即可，主要在我们对于项目中已有的通知进行排查 2. 主题的 Activity 设置屏幕方向 针对 8.0 的应用，设置了透明主题的Activity，再设置屏幕方向， 会抛出一下异常信息， 123java.lang.IllegalStateException: Only fullscreen opaque activities can request orientation 例如 activity 做了如下配置： 解决方案： 去掉其中一个 参考文档列表 ： https://developer.android.com/about/versions/nougat/android-7.0https://developer.android.com/about/versions/nougat/android-8.0","categories":[{"name":"Android","slug":"Android","permalink":"http://wanke.fun/categories/Android/"}],"tags":[],"author":"师学"},{"title":"手机刷入第三方recovery","slug":"手机刷入第三方recovery","date":"2019-09-06T02:26:00.000Z","updated":"2024-03-12T01:06:15.828Z","comments":true,"path":"Note2/手机刷入第三方recovery/","link":"","permalink":"http://wanke.fun/Note2/%E6%89%8B%E6%9C%BA%E5%88%B7%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9recovery/","excerpt":"第三方recovery刷入手机 以小米note为例","text":"第三方recovery刷入手机 以小米note为例 1. 准备工作1. 解锁手机 Bootloader（BL） 2. recovery 这里选择了twrp 下载完的文件名修改为 trwp.img 3. adb 工具 2. 准备安装1. adb工具 重启到 fastboot模式 adb reboot bootloader 2. 刷入我们下载的 img fastboot flash recovery twrp.img 3. 重启到我们刷入的recovery fastboot boot twrp.img 一些资料下载https://twrp.me/Devices/https://download.lineageos.org/scorpio","categories":[{"name":"Note2","slug":"Note2","permalink":"http://wanke.fun/categories/Note2/"}],"tags":[],"author":"师学"},{"title":"gradle 自定义transform实践","slug":"gradle-自定义transform实践","date":"2019-08-28T11:55:00.000Z","updated":"2024-03-12T01:06:15.826Z","comments":true,"path":"Gradle/gradle-自定义transform实践/","link":"","permalink":"http://wanke.fun/Gradle/gradle-%E8%87%AA%E5%AE%9A%E4%B9%89transform%E5%AE%9E%E8%B7%B5/","excerpt":"1. 工程配置","text":"1. 工程配置 1. 添加 gradle api依赖 12compile &#x27;com.android.tools.build:gradle:3.0.1&#x27; compile group: &#x27;org.javassist&#x27;, name: &#x27;javassist&#x27;, version: &#x27;3.22.0-GA&#x27; 2. 自定义transform注入123456 class MyPlugin implements Plugin&lt;Project&gt; &#123; void apply(Project project) &#123; def android = project.extensions.getByType(AppExtension) android.registerTransform(new CodeTrans(project)) &#125;&#125; 3. transform自定义自定义 transform 扩展自 Transform ，实现 transform 方法即可 3.1 transform的概念google 的android编译流程，以transform的形式提供给我们可干涉的时机 我们可以在编译成class文件并且生成dex之前拿到这些编译完成的class文件，做一些我们想要的修改。 我们自定义的transform会被包装秤一个 transform task，在 java compile task 之后执行。 3.2 transform的执行流程transform 执行流程如下 3.3 transform api123456789public abstract class Transform &#123; 1. public abstract String getName(); 2. public abstract Set&lt;ContentType&gt; getInputTypes(); 3. public abstract Set&lt;? super Scope&gt; getScopes(); 3. public abstract boolean isIncremental(); // 是否支持增量编译&#125; 1. name : 此 transform的名字，也是这个transform代表的task的名字 2. getInputTypes ： 输入类型，作为输入过滤，transformManager中定义了有如下类型。 123456public static final Set&lt;ContentType&gt; CONTENT_CLASS; public static final Set&lt;ContentType&gt; CONTENT_JARS; public static final Set&lt;ContentType&gt; CONTENT_RESOURCES; public static final Set&lt;ContentType&gt; CONTENT_NATIVE_LIBS; public static final Set&lt;ContentType&gt; CONTENT_DEX; 3. getScopes ： 作用域 transformManager中定义了如下类型 12345public static final Set&lt;ScopeType&gt; PROJECT_ONLY; public static final Set&lt;Scope&gt; SCOPE_FULL_PROJECT; public static final Set&lt;ScopeType&gt; SCOPE_FULL_WITH_IR_FOR_DEXING; public static final Set&lt;ScopeType&gt; SCOPE_FULL_LIBRARY_WITH_LOCAL_JARS; 3.4 代码实例在以下的例子中，我们继承transform方法，修改我们关心的类，在静态函数中插入一行打印语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void transform(Context context, Collection&lt;TransformInput&gt; inputs, Collection&lt;TransformInput&gt; referencedInputs, TransformOutputProvider outputProvider, boolean isIncremental) throws IOException, TransformException, InterruptedException &#123;// super.transform(context, inputs, referencedInputs, outputProvider, isIncremental) ExtParams params = project.extParams println &quot; params.logEnable is $&#123; params.logEnable &#125;&quot; println &quot;transform method is invoked ====== --------------- &quot;// System.out.println(&quot;=======================================doPathTransform&#123; context=$&#123;context&#125;, inputs=$&#123;inputs&#125;, referencedInputs=$&#123;referencedInputs&#125;, outputProvider=$&#123;outputProvider&#125;, isIncremental=$&#123;isIncremental&#125;&quot;) inputs.each &#123; TransformInput input -&gt; input.directoryInputs.each &#123; DirectoryInput directoryInput -&gt; //修改我们关注的类 InjectU.inject(directoryInput.file.absolutePath) //获取输出目录 def dest = outputProvider.getContentLocation( directoryInput.name,directoryInput.contentTypes,directoryInput.scopes, Format.DIRECTORY)// println &quot;directory name location is $&#123;directoryInput.name&#125;&quot; com.android.utils.FileUtils.copyDirectory( directoryInput.file,dest) &#125; input.jarInputs.each &#123; JarInput jarInput -&gt; //jar文件一般是第三方依赖库jar文件 // 重命名输出文件（同目录copyFile会冲突） def jarName = jarInput.name def md5 = DigestUtils.md5Hex(jarInput.file.getAbsolutePath()) if (jarName.endsWith(&quot;.jar&quot;)) &#123; jarName = jarName.substring(0,jarName.length() - 4 ) &#125; //输出 def dest = outputProvider.getContentLocation(jarName, jarInput.contentTypes,jarInput.scopes,Format.JAR)// println &quot; jar name location is $&#123;jarInput.name&#125;&quot; FileUtils.copyFile(jarInput.file,dest) &#125; &#125; &#125; 以下代码用javassist实现了再构造函数中插入语句的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class InjectU &#123; static ClassPool pool = ClassPool.getDefault() static String injectStr = &quot;System.out.println(\\&quot;I Love android-----\\&quot; ); &quot; /** * * @param path file path */ static void inject(String path) &#123; pool.appendClassPath(path) def dir = new File(path); if (dir.isDirectory()) &#123; dir.eachFileRecurse &#123; File file -&gt; def filePath = file.absolutePath //确保当前文件是class文件，并且不是系统自动生成的class文件 if (filePath.endsWith(&quot;.class&quot;) &amp;&amp; !filePath.contains(&#x27;R$&#x27;) &amp;&amp; !filePath.contains(&#x27;R.class&#x27;) &amp;&amp; !filePath.contains(&quot;BuildConfig.class&quot;)) &#123; println &quot;file path is $&#123;filePath&#125;&quot; int index = filePath.indexOf(&quot;com/example/pluginproject&quot;); if (index != -1) &#123; int end = filePath.length() - 6 // .class = 6 String className = filePath.substring(index, end) .replace(&#x27;\\\\&#x27;, &#x27;.&#x27;).replace(&#x27;/&#x27;, &#x27;.&#x27;) println &quot;not -1 class name is $&#123;className&#125;&quot; def c = pool.getCtClass(className) if (c.isFrozen()) &#123; c.defrost() &#125; CtConstructor[] declaredConstructors = c.getDeclaredConstructors(); if (declaredConstructors == null || declaredConstructors.length == 0) &#123; CtConstructor constructor = new CtConstructor(new CtClass[0], c); c.addConstructor(constructor); constructor.insertBeforeBody(injectStr); &#125; else &#123; declaredConstructors[0].insertBeforeBody(injectStr); &#125; c.writeFile(path) c.detach() &#125; &#125; &#125; &#125; &#125;&#125; 代码已托管至 Github ，点击获取","categories":[{"name":"Gradle","slug":"Gradle","permalink":"http://wanke.fun/categories/Gradle/"}],"tags":[],"author":"kongxs"},{"title":"gradle 自定义plugin基本方式","slug":"gradle-自定义plugin基本方式","date":"2019-08-26T09:40:50.000Z","updated":"2024-03-12T01:06:15.826Z","comments":true,"path":"Gradle/gradle-自定义plugin基本方式/","link":"","permalink":"http://wanke.fun/Gradle/gradle-%E8%87%AA%E5%AE%9A%E4%B9%89plugin%E5%9F%BA%E6%9C%AC%E6%96%B9%E5%BC%8F/","excerpt":"1. 实现的几种方式","text":"1. 实现的几种方式 1. 直接在 app 的gradle文件中编写 只有当前module可用，可用于本地调试 2. buildSrc工程 只有当前工程可用，重复使用，不可上传 3. 独立module 要配合上传到本地或者远端仓库使用 2. 如何实现2.1 直接使用好处： 使用简单，配置简单 缺点： 只能在当前module使用，局限性大 实现方式： 1. 在APP的build.gradle文件中定义plugin 1234567apply plugin: MyPluginclass MyPlugin implements Plugin&lt;Project&gt; &#123; void apply(Project project) &#123; println &quot;hello this my plugin in module &quot; &#125;&#125; build当前工程，执行 ./gradlew build 即可看到输入 2.2 buildSrc方式1. 新建 java module 名字 为 buildSrc 2. 配置gradle文件 12345678apply plugin: &#x27;java-library&#x27;apply plugin: &#x27;groovy&#x27;dependencies &#123; compile gradleApi() compile localGroovy()&#125; 3. 编写plugin实现 1234567891011package fun.wanke.pluginimport org.gradle.api.Pluginimport org.gradle.api.Projectclass MyPlugin implements Plugin&lt;Project&gt; &#123; void apply(Project project) &#123; println &quot;hello this my plugin in src module &quot; &#125;&#125; 4. 在APP中引用完整的类名 apply plugin: fun.wanke.plugin.MyPlugin 5. 执行./gradlew build 验证即可看到输出 2.3 独立module2.3.1 建立插件工程独立的module是配置最为复杂，使用灵活的一种实现方式 1. 创建java工程 2. gradle 配置 123456789apply plugin: &#x27;java-library&#x27;apply plugin: &#x27;groovy&#x27;dependencies &#123; compile gradleApi() compile localGroovy()&#125; 3. 创建插件类 12345678910package fun.wanke.pluginimport org.gradle.api.Pluginimport org.gradle.api.Projectclass MyPlugin implements Plugin&lt;Project&gt; &#123; void apply(Project project) &#123; println &quot;hello this my plugin in standalone &quot; &#125;&#125; 4. 创建资源文件，按照以下目录进行 - module - src - main - resources - META-INF - gradle-plugin 在main下创建目录，最后我们在 gradle-plugin 文件夹下创建属性文件 fun.wanke.plugin.properties 文件名规则要按照我们plugin所在的包名命名 implementation-class=fun.wanke.plugin.MyPlugin 文件中写入以上信息。value 为 我们的自定义插件完整命名 2.3.2 上传插件到本地仓库在我们的工程的gradle文件中追加一下信息 123456789101112131415161718apply plugin: &#x27;maven&#x27;repositories &#123; jcenter() mavenCentral()&#125;group = &#x27;fun.wanke.plugin&#x27;version = &#x27;0.7&#x27;uploadArchives &#123; repositories &#123; mavenDeployer &#123; repository(url: uri(&quot;../repository&quot;)) &#125; &#125;&#125; 我们配置了maven仓库，并且新建了一个uploadtask，把maven仓库配置为工程所在的根目录 我们同步gradle会在gradle看板中找到一个 uploadArchive的task 执行此task，会在工程根目录生成一个respository文件夹 2.3.3 使用本地仓库的插件工程根目录配置gradle文件，添加classpath如下 1. classpath &#39;fun.wanke.plugin:myPlugin:0.7&#39; 组织结构为 [packagename：moduleName：version] 2. respositories 添加maven仓库地址 123maven &#123;// 添加Maven的本地依赖 url uri(&#x27;./repository&#x27;) &#125; 3. app 的gradle 文件中应用 apply plugin: &#39;fun.wanke.plugin&#39; 4. clean and make project 代码已托管至 Github ，点击获取","categories":[{"name":"Gradle","slug":"Gradle","permalink":"http://wanke.fun/categories/Gradle/"}],"tags":[]},{"title":"gradle 核心概念详解","slug":"gradle-核心概念详解","date":"2019-08-23T08:24:00.000Z","updated":"2024-03-12T01:06:15.826Z","comments":true,"path":"Gradle/gradle-核心概念详解/","link":"","permalink":"http://wanke.fun/Gradle/gradle-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3/","excerpt":"gradle 核心概念详解","text":"gradle 核心概念详解 1. project工程中每个module 都是一个project 。在此工程中，一共有三个project 分别是 myAppliance，app 和 lib 方法介绍： 1. this.beforeEvaluate 2. this.afterEvaluate 3. this.gradle.buildFinished 4. getSubprojects 5. getAllProjects 6. getRootProject 7. project 方法 project(&quot;lib&quot;) &#123; //可以对lib 这个module进行配置 Project project -&gt; println (&quot;lib project -- $&#123;project.name&#125;&quot;) &#125; 123456project(&quot;lib&quot;) &#123; //可以对lib 这个module进行配置 Project project -&gt; apply plugin &#x27;xxx&#x27; group &#x27;xxxx&#x27; &#125; 2. 对所有project进行配置allprojects 闭包 3. subProjectsubprojects &#123; Project p -&gt; if(p.plugins.contains(&quot;library&quot;)) apply from &#39;../xxx.gradle&#39; &#125; 4. Project 属性扩展 1根project定义 ext 然后进行字段的扩展 ext &#123; jdk_version = 8l &#125; gradle文件扩展，可以将gradle文件独立出来，然后在module 的gradlee文件使用 apply from : this.file(&quot;path&quot;) 5. Project 属性扩展 2gradle.properties 中定义 ig: isModule = true 使用： if(hasProperty(&#39;isModule&#39;)) &#123; include &#39;lib&#39; &#125; 6. 文件属性操作文件路径获取 ： println getRootDir() println getBuildDir() println getProjectDir() 7. task执行顺序1. dependsOn 属性指定 task(&quot;taskX&quot;) &#123; doLast &#123; println &quot;taskX&quot; &#125; &#125; task (&quot;taskY&quot;,dependsOn: taskX) &#123; doLast &#123; println &quot;taskY&quot; &#125; &#125; 2. mustRunAfter 维护 task (&quot;taskY&quot;) &#123; mustRunAfter taskX doLast &#123; println &quot;taskY&quot; &#125; &#125; 8. 将自定义task挂载到构件过程this.project.afterEvaluate&#123; def build = project.tasks.getByName(&quot;build&quot;); build.doLast &#123; cusTask.execute(); &#125; &#125;","categories":[{"name":"Gradle","slug":"Gradle","permalink":"http://wanke.fun/categories/Gradle/"}],"tags":[]},{"title":"jvm 垃圾收集算法","slug":"jvm-垃圾收集算法","date":"2019-08-14T09:47:15.000Z","updated":"2024-03-12T01:06:15.826Z","comments":true,"path":"Jvm/jvm-垃圾收集算法/","link":"","permalink":"http://wanke.fun/Jvm/jvm-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/","excerpt":"1. 标记-清除算法","text":"1. 标记-清除算法 标记清除 是最基础的垃圾收集算法，因为后续的所有gc算法都是基于此进行的改进。 特点： 分为标记和收集2个阶段，首先标记处需要回收的对象，然后统一回收 不足： 效率问题，空间碎片，当分配大对象时会因为没有足够的连续内存空间二导致提前出发gc 2. 复制收集算法将可用内存分为大小相等的2份，每次只是用其中的一块，当这块内存用完，就将活着的对象赋值到另一块空间， 然后将是用过的内存空间清理掉。 特点： 简单，运行高晓晓 不足： 将内存空间缩小为原来的一半，代价有些高。 3. 标记-整理算法复制收集算法在对象存活率较高时候就要进行多次复制，效率低。 老年代采用了标记清除算法，把存活的对象都向一端移动，然后清理掉其他内存 4. 分代收集算法当前商用虚拟机大多采用分代收集的算法。 根据对象存活的手气不同，将内存划分为新生代和老年代，然后根据不同区域采用不同收集算法。 新生代： 每次收集都会有大批对象死去，采用复制算法，只需要少量对象复制的成本就可以完成收集。 老年代： 对象存活率高，采用标记-清理或者标记-整理算法 5. minor 和 major gc新生代gc (minor gc) ： java对象大多朝生夕死，所以minor gc会很频繁，回收速度也快 老年代gc (major gc) ： 一次 major gc 通常伴随着至少一次的minor gc 大对象和长期存活的对象直接进入老年代 每次gc都会讲对象头中的age + 1，一般最大为15就会进入老年代","categories":[{"name":"Jvm","slug":"Jvm","permalink":"http://wanke.fun/categories/Jvm/"}],"tags":[]},{"title":"nio buffer 学习详解","slug":"nio-buffer-学习详解","date":"2019-08-13T01:47:02.000Z","updated":"2024-03-12T01:06:15.827Z","comments":true,"path":"Nio/nio-buffer-学习详解/","link":"","permalink":"http://wanke.fun/Nio/nio-buffer-%E5%AD%A6%E4%B9%A0%E8%AF%A6%E8%A7%A3/","excerpt":"1. Buffernio对于原生数据类型的支持(除去boolean) 如 IntBuffer、ByteBuffer","text":"1. Buffernio对于原生数据类型的支持(除去boolean) 如 IntBuffer、ByteBuffer 2. buffer重要概念buffer中有一个概念是关于 position、limit 、capacity 的 在一个buffer被初始化的时候，比如 intBuffer.allocate(6)，我们给当前buffer分配控件为6 这个时候，position 指向 0 ，limit = capacity 指向当前容量的下一个地址 即 7 如下图： 这时候我们向buffer中写入3个控件的数据，position 指向4（下一个将要下入的空间），limit = capacity 指向当前容量的下一个地址 为 7 此时调用buffer.flip 进行翻转 准备输出。 position指向0， limit指向4，capacity指向7 buffer.clear 置为初始状态 3. sliceBuffer通过 buffer.slice获取一个新的buffer，新buffer以 buffer的position为开始，以buffer的limit为结束返回。 新buffer的position，limit，capacity 独立，但是对于新buffer的修改会反映到原有的buffer中 4. 只读buffer通过buffer.asReadOnlyBuffer()获取. 如果尝试向只读buffer写入数据会抛出异常ReadOnlyException，原有buffer的数据变化对于只读buffer是可见的 5. directBuffer 直接缓冲通过byteBuffer.allocateDirect()获取. 堆外内存，0 拷贝，直接在native创建内存区域同io设备打交道 6. buffer的scattering和gatheringScaterring 撒开,分散,将来自于一个Channel的数据分散到多个Buffer当中,一个满了就用下一个,可以实现数据的分门别类. 这样就省去了解析的时间,比如一个消息有三个部分,第一部分是头信息,第二部分是协议信息,第三部分是消息体. 可以吧这三个消息分别放到不同的Ｂuffer当中， Gatering 把多个汇总成一个,将要写到Channel的数据,","categories":[{"name":"Nio","slug":"Nio","permalink":"http://wanke.fun/categories/Nio/"}],"tags":[]},{"title":"nio学习","slug":"nio学习","date":"2019-08-12T06:31:56.000Z","updated":"2024-03-12T01:06:15.827Z","comments":true,"path":"uncategorized/nio学习/","link":"","permalink":"http://wanke.fun/uncategorized/nio%E5%AD%A6%E4%B9%A0/","excerpt":"1. IO与NIO","text":"1. IO与NIO 在io中核心概念是流，要么是输入要么是输出，不能同时输入输出 在NIO中拥有三个核心概念： 1. selector 选择器 2. channel 通道 3. buffer 缓冲区 NIO 是面向块(block)或者缓冲区(buffer)编程的, buffer 本身是一块内存，底层实现是一块数组， 底层 读写 是通过buffer实现的 java中的原生类型都有对应的buffer 如 intBuffer channel是指可以从中读取或者写入数据的对象，所有数据的读写都是通过 buffer来进行的， channel是双向的，拥有读写的双向功能 。 2. nio示例一1234567891011121314FileInputStream fisl = new FileInputStream(&quot;niotest.txt&quot;); FileChannel channel = fisl.getChannel(); ByteBuffer buffer = ByteBuffer.allocate(512); channel.read(buffer); buffer.flip(); while (buffer.hasRemaining()) &#123; System.out.print((char) buffer.get()); &#125; 3. nio 示例二1234567891011121314151617public static void main(String[] args) throws Exception &#123; FileOutputStream fos = new FileOutputStream(&quot;niotext.txt&quot;); FileChannel channel = fos.getChannel(); ByteBuffer buffer = ByteBuffer.allocate(512); buffer.put(&quot;hello nio test &quot;.getBytes()); buffer.flip(); channel.write(buffer); fos.close(); &#125; 总结： 以上两个例子，我们对文件的操作都是通过channel和buffer来实现的 读文件: 首先通过channel把的文件内容写到buffer，然后通过buffer获取 写文件： 首先把内容写到buffer，然后通过channel写入文件","categories":[],"tags":[]},{"title":"装饰模式使用","slug":"装饰模式使用","date":"2019-08-12T05:52:30.000Z","updated":"2024-03-12T01:06:15.829Z","comments":true,"path":"设计模式/装饰模式使用/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8/","excerpt":"1. 装饰模式的概念","text":"1. 装饰模式的概念 装饰模式： 在不改变接口的前提下，动态扩展对象的访问。 动态继承，让类具有在运行期改变行为的能力。 装饰模式，突出的是运行期增加行为，这和继承是不同的， 继承是在编译期增加行为。 强调：增强，新增行为 策略模式有如下的角色: 顶层构件接口： 规范了接口的动作行为 抽象构件类 ： 实现顶层构件并维护一个构件对象，将行为做分发 核心构件类 ： 脱离于抽象构件的核心独立存在 2. 代码实现顶层构件接口： 12345public interface Milk &#123; int getPrice(); String getName(); &#125; 抽象构件类： 123456789101112131415161718192021222324/** * 抽象构件角色，继承 milk * 并内部维护一个 compoment 对象，负责做接口请求的转发 */public abstract class MilkDecorator implements Milk &#123; protected Milk compoment; public MilkDecorator(Milk compoment) &#123; this.compoment = compoment; &#125; @Override public int getPrice() &#123; return compoment.getPrice(); &#125; @Override public String getName() &#123; return compoment.getName(); &#125;&#125; 核心构件： 12345678910111213141516/** * 核心构件 */public class PureMilk implements Milk &#123; @Override public int getPrice() &#123; return 5; &#125; @Override public String getName() &#123; return &quot;纯牛奶&quot;; &#125;&#125; 构件： 123456789101112131415161718192021222324252627282930313233343536373839public class AppleMilk extends MilkDecorator &#123; public AppleMilk(Milk compoment) &#123; super(compoment); &#125; @Override public int getPrice() &#123; return super.getPrice() + 5; &#125; @Override public String getName() &#123; return super.getName() + &quot; 加苹果 &quot;; &#125;&#125;public class PeachMilk extends MilkDecorator &#123; public PeachMilk(Milk compoment) &#123; super(compoment); &#125; @Override public int getPrice() &#123; return super.getPrice() + 10; &#125; @Override public String getName() &#123; return super.getName() + &quot; 黄桃 &quot;; &#125;&#125; 12345678910111213141516171819202122public static void main(String[] args) &#123; //核心构件 Milk milk = new PureMilk(); Milk packageA = new AppleMilk(milk); Milk iceMilkA = new IceMilk(packageA); System.out.println(iceMilkA.getPrice() + &quot; , &quot; + iceMilkA.getName()); Milk packageB = new PeachMilk(iceMilkA); System.out.println(packageB.getPrice() + &quot; , &quot; + packageB.getName()); &#125; 执行结果： 10 , 纯牛奶 加苹果 加冰 20 , 纯牛奶 加苹果 加冰 黄桃 3. 优缺点分析优点： 1. 装饰模式可以提供比继承更多地灵活性。 2. 可以通过一种动态的方式来扩展一个对象的功能， 在运行时选择不同的装饰器，从而实现不同的行为。 缺点： 1. 会产生很多的小对象（具体装饰类），增加了系统的复杂性。 2. 装饰模式比继承易于出错，排错也很困难，对于多次装饰的对象， 调试时寻找错误可能需要逐级排查，较为烦琐。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"策略模式使用","slug":"策略模式使用","date":"2019-08-11T09:20:54.000Z","updated":"2024-03-12T01:06:15.829Z","comments":true,"path":"设计模式/策略模式使用/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8/","excerpt":"1. 是什么在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。 1. 抽象策略角色 - 接口或者抽象类 2. 具体策略角色 3. 环境角色 - 持有策略类的引用，最终给客户端调用","text":"1. 是什么在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。 1. 抽象策略角色 - 接口或者抽象类 2. 具体策略角色 3. 环境角色 - 持有策略类的引用，最终给客户端调用 2. 代码编写抽象策略角色 123public interface Cal &#123; int calate(int a,int b);&#125; 具体策略角色 12345678910111213public class AddCal implements Cal &#123; @Override public int calate(int a, int b) &#123; return a + b; &#125;&#125;public class SubCal implements Cal &#123; @Override public int calate(int a, int b) &#123; return a - b; &#125;&#125; 环境类 1234567891011121314151617181920public class Environment &#123; Cal cal = null; public Environment(Cal cal) &#123; this.cal = cal; &#125; public int invokeCal(int a , int b) &#123; return cal.calate(a,b); &#125; public void setCal(Cal cal) &#123; this.cal = cal; &#125;&#125; 测试代码： 12345678910111213141516171819202122232425public class StrategyTest &#123; public static void main(String[] args) &#123; AddCal cal = new AddCal(); Environment environment = new Environment(cal); environment.setCal(cal); int i = environment.invokeCal(1, 2); System.out.println(i); environment.setCal(new SubCal()); System.out.println(environment.invokeCal(1,2)); &#125;&#125; 输出： 3 -1 3. 优缺点优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。 缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。3. 客户端必须要知道所有的实现类 注意事项： 如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[]},{"title":"netty学习","slug":"netty学习","date":"2019-08-09T02:06:16.000Z","updated":"2024-03-12T01:06:15.827Z","comments":true,"path":"Nio/netty学习/","link":"","permalink":"http://wanke.fun/Nio/netty%E5%AD%A6%E4%B9%A0/","excerpt":"1. Netty 能做什么1. http服务器 类 Tomcat ，但是没有实现web规范 2. socket 开发 rpc通信 3. 长链接的开发","text":"1. Netty 能做什么1. http服务器 类 Tomcat ，但是没有实现web规范 2. socket 开发 rpc通信 3. 长链接的开发 2. netty的http程序示例12345678910111213141516171819202122232425262728293031323334public class TestServer &#123; public static void main(String[] args) throws Exception&#123; //工作线程 EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; //服务启动器 ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(bossGroup,workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new TestServerInitializer()); //绑定端口 ChannelFuture sync = bootstrap.bind(8899).sync(); sync.channel().closeFuture().sync(); &#125; finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 123456789101112131415161718192021public class TestServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; //管道可以拥有很多个handler，类似于拦截器 ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(&quot;httpServerCodec&quot;,new HttpServerCodec()); //自定义处理器 pipeline.addLast(&quot;testHttpServerHandler&quot;,new TestHttpServerHandler()); &#125;&#125; 1234567891011121314151617181920212223242526272829public class TestHttpServerHandler extends SimpleChannelInboundHandler&lt;HttpObject&gt; &#123; //类似于 msgReceived 方法 , //接收消息，返回响应 @Override protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception &#123; if (msg instanceof HttpRequest) &#123; //构造一个响应内容 ByteBuf content = Unpooled.copiedBuffer(&quot;hello&quot;, CharsetUtil.UTF_8); //构造响应体 FullHttpResponse response = new DefaultFullHttpResponse( HttpVersion.HTTP_1_1, HttpResponseStatus.OK,content ); response.headers().add(HttpHeaderNames.CONTENT_TYPE,&quot;text/plain&quot;); response.headers().add(HttpHeaderNames.CONTENT_LENGTH,content.readableBytes()); //回写response ctx.writeAndFlush(response); &#125; &#125;&#125; 使用： 浏览器 localhost：8899 curl localhost：8899 3. netty实现socket编程示例3.1 SocketServer的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class TestSocketServer &#123; public static void main(String[] args) throws Exception &#123; NioEventLoopGroup bossGroup = new NioEventLoopGroup(); NioEventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(bossGroup,workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new TestSocketServerInitializer()); ChannelFuture sync = bootstrap.bind(8899).sync(); sync.channel().closeFuture().sync(); &#125; finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125;public class TestSocketServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(new LengthFieldBasedFrameDecoder( Integer.MAX_VALUE,0,4,0,4)); pipeline.addLast(new LengthFieldPrepender(4)); pipeline.addLast(new StringEncoder(CharsetUtil.UTF_8)); pipeline.addLast(new StringDecoder(CharsetUtil.UTF_8)); pipeline.addLast(new TestSocketServerHandler()); &#125;&#125;@Override protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception &#123; SocketAddress socketAddress = ctx.channel().remoteAddress(); System.out.println(socketAddress + &quot; : &quot; + msg ); ctx.writeAndFlush(&quot;write from server : &quot; + UUID.randomUUID()); &#125; 3.2 SocketClient的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class MySocketClient &#123; public static void main(String[] args) throws Exception &#123; NioEventLoopGroup loop = new NioEventLoopGroup(); try &#123; Bootstrap bootstrap = new Bootstrap(); bootstrap.group(loop) .channel(NioSocketChannel.class) .handler(new MySocketClientInitializer()); ChannelFuture future = bootstrap.connect(&quot;localhost&quot;, 8899).sync(); future.channel().closeFuture().sync(); &#125; finally &#123; loop.shutdownGracefully(); &#125; &#125;&#125;public class MySocketClientInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(new LengthFieldBasedFrameDecoder( Integer.MAX_VALUE,0,4,0,4)); pipeline.addLast(new LengthFieldPrepender(4)); pipeline.addLast(new StringEncoder(CharsetUtil.UTF_8)); pipeline.addLast(new StringDecoder(CharsetUtil.UTF_8)); pipeline.addLast(new MySocketClientHandler()); &#125;&#125;class MySocketClientHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123; @Override protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception &#123; System.out.println(ctx.channel().remoteAddress() + &quot; : &quot; + msg); ctx.writeAndFlush(&quot;from client : &quot; + LocalDateTime.now()); &#125; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; super.channelActive(ctx); ctx.writeAndFlush(&quot;sss&quot;); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;// super.exceptionCaught(ctx, cause); cause.printStackTrace(); ctx.close(); &#125;&#125; 分别启动服务端和客户端就可以在命令行看到输出 4. netty编程流程总结在Netty中，几乎所有的代码编写流程都遵循以下流程 服务端： 1. 构建 ServerBootstrap 创建工作线程 NioEventLoopGroup 指定channel NioServerSocketChannel 指定handler 2. 构建ChannelInitializer 获取ChannelPipeline 添加netty处理器 添加自定义处理器 3. 编写自定义处理器 继承SimpleChannelInboundHandler 接收参数 然后通过ChannelHandlerContext写会数据 socket客户端： 1. 构建 Bootstrap 创建工作线程 NioEventLoopGroup 指定channel NioSocketChannel 指定handler 2. 构建ChannelInitializer 获取ChannelPipeline 添加netty处理器 添加自定义处理器 3. 编写自定义处理器 继承SimpleChannelInboundHandler 接收参数 然后通过ChannelHandlerContext写会数据","categories":[{"name":"Nio","slug":"Nio","permalink":"http://wanke.fun/categories/Nio/"}],"tags":[]},{"title":"Java8-lambda表达式","slug":"Java8-lambda表达式","date":"2019-08-01T08:22:38.000Z","updated":"2024-03-12T01:06:15.825Z","comments":true,"path":"Java/Java8-lambda表达式/","link":"","permalink":"http://wanke.fun/Java/Java8-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"1. lambda表达式","text":"1. lambda表达式 1. 如果一个接口只有一个抽象方法，那么它是lambda表达式 2. 声明了 @FunctionalInterface 注解的接口 3. 只有一个抽象接口，并没有@FunctionalInterface注解 2. lambda 表达式的基本形式(type1:param1,type2:param2) -&gt; &#123;body&#125; (param1,param2) -&gt; &#123;body&#125; () -&gt; &#123;body&#125; param -&gt; &#123;body&#125; 箭头函数左边为我们的参数，右边为体。如果右边为表达式的话 那么我们可以将&#123;&#125;省略 3. Function 接口单个的入参和出参 方法： 1. R apply(T var1); 默认方法，apply会将var作为参数调用我们传递的行为 2. default &lt;V&gt; Function&lt;T, V&gt; andThen 3. default &lt;V&gt; Function&lt;V, R&gt; compose 以上两个方法是可以将任意的2个function接口函数组合 到一起使用，理论上可以无限延伸 compose是先执行参数function的apply再执行自身 andThen相反 4. BiFunction 接口接收2个入参有一个出参 1. R apply(T var1, U var2); 2. default &lt;V&gt; BiFunction&lt;T, U, V&gt; andThen(Function&lt;? super R, ? extends V&gt; var1) BiFunction只有andThen 并接收一个 function作为参数 5. Predicate 接口判定类型接口方法 1. boolean test(T var1); 2. default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; var1) 逻辑与 3. default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; var1) 逻辑或 4. default Predicate&lt;T&gt; negate() 取反 5. static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object var0) 6. 示例代码12345678910111213141516171819202122232425262728293031public static void main(String[] args) &#123; Test1 test1 = new Test1(); int computer = test1.computer(10, param -&gt; param * param); System.out.println(computer); int i = test1.computer2(1, 2, (a, b) -&gt; a + b); System.out.println(i); boolean b = test1.computer3(1, (a) -&gt; a &gt; 10); System.out.println(b); &#125; public int computer(int a,Function&lt;Integer,Integer&gt; function) &#123; return function.apply(a); &#125; public int computer2(int a,int b,BiFunction&lt;Integer,Integer,Integer&gt; function) &#123; return function.apply(a,b); &#125; public boolean computer3(int a, Predicate&lt;Integer&gt; predicate) &#123; return predicate.test(1); &#125; 7. Supplier 接口 不接收参数同事返回一个结果 1. T get(); 8. Optional 概念用来解决NPE问题 Optional&lt;String&gt; s = Optional.of(&quot;hello &quot;); s.ifPresent(item -&gt; System.out.println(item)); 9. 方法引用我们可以将方法引用看做一个 函数指针 方法引用分为四类 1. 连续两个冒号，类名::静态方法名 2. 对象名::实例方法名 3. 类名::实例方法名 List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5); list.forEach(System.out::println);","categories":[{"name":"Java","slug":"Java","permalink":"http://wanke.fun/categories/Java/"}],"tags":[]},{"title":"java内存模型理解","slug":"2019-07-30-java内存模型理解","date":"2019-07-30T08:04:43.000Z","updated":"2024-03-12T01:06:15.823Z","comments":true,"path":"Jvm/2019-07-30-java内存模型理解/","link":"","permalink":"http://wanke.fun/Jvm/2019-07-30-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3/","excerpt":"1. jvm虚拟机运行区域","text":"1. jvm虚拟机运行区域 1. 堆 2. 栈(线程)线程在运行的过程中， 3. 本地方法栈4. 方法区(元空间)-直接内存5. 程序计数器线程独享的一块内存空间，可以看做当前线程所执行字节码的行号指示器 如果是java代码，计数器指向的是虚拟机字节码指令地址，如果是native代码， ，指示器的值为undefined 此区域是jvm规范中唯一没有规定OOM情况的区域","categories":[{"name":"Jvm","slug":"Jvm","permalink":"http://wanke.fun/categories/Jvm/"}],"tags":[]},{"title":"jvm_字节码看动态代理","slug":"jvm-字节码看动态代理","date":"2019-07-26T01:26:32.000Z","updated":"2024-03-12T01:06:15.826Z","comments":true,"path":"Jvm/jvm-字节码看动态代理/","link":"","permalink":"http://wanke.fun/Jvm/jvm-%E5%AD%97%E8%8A%82%E7%A0%81%E7%9C%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"1. jdk 动态代理基本使用","text":"1. jdk 动态代理基本使用 123public interface Subscribe &#123; void subscrib();&#125; 123456 public class SubImpl implements Subscribe &#123; @Override public void subscrib() &#123; System.out.println(&quot;subscribe invoked &quot;); &#125;&#125; 1234567891011121314151617181920212223242526 public class SubHandler implements InvocationHandler &#123; private Object realObj; public SubHandler(Object realObj) &#123; this.realObj = realObj; &#125; @Override public Object invoke(Object o, Method method, Object[] objects) throws Throwable &#123; if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(o,objects); &#125; System.out.println(&quot;before invoked &quot;); Object invoke = method.invoke(realObj, objects); System.out.println(&quot;after invoked &quot;); return invoke; &#125;&#125; 测试代码 1234567891011121314151617 public class MyClass &#123; public static void main(String[] args) &#123; System.setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;,&quot;true&quot;); Subscribe subscribe = new SubImpl(); Subscribe proxy = (Subscribe) Proxy.newProxyInstance(subscribe.getClass().getClassLoader(), subscribe.getClass().getInterfaces(), new SubHandler(subscribe)); proxy.subscrib(); &#125;&#125; 以上代码是对于jdk动态代理的基本使用。值得注意的是，jdk的动态代理类， 必须是有接口的。 执行结果如下： before invoked subscribe invoked after invoked 2. 源码分析12Subscribe proxy = (Subscribe) Proxy.newProxyInstance(subscribe.getClass().getClassLoader(), subscribe.getClass().getInterfaces(), new SubHandler(subscribe)); 通过对于proxy类进行打印发现，他的父类其实是 java.lang.reflect.Proxy 下面我们具体分析，我们的 proxy对象是怎么生成的 1. 首先进入Proxy.newProxyInstance静态方法.鉴于代码篇幅较长，做了一部分删减。 123456789101112131415161718192021public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; ...... /* * Look up or generate the designated proxy class. */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); ....... return cons.newInstance(new Object[]&#123;h&#125;); &#125; 通过以上代码，我们发现关键点 在这里主要做了三件事 1. 通过 getProxyClass0 方法获取 Class对象 2. 调用默认构造方法 conns 3. 通过构造方法生成我们需要的返回对象 这里我们再次进入getProxyClass0 看如何生成 class对象的。 跟进代码进入到 ProxyClassFactory.apply 方法 1234567891011byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try &#123; return defineClass0(loader, proxyName, proxyClassFile, 0,proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; &#125; 首先通过 ProxyGenerator.generateProxyClass生成字节码的数组，然后通过 defineClass0 生成class对象。 defineClass0是native方法。 到目前为止，我们就完成了整个流程的分析。 3. 我们通过Proxy.newProxyInstance类内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 public final class $Proxy0 extends Proxy implements Subscribe &#123; private static Method m1; private static Method m2; private static Method m3; private static Method m0; public $Proxy0(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final void subscrib() throws &#123; try &#123; super.h.invoke(this, m3, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int hashCode() throws &#123; try &#123; return (Integer)super.h.invoke(this, m0, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;)); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;); m3 = Class.forName(&quot;com.example.lib.Subscribe&quot;).getMethod(&quot;subscrib&quot;); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 以上是我们通过动态代理生成的类，继承了 Proxy，实现我们的Subscribe接口 默认实现了object中的 equals，toString，hashCode方法 以及Subscribe接口中的方法 以上方法提的人内容大同小异，通过静态代码块实例化的method，最后调用我们的 handler的invoke方法","categories":[{"name":"Jvm","slug":"Jvm","permalink":"http://wanke.fun/categories/Jvm/"}],"tags":[]},{"title":"jvm_字节码的基本信息","slug":"jvm-字节码的基本信息","date":"2019-07-25T06:44:19.000Z","updated":"2024-03-12T01:06:15.826Z","comments":true,"path":"Jvm/jvm-字节码的基本信息/","link":"","permalink":"http://wanke.fun/Jvm/jvm-%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF/","excerpt":"字节码文件基本组成部分解析 。字节码文件中的十六进制数据中 每两个文字符号为一个字节。","text":"字节码文件基本组成部分解析 。字节码文件中的十六进制数据中 每两个文字符号为一个字节。 1. 魔数在字节码文件中，魔数占据了4个字节 在我们以上的字节码数据中，从0开始数4个字节就是我们的魔数， java语言中，魔数固定为 【 CAFEBABE 】 2. 版本号魔数后的4个字节为版本号，主次版本号分别占据2个字节 ， 十六进制数据 ： 00000033 -&gt; jdk版本为 51 3. 常量池版本号后面 2个字节为常量池大小的定义： 0019 -&gt; 25 可以看到常量池的大小为24 (25-1) 索引0 为保留常量 null，不位于常量表中 3.1 常量池表分析根据下面的常量池表进行分析： 我们得到常量池分析的结束位置： 4. AccessFlag访问标志常量池结束 accessflag占据2个字节 ： 0021 这个表里面无法直接查询到0021这个值，原因是0021=0020+0001，也就是表示当前class的access_flag是ACC_PUBLIC|ACC_SUPER 参考下表： 5. ClassName 类名访问标识后面2个字节： 0003 说明类名在常量池表中的索引为 3 6. SuperClassName 父类名类名后占据2个字节： 0004 ，在常量池的索引为4 7. 接口 interface名父类后占据2个字节： 0000 因为我们的类，没有实现接口所以为0 8. fields占据2个字节： 0001 数量为1 8.1 字段表结构每个成员变量对应一个field_info结构： field_info &#123; u2 access_flags; 0002 u2 name_index; 0005 u2 descriptor_index; 0006 u2 attributes_count; 0000 attribute_info attributes[attributes_count]; &#125; access_flags为0002，即是ACC_PRIVATE name_index指向常量池的第五个常量，为“test” descriptor_index指向常量池的第6个常量为“I” 三个字段结合起来，说明这个变量是&quot;private int test&quot;。 接下来的是attribute字段，用来描述该变量的属性，因为这个变量没有附加属性，所以attributes_count为 0，attribute_info为空。 9. methods占据2个字节： 0004 9.1 方法表结构method_info &#123; u2 access_flags; u2 name_index; u2 descriptor_index; u2 attributes_count; attribute_info attributes[attributes_count]; &#125; 9.2 0009 code 结构表Code_attribute &#123; u2 attribute_name_index; u4 attribute_length; u2 max_stack; u2 max_locals; u4 code_length; u1 code[code_length]; u2 exception_table_length; &#123; u2 start_pc; u2 end_pc; u2 handler_pc; u2 catch_type; &#125; exception_table[exception_table_length]; u2 attributes_count; attribute_info attributes[attributes_count]; &#125; attribute_length表示attribute所包含的字节数，这里为0000001d，即是39个字节，不包含 attribute_name_index和attribute_length字段。 max_stack表示这个方法运行的任何时刻所能达到的操作数栈的最大深度，这里是0001 max_locals表示方法执行期间创建的局部变量的数目，包含用来表示传入的参数的局部变量，这里是0001. 接下来的code_length表示该方法的所包含的字节码的字节数以及具体的指令码。 这里的字节码长度为00000005，即是后面的5个字节 2a b7 00 01 b1为对应的字节码指令的指令码。 参照下表可以将上面的指令码翻译成对应的助记符： 9.3 属性表结构attribute_info &#123; u2 attribute_name_index; u4 attribute_length; u1 info[attribute_length]; &#125;","categories":[{"name":"Jvm","slug":"Jvm","permalink":"http://wanke.fun/categories/Jvm/"}],"tags":[]},{"title":"jvm_字节码_概述","slug":"jvm-字节码-概述","date":"2019-07-25T05:43:32.000Z","updated":"2024-03-12T01:06:15.826Z","comments":true,"path":"Jvm/jvm-字节码-概述/","link":"","permalink":"http://wanke.fun/Jvm/jvm-%E5%AD%97%E8%8A%82%E7%A0%81-%E6%A6%82%E8%BF%B0/","excerpt":"Java字节码是java源文件编译只有的产物，供jvm加载执行的十六进制数据。","text":"Java字节码是java源文件编译只有的产物，供jvm加载执行的十六进制数据。 在字节码文件中，每2个字符作为一个字节。 jvm字节码描述了java编译以后的产物。主要由以下几部分组成： 1. 魔数，作为class文件的标识 2. 主次版本号 3. 常量池 4. accessFlag 访问标志 5. 类名 6. 父类名 7. 接口数量 8. field数，field表 9. 方法数，方法表 10. attribute数 attribute表 ...... 以上各数据组合成一个完整的字节码文件，包括了我们在java类中标书的一切信息， 只不过是以字节码形式存在的，主要供机器读取，而不是正常人。 java 创新性的提出字节码的概念，这是java语言可以跨平台的重要存在。 java 和 jvm虚拟机java语言规范和jvm虚拟机规范是分开的。java语言只不过是jvm规范中一个最重要的分支。 原则上只要是符合规范的字节码文件，jvm都可以执行。jvm并不关心class文件的来源。 以及class文件是由于哪些语言编译的产物。 事实上，jython，jruby groovy 等都是运行在jvm之上的语言。 在以后的文章中会针对一个简单类的字节码进行反编译，来深入进行字节码学习。 示例代码： 123456789101112131415 public class MyClass &#123; private static int a = 1; public int getA() &#123; return this.a; &#125; public void setA(int a) &#123; this.a = a; &#125;&#125; 对以上源文件生成的字节码进行反编译，得到结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495 Last modified Jul 25, 2019; size 524 bytes MD5 checksum e846819608e7bc904c06a8545263fac1 Compiled from &quot;MyClass.java&quot;public class com.example.lib.MyClass minor version: 0 major version: 51 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #4.#21 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #3.#22 // com/example/lib/MyClass.a:I #3 = Class #23 // com/example/lib/MyClass #4 = Class #24 // java/lang/Object #5 = Utf8 a #6 = Utf8 I #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Lcom/example/lib/MyClass; #14 = Utf8 getA #15 = Utf8 ()I #16 = Utf8 setA #17 = Utf8 (I)V #18 = Utf8 &lt;clinit&gt; #19 = Utf8 SourceFile #20 = Utf8 MyClass.java #21 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V #22 = NameAndType #5:#6 // a:I #23 = Utf8 com/example/lib/MyClass #24 = Utf8 java/lang/Object&#123; public com.example.lib.MyClass(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 3: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/example/lib/MyClass; public int getA(); descriptor: ()I flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: pop 2: getstatic #2 // Field a:I 5: ireturn LineNumberTable: line 8: 0 LocalVariableTable: Start Length Slot Name Signature 0 6 0 this Lcom/example/lib/MyClass; public void setA(int); descriptor: (I)V flags: ACC_PUBLIC Code: stack=1, locals=2, args_size=2 0: aload_0 1: pop 2: iload_1 3: putstatic #2 // Field a:I 6: return LineNumberTable: line 12: 0 line 13: 6 LocalVariableTable: Start Length Slot Name Signature 0 7 0 this Lcom/example/lib/MyClass; 0 7 1 a I static &#123;&#125;; descriptor: ()V flags: ACC_STATIC Code: stack=1, locals=0, args_size=0 0: iconst_1 1: putstatic #2 // Field a:I 4: return LineNumberTable: line 5: 0&#125;SourceFile: &quot;MyClass.java&quot; 我们用工具打开字节码文件，可以看到以下16进制的数据 在后续章节将会对字节码文件进行一个详细的阐述和分析","categories":[{"name":"Jvm","slug":"Jvm","permalink":"http://wanke.fun/categories/Jvm/"}],"tags":[]},{"title":"jvm_类文件结构","slug":"jvm01-类文件结构","date":"2019-07-23T06:25:21.000Z","updated":"2024-03-12T01:06:15.826Z","comments":true,"path":"Jvm/jvm01-类文件结构/","link":"","permalink":"http://wanke.fun/Jvm/jvm01-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/","excerpt":"计算机是只能识别0和1的，Java的设计者创新性的提出了跨平台的概念， 把Java编译成字节码文件，运行在 jvm虚拟机中，从而可以达到跨平台的概念。 Java只不过是jvm支持的众多语言中的最广泛的一种 ，Java和jvm虚拟机并不是绑定在一起的。 实际上，不论哪种语言，只要他的最终产物编译成字节码，都是可以运行在jvm之上的，例如 groovy，scala，jython 等","text":"计算机是只能识别0和1的，Java的设计者创新性的提出了跨平台的概念， 把Java编译成字节码文件，运行在 jvm虚拟机中，从而可以达到跨平台的概念。 Java只不过是jvm支持的众多语言中的最广泛的一种 ，Java和jvm虚拟机并不是绑定在一起的。 实际上，不论哪种语言，只要他的最终产物编译成字节码，都是可以运行在jvm之上的，例如 groovy，scala，jython 等 字节码查看工具： jclasslib https://github.com/ingokegel/jclasslib 1. 反编译命令行工具： 1. javap -verbose 分析 魔数，版本号，常量池，类信息，构造方法，成员方法，变量 2. javap -c xxx 3. 十六进制查看 mac ：hex_fiend 。 win ：winhex 1. 魔数字节数： U4 Java采用魔数来识别字节码文件而不是后缀，从而规避安全性风险。 1. class文件的头四个字节是魔数 CA FE BA BE 2. 版本号字节数： U4 挨着四个字节代表版本号 其中前2字节代表次版本号 minor version， 后2字节代表主版本号 major version 3. 常量池 constant pool常量池个数的字节数： U2 + N 1. 主版本号之后的是常量池入口，一个Java类中定义的很多信息都是由常量池来维护的， 我们可以将常量池看做class文件的资源库，比如 方法变量信息， 2. 常量池主要存储2中数据， 字面量和符号引用 字面量： 文本字符串，比如final常量值 符号引用：类和接口的全局限定名，字段以及方法的名称和描述符 3. 常量池的总体结构：Java类所对应的常量池主要由常量池数量和常量池数组构成 3. 常量池数量和常量池数组1. 常量池数量紧跟主版本后，占用2个字节。 2. 常量池数组紧跟常量池数量，与一般数组不同的是，它的元素类型，结构都是不相同 的。 每一种元素的第一个数据都是一个u1类型，该字节是一个标志位，占1个字节， jvm在解析常量池时，会根据这个u1类型获取元素具体类型， 常量池数组中元素的个数等于 常量池数-1(其中0暂时不使用),目的是满足某些 常量池索引值的数据在特定情况下表达 不引用任何常量池的含义。 根本原因是所以0也是一个常量(保留常量)，不过它不位于长量表中，对应null值， 常量池索引从1开始 常量池对照表 字节码整体结构 在jvm规范中，每个变量/字段都有描述信息，描述信息的主要作用就是描述 字段的数据类型，方法的参数列表(数量，类型，顺序)与返回值 基本数据类型和代表返回值void的类型都用一个大写字符标识，对象类型使用L加上 对象的全限定名称来标识，为了压缩字节码体积 基本数据类型都是用一个大写字符标识： B - byte。C - chart。D - double。 I - int 。J - long。F - float。 z - boolean。V - void。S - short。 L - 对象类型,如 Ljava/lang/String 对于数组： 使用 前置的方括号[ 。如 int ，记录为 [I 二维数组： 使用前置的[[ 记录，比如 [[I 方法的描述符 先参数列表后返回值类型，参数列表按照严格顺序放在一组()内 比如： 方法 String getName(int id,string name) (I,Ljava/lang/String;)Ljava/lang/String; 4. accessFlag 访问标志字节数： U2 示例 ： 0x0021 是 acce_public 和 acc_super的并集 5. this class Name字节数： u2 6. super class name字节数： u2 7. interfaces字节数： u2 + N 8. fields字节数： u2 + N 字段表 ： 用于描述类和接口中声明的变量。包括类变量和实例变量，但是不包括方法内局部变量 变量由以下几部分信息组成fieldInfo 1. 访问修饰符 U2 2. 名字索引 U2 3. 描述符索引 U2 (类型) 4. attribute count 5. attribute info 9. methods字节数： U2 + N 方法数量： U2 默认会有一个无参数的构造方法，所以方法+1 方法表 ： 1. 访问修饰符 U2 2. 名字索引 U2 3. 描述符索引 U2 (类型) 4. attribute count 5. attribute info 方法属性结构表： 1. 名字索引 U2 2. 属性长度 U4 3. 具体信息 U1 code 结构表： stack 方法执行的最大栈的深度 local 方法运行期间创建的局部变量的数目，包括入参的局部变量 args_size 至少为1，因为this是隐式传递的 助记符 10. attributes字节数： U2 + N","categories":[{"name":"Jvm","slug":"Jvm","permalink":"http://wanke.fun/categories/Jvm/"}],"tags":[]},{"title":"jvm 系列笔记 - 类加载器","slug":"jvm-系列笔记","date":"2019-07-19T06:33:44.000Z","updated":"2024-03-12T01:06:15.826Z","comments":true,"path":"Jvm/jvm-系列笔记/","link":"","permalink":"http://wanke.fun/Jvm/jvm-%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/","excerpt":"1. Java进程监控工具jconsole ，jvisualvm 利用以上2个工具可以进行堆栈，线程等信息的查看","text":"1. Java进程监控工具jconsole ，jvisualvm 利用以上2个工具可以进行堆栈，线程等信息的查看 2. Java类加载器生命周期正常结束，异常结束，执行 system.exit方式终止 3. 类的加载器深入解析加载： 查找并加载类的二进制数据 连接： - 验证： 确保被加载类的正确 - 准备： 为类的【静态变量】分配内存，并初始化为默认值 - 解析： 符号引用转换化为直接引用 初始化：为类的静态变量初始化为正确的值 使用： 主动使用、被动使用 卸载： ****** 所有的Java虚拟机实现，必须在每个类或者接口被Java程序【首次主动使用】的时候才会初始化他们 4. 主动使用的情况1. 创建类实例 ig：new object（） 2. 访问某类或者接口的静态变量 取值赋值操作 3. 调用类的静态方法 4. 反射 5. 初始化子类 5. 子类和父类的加载优先级关系一12345678910111213141516171819 public class Parent &#123; static &#123; System.out.println(&quot;i am parent static block &quot;); &#125; public Parent() &#123; System.out.println(&quot;i am parent constructor &quot;); &#125; &#123; System.out.println(&quot;i am parent normal block &quot;); &#125; public static void test() &#123; System.out.println(&quot;i am parent&quot;); &#125; &#125; i am parent static block i am parent normal block i am parent constructor 结论： 先初始化代码块，然后调用构造函数，其中静态代码块优先级要高于普通代码块 5. 子类和父类的加载优先级关系二1234567891011121314151617 public class Son extends Parent &#123; static &#123; System.out.println(&quot;i am Son static block &quot;); &#125; public Son() &#123; System.out.println(&quot;i am Son constructor &quot;); &#125; &#123; System.out.println(&quot;i am Son normal block &quot;); &#125; &#125; i am parent static block i am Son static block i am parent normal block i am parent constructor i am Son normal block i am Son constructor 结论： 1. 静态代码块高于一切优先级最高 2. 其次为父类的普通代码块和构造函数 3. 父类的构造函数优先于子类的普通代码块 6. 类加载概述类的加载是指将类的二进制数据读入内存，放在运行时方法区，然后创建一个Class对象，用来封装类在方法去的数据结构 加载class文件的方式 1. 本地加载 2. 网络下载 3. 加载jar，zip等归档文件中的class文件 4. 数据库提取 5. Java源文件动态编译为class文件 7. 主动使用和被动使用1. 对于调用静态字段，只有直接定义了该字段的类才会被初始化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 public class Parent &#123; &#123; System.out.println(&quot;i am parent normal block &quot;); &#125; static &#123; System.out.println(&quot;i am parent static block &quot;); &#125; public Parent() &#123; System.out.println(&quot;i am parent constructor &quot;); &#125; public static String str = &quot;hello word &quot;; &#125;public class Son extends Parent &#123; static &#123; System.out.println(&quot;i am Son static block &quot;); &#125; public Son() &#123; System.out.println(&quot;i am Son constructor &quot;); &#125; &#123; System.out.println(&quot;i am Son normal block &quot;); &#125; public void test() &#123; System.out.println(&quot;i am son&quot;); &#125; &#125;public static void main(String[] args) &#123; // Parent p = new Parent(); // // // p.test(); String str = Son.str; &#125; 输出结果： i am parent static block 由此可见，只有父类的静态代码块被调用了，这这个例子当中，是对父类的主动引用，虽然调用了son类。 初始化子类，父类也会被初始化 8. 追踪被加载的类信息使用 -XX:+TraceClassLoading 追踪类加载信息并打印 + 表示开启 追踪，可以用 - 减号关闭 -xx:&lt;options&gt;=&lt;value&gt;表示赋值为value 9. 实例11234567891011121314151617 public class Test2 &#123; public static void main(String[] args) &#123; String str = Parent2.str; &#125; static class Parent2 &#123; static &#123; System.out.println(&quot;static block invoked &quot;); &#125; public static final String str = &quot;hello &quot;; &#125;&#125;&#125; str 常量使用final修饰： 静态代码块会调用否则不会 在编译阶段：final修饰的常量，会被放置到调用者类的常量池当中 本质上，调用类并没有直接饮用到定义常量的类，因此不会触发定义常量的类的初始化 10. 双亲委托机制1. 根类加载器 BootClassLoader 2. 扩展类加载器 ExtClassLoader 3. 系统类加载器 AppClassLoader 在双亲委托机制中，各个了类加载器按照父子关系形成树形结构， 除了根类加载器以后，其他类加载器都有且只有一个父亲 11. 继承类的主动使用 结论 通过子类对于父类静态变量和静态函数的调用，并不属于对子类的主动使用， 所以，子类的静态代码块没有执行 看的是定义方，而不是调用方 12. 类的卸载1. 由Java虚拟机自带的类加载器(根类加载器，扩展类加载器，系统来加载器)加载的类， 在jvm生命周期内，始终不会被卸载。 2. 由用户自定义的类加载器加载的类，是可以被卸载的。 13. 追踪被卸载的类信息使用 -XX:+TraceClassUnloading 追踪类加载信息并打印 14. 复杂类的加载对于父加载器加载的类，对于子加载器是可见的，但是 对于子加载器加载的类，对于父加载器是不可见的 15. 命名空间的概念1. 每个类加载器都有一个命名空间， 2. 子加载器包含所有父类的命名空间可以访问父加载器加载的类， 3. 父加载器锁加载的类，无法被子加载器访问 4. 在同一个命名空间内，不会出现同一个类名和包名相同的类 5. 同一个命名空间内，类之间是相互可见的，反之不可见 16. 启动类加载器内建于jvm的启动类加载器会加载ClassLoader以及其他的Java平台类 当jvm启动时，一块特殊的代码块会运行，他会加载扩展类加载器以及系统类加载器， 启动类加载器是c++实现，特定平台的机器指令，负责开启整个加载过程。 启动类加载器负责加载JRE基本组件，java.util java.lang包中的类 17. 线程上下文类加载器破坏双亲委托机制，使得我们可以让某一个加载器去加载类 1. 当前类加载器 (currentClassLoader)： 用于加载当前类的加载器 每个类都会使用自己的类加载器去加载其他类，如果classX引用 了classY,那么classX的类加载器就会去加载classY(如果 classY尚未被加载) 2. 线程上下文类加载器 jdk 1.2 引入的，thread类 getContextClassLoader方法 如果没有通过setContextClassLoader设置，线程将继承 父类的上下文加载器， Java应用运行时的初始线程的上下文加载器是系统类加载器， 在线程中运行的代码可以通过该类加载器来加载类与资源 父classLoader可以使用当前线程 Thread.currentClassLoader().getClassLoader 所指定的 classloader加载的类，这就改变了父classloader不能使用子 classloader或者没有父子关系的classloader加载的类的情况。 例如 jdbc规范的实现 高层提供统一的接口让低层去实现，同时又要在高层使用低层的类 18. jar hell问题解决当某各类存在多个jar包中，我们可以通过以下方式寻找解决 19. 类的加载过程解析1. 加载 2. 连接 - 验证-准备-解析 3. 初始化 4. 使用 5. 卸载 1. 加载在类加载过程中，虚拟机主要完成以下事件 1. 获取二进制流 2. 将二进制流转化为方法区的运行时数据结构 3. 内存中生成代表这个类的Class对象，作为访问各种数据的入口 2. 验证验证主要是为了确保Class文件中的字节流符合虚拟机的要求，不会危及虚拟机安全。 1. 文件格式验证 检查魔数，主此版本号看是否虚拟机可以支持，常量池检查 2. 元数据验证 对语义进行分析，看是否符合Java规范。例如： 继承了final类，抽象类方法未实现 3. 字节码验证 4. 符号引用验证 3. 准备准备阶段会为类的静态变量分配内存并初始化默认的零值 4. 解析符号引用转化为直接引用 5. 初始化为静态变量初始化正确的赋值 3. 类加载器 4. 双亲委托1. 工作过程 如果一个类加载器收到了类加载的请求，它首先会去请求父类加载器去完成， 因此所有的加载请求最终都会传送到顶层的类加载器中。 只有父类加载器反馈自己无法完成类加载请求，子类加载器才会去 尝试加载。 2. 双亲委托的好处 保持层级关系 保证在当前类加载上下文中，类的唯一性 5. 双亲委托模型的破坏1. 双亲委托模型是jdk1.2开始的，so 2. 线程上下文加载器 3. 程序动态性 1. 线程上下文改变了双亲委托模型父classLoader可以使用当前线程 Thread.currentClassLoader().getClassLoader 所指定的 classloader加载的类，这就改变了父classloader不能使用子 classloader或者没有父子关系的classloader加载的类的情况。 jdbc 的实现","categories":[{"name":"Jvm","slug":"Jvm","permalink":"http://wanke.fun/categories/Jvm/"}],"tags":[]},{"title":"Flutter_mac环境配置Android studio篇","slug":"Flutter-mac环境配置Android-studio篇","date":"2019-07-19T01:35:00.000Z","updated":"2024-03-12T01:06:15.824Z","comments":true,"path":"Flutter/Flutter-mac环境配置Android-studio篇/","link":"","permalink":"http://wanke.fun/Flutter/Flutter-mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AEAndroid-studio%E7%AF%87/","excerpt":"flutter 环境配置相对比较简单，不做陈述 。 注意开通vpn网络环境即可","text":"flutter 环境配置相对比较简单，不做陈述 。 注意开通vpn网络环境即可 后续开始 Flutter 相关学习 参考文档： https://flutterchina.club/setup-macos/","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://wanke.fun/categories/Flutter/"}],"tags":[]},{"title":"Android中的事件分发流程","slug":"Android中的事件分发流程","date":"2019-07-17T06:38:23.000Z","updated":"2024-03-12T01:06:15.823Z","comments":true,"path":"uncategorized/Android中的事件分发流程/","link":"","permalink":"http://wanke.fun/uncategorized/Android%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B/","excerpt":"1. View中的事件分发流程dispatchTouchEvent 核心代码","text":"1. View中的事件分发流程dispatchTouchEvent 核心代码 123456789101112131415public boolean dispatchTouchEvent(MotionEvent event) &#123; ...... ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; ..... return result; &#125; 在dispatch中对 mOnTouchListener 事件进行了处理，由此可见mOnTouchListener对分发的影响，要高于onCLick以及onLongClick 。 如果没有在mOnTouchListener中进行消费，那么View中的分发，在此处进入到了 onTouchEvent 进行处理 在View的onTouchEvent中，主要是对于MotionEvent.ACTION_DOWN、MotionEvent.ACTION_UP 、MotionEvent.ACTION_MOVE 事件进行处理 1. MotionEvent.ACTION_UP:在up 事件中，首先会进行longClick事件的判断，如果返回false，那么就不在执行 onClick事件 2. MotionEvent.ACTION_DOWN:在down事件中，首先设置了一个longClick的runnable，进行检查 3. MotionEvent.ACTION_MOVE: 2. ViewGroup 中的分发流程123456789101112131415161718public boolean dispatchTouchEvent(MotionEvent ev) &#123; ...... // 利用disallowIntercept 和 onInterceptTouchEvent 进行是否拦截的判断 if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125;","categories":[],"tags":[]},{"title":"pr主要技术点汇总","slug":"pr主要技术点汇总","date":"2019-07-09T07:09:27.000Z","updated":"2024-03-12T01:06:15.827Z","comments":true,"path":"uncategorized/pr主要技术点汇总/","link":"","permalink":"http://wanke.fun/uncategorized/pr%E4%B8%BB%E8%A6%81%E6%8A%80%E6%9C%AF%E7%82%B9%E6%B1%87%E6%80%BB/","excerpt":"绿幕抠图： 超级键 - 主要颜色点击绿布 图中抠字： 效果控件，亮度建调整 阈值和屏蔽度","text":"绿幕抠图： 超级键 - 主要颜色点击绿布 图中抠字： 效果控件，亮度建调整 阈值和屏蔽度","categories":[],"tags":[]},{"title":"镂空文字制作","slug":"镂空文字制作","date":"2019-07-08T10:41:16.000Z","updated":"2024-03-12T01:06:15.829Z","comments":true,"path":"uncategorized/镂空文字制作/","link":"","permalink":"http://wanke.fun/uncategorized/%E9%95%82%E7%A9%BA%E6%96%87%E5%AD%97%E5%88%B6%E4%BD%9C/","excerpt":"用视频或者图片作为v1 新建旧版标题 - 设置为黑色背景 添加旧版标题到v2 v2亮度建效果 - 调整阈值、调整屏蔽度","text":"用视频或者图片作为v1 新建旧版标题 - 设置为黑色背景 添加旧版标题到v2 v2亮度建效果 - 调整阈值、调整屏蔽度 绿幕抠图： 超级键 - 主要颜色点击绿布","categories":[],"tags":[]},{"title":"文字写到石头上","slug":"文字写到石头上","date":"2019-07-08T09:33:34.000Z","updated":"2024-03-12T01:06:15.828Z","comments":true,"path":"uncategorized/文字写到石头上/","link":"","permalink":"http://wanke.fun/uncategorized/%E6%96%87%E5%AD%97%E5%86%99%E5%88%B0%E7%9F%B3%E5%A4%B4%E4%B8%8A/","excerpt":"石头 v1 ，文字 v2 ，","text":"石头 v1 ，文字 v2 ， 抠图 - 文字抠图 - 效果控件，亮度建调整 阈值和屏蔽度 扭曲 - 边角定位效果可以调整图片的位置 如果文字前面有遮挡，导致效果不好，可以复制v1 到v3 选择轨道遮罩键进行处理 1、新建旧版标题 为v4 2、钢笔工具抠图 3、邮件 选择填充贝塞尔曲线 将我们的旧版标题添加到视频轨道，这样就给遮住了 轨道遮罩键 选择遮罩为视频4","categories":[],"tags":[]},{"title":"玻璃划过的效果制作","slug":"玻璃划过的效果制作","date":"2019-07-08T07:58:00.000Z","updated":"2024-03-12T01:06:15.829Z","comments":true,"path":"uncategorized/玻璃划过的效果制作/","link":"","permalink":"http://wanke.fun/uncategorized/%E7%8E%BB%E7%92%83%E5%88%92%E8%BF%87%E7%9A%84%E6%95%88%E6%9E%9C%E5%88%B6%E4%BD%9C/","excerpt":"使用图片素材 v1，拷贝一下v2，然后在窗口里面 找到基本图形 - 编辑- 矩形","text":"使用图片素材 v1，拷贝一下v2，然后在窗口里面 找到基本图形 - 编辑- 矩形 这时候会在窗口中出现一个矩形框，调整宽高，设置为水平居中和垂直居中，调整角度 现在已经有了一个黑色的长条，我们找到效果，轨道遮罩键，拖到拷贝的v2素材中 遮罩效果，选择视频3，然后在调整缩放就可以看到静态效果 图形，然后在效果栏找到变换，设置位置和关键帧 图片抠字 ： 效果控件，亮度建调整 阈值和屏蔽度","categories":[],"tags":[]},{"title":"文字操作合集","slug":"字幕","date":"2019-07-04T06:20:47.000Z","updated":"2024-03-12T01:06:15.828Z","comments":true,"path":"uncategorized/字幕/","link":"","permalink":"http://wanke.fun/uncategorized/%E5%AD%97%E5%B9%95/","excerpt":"1. 开放式字幕资源栏目里新建字幕 - 选择开放式字幕","text":"1. 开放式字幕资源栏目里新建字幕 - 选择开放式字幕 2. 制作任意轨迹文字效果1. 旧版标题 2. 路径文字工具 / 垂直路径文字工具 3. 雷特字幕插件1. 新建字幕 - 注意要和视频的序列保持一致 2. 弹出的对话框左下角点击 - 选择一个对白模板 3. 将新建的元素序列拖放到视频轨道的上方，并调整长度 4. 双击字幕轨道，导入编辑好的文本 5. 可以编辑，字体字号等样式 6. 拍字幕 ，点击录制键，然后按空格键 7. 可以在控制面板进行微调,修改错别字 4. 制作滚动和游动字幕1. 新建标题 2. 添加文本，并调整位置 3. 点击左上角第三栏图标 ，选择滚动/游动，配置滚动方式 4. 添加到轨道 练习 5. 制作猪年对联1. 在素材上新建旧版标题 2. 调整样式，并添加竖版文字 3. 变换 - 裁剪 6. 文字镂空效果 - 文字透过背景1. 新建旧版标题，用矩形工具将背景置为黑色 2. 亮度建 - 调整阈值和屏蔽度即可 7. 石头书法1. 抠图 - 文字抠图 - 效果控件，亮度建调整 阈值和屏蔽度 扭曲 - 边角定位效果可以调整图片的位置 如果文字前面有遮挡，导致效果不好，可以复制v1 到v3 选择轨道遮罩键进行处理 1、新建旧版标题 为v4 2、钢笔工具抠图 3、邮件 选择填充贝塞尔曲线 将我们的旧版标题添加到视频轨道，这样就给遮住了 轨道遮罩键 选择遮罩为视频4 8. 逐笔写字效果1. 新建旧版标题 2. 不透明度效果，新建一个矩形蒙版 3. 设置关键帧，让蒙版运动","categories":[],"tags":[]},{"title":"音频基础","slug":"音频基础","date":"2019-07-04T05:47:05.000Z","updated":"2024-03-12T01:06:15.830Z","comments":true,"path":"uncategorized/音频基础/","link":"","permalink":"http://wanke.fun/uncategorized/%E9%9F%B3%E9%A2%91%E5%9F%BA%E7%A1%80/","excerpt":"1. 音频剪辑，效果，轨道","text":"1. 音频剪辑，效果，轨道 2. 声音录制3. 变速，视频录制4. 视频加速1. 效果控件 - 时间重映射 - 速度 - 添加关键帧 2. 视频编辑出 - 右键 - 时间重映射 - 速度 2. 编辑器调整视频时间线(上下拖动) 3. 音频同步 - 取消链接，然后缩短和视频一样长度","categories":[],"tags":[]},{"title":"视频基础","slug":"视频基础","date":"2019-07-04T01:29:49.000Z","updated":"2024-03-12T01:06:15.829Z","comments":true,"path":"pr/视频基础/","link":"","permalink":"http://wanke.fun/pr/%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80/","excerpt":"1. 图片素材的导入以及导出媒体","text":"1. 图片素材的导入以及导出媒体 1.打开图片素材&lt;br&gt; 2.新建序列 3.可以对图片进行大小的调整 -&gt; 窗口-效果控件-选中图片进行调整 4.可以选择图片之间的过渡效果 5.a轨道添加音频可以作为背景音乐 2. 入点出点以及剃刀工具1. 使用入点和出点可以更方便的选中某一片段从而进行更加精确定位 2. 使用左边栏菜单，剃刀工具进行分割，也可已作为子剪辑 3. 可以在入点和出点进行循环播放 4. 对于已有视频，可以在视频素材右下角菜单建立序列和当前视频源保持一致 3.录机和放机，音视频链接1. 放机里面我们可以截取片段 2. 音视频可以通过右键菜单进行链接与反链接 4. 倒放，播放速度，持续时间1. 视频轨道右键通过时间菜单可以进行调整 5. 画中画1. v1，v2添加视频源 2. 可以调整视频的位置，可以动态设置位置，可以进行特效 比如移动，透明，旋转。。。 6. 特效控制1. 效果控件里面可以选择翻转，等过渡动画，可以添加特效","categories":[{"name":"pr","slug":"pr","permalink":"http://wanke.fun/categories/pr/"}],"tags":[]},{"title":"https 以及SSL通信认证","slug":"https-以及SSL通信认证","date":"2019-06-06T03:11:17.000Z","updated":"2024-03-12T01:06:15.826Z","comments":true,"path":"Java/https-以及SSL通信认证/","link":"","permalink":"http://wanke.fun/Java/https-%E4%BB%A5%E5%8F%8ASSL%E9%80%9A%E4%BF%A1%E8%AE%A4%E8%AF%81/","excerpt":"1. HttpHyperText Transfer Protocol，超文本传输协议，是互联网上使用最广泛的一种协议，所有WWW文件必须遵循的标准。HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全。","text":"1. HttpHyperText Transfer Protocol，超文本传输协议，是互联网上使用最广泛的一种协议，所有WWW文件必须遵循的标准。HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全。 使用TCP端口为：80 2. HttpsHyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了SSL(Secure Sockets Layer)协议用于对Http协议传输的数据进行加密，保证会话过程中的安全性。 使用TCP端口默认为443 3. SSL协议加密方式SSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。 对称加密速度高，可加密内容较大，用来加密会话过程中的消息 公钥加密加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥 4. 单向认证Https在建立Socket连接之前，需要进行握手，具体过程如下： 客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。 服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书 客户端使用服务端返回的信息验证服务器的合法性，包括： a. 证书是否过期 b. 发型服务器证书的CA是否可靠 c. 返回的公钥是否能正确解开返回证书中的数字签名 d. 服务器证书上的域名是否和服务器的实际域名相匹配 e. 验证通过后，将继续进行通信，否则，终止通信 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。 服务器将选择好的加密方案通过明文方式返回给客户端 客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器 服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。 在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。 5. 双向认证双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下： 客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。 服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书 客户端使用服务端返回的信息验证服务器的合法性，包括： a. 证书是否过期 b. 发型服务器证书的CA是否可靠 c. 返回的公钥是否能正确解开返回证书中的数字签名 d. 服务器证书上的域名是否和服务器的实际域名相匹配 e. 验证通过后，将继续进行通信，否则，终止通信 服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端 验证客户端的证书，通过验证后，会获得客户端的公钥 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式 将加密方案通过使用之前获取到的公钥进行加密，返回给客户端 客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端 10、服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。 6. 总结https的通信由三步完成 1. 交换客户端和服务端的交换 包括： SSL版本号，加密算法种类，随机数等，服务端同时返回证书信息 2. 认证客户端对服务端证书的认证 包括： 证书有效期，证书是否合法，证书的额域名是否匹配等 3. 加密 &amp; 通信客户端会将自己支持的加密算法发送给服务端，然后服务端选择安全性高的加密方式，连同之前的公钥发给客户端。","categories":[{"name":"Java","slug":"Java","permalink":"http://wanke.fun/categories/Java/"}],"tags":[]},{"title":"深入理解BlockQueue","slug":"深入理解BlockQueue","date":"2019-05-28T06:38:29.000Z","updated":"2024-03-12T01:06:15.828Z","comments":true,"path":"Java/深入理解BlockQueue/","link":"","permalink":"http://wanke.fun/Java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3BlockQueue/","excerpt":"","text":"谈谈BlockQueue 在前文生产者消费者模式的实现中，我们使用了BlockQueue的方式 来进行模拟，它使得我们不必写大量的wait和notify代码 那么BlockQueue有着什么样的魔力 1.","categories":[{"name":"Java","slug":"Java","permalink":"http://wanke.fun/categories/Java/"}],"tags":[]},{"title":"生产者消费者模式的三种实现","slug":"生产者消费者模式的三种实现","date":"2019-05-28T03:25:00.000Z","updated":"2024-03-12T01:06:15.829Z","comments":true,"path":"Java/生产者消费者模式的三种实现/","link":"","permalink":"http://wanke.fun/Java/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0/","excerpt":"1. 什么是生产者消费者模式通过一个容器解决生产者消费者强耦合的问题，生产者和消费者之间不直接通信，通过阻塞的方式来实现数据的存取，阻塞的容器就相当于一个缓冲区，平衡生产者消费者的能力。","text":"1. 什么是生产者消费者模式通过一个容器解决生产者消费者强耦合的问题，生产者和消费者之间不直接通信，通过阻塞的方式来实现数据的存取，阻塞的容器就相当于一个缓冲区，平衡生产者消费者的能力。 2. 为什么要使用生产者消费者模式在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这种生产消费能力不均衡的问题，所以便有了生产者和消费者模式。 代码实战1.首先是生产者和消费者线程生产者和消费者各是线程，在线程启动时候，开启无限循环，不断的进行添加和删除的操作。 12345678910111213141516 public class Consumer extends Thread &#123; private Resources res; public Consumer(Resources res) &#123; this.res = res; &#125; @Override public void run() &#123; super.run(); while(true) &#123; res.countDown(); &#125; &#125;&#125; 1234567891011121314151617 public class Productor extends Thread &#123; private Resources res; public Productor(Resources res) &#123; this.res = res; &#125; @Override public void run() &#123; super.run(); while(true) &#123; res.add(); &#125; &#125;&#125; 2. 重点是我们的资源库，一共三种实现方式123456 public interface Resources &#123; public void add(); public void countDown(); &#125; 定义了一个 resource接口，有一个添加和一个消费的接口。 1. 使用synchronize + wait() + notifyAll() 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 public class ResourcesImpl2 implements Resources &#123; // 当前资源数量 private int num = 0; // 资源池中允许存放的资源数目 private int size = 10; @Override public synchronized void add() &#123; System.out.println(&quot; add ........... &quot;); if (num &lt; size) &#123; num++; System.out.println(&quot;生产者&quot;+Thread.currentThread().getName() + &quot;生产一件资源，当前资源池有&quot; + num + &quot;个&quot;); // 通知等待的消费者 this.notifyAll(); &#125; else &#123; // 如果当前资源池中有10件资源 try &#123; System.out.println(&quot;生产者&quot;+Thread.currentThread().getName() + &quot;线程进入等待&quot;); this.wait();// 生产者进入等待状态，并释放锁 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public synchronized void countDown() &#123; if (num &gt; 0) &#123; num--; System.out.println(&quot;消费者&quot; + Thread.currentThread().getName() + &quot;消耗一件资源，&quot; + &quot;当前线程池有&quot; + num + &quot;个&quot;); this.notifyAll();// 通知生产者生产资源 &#125; else &#123; try &#123; // 如果没有资源，则消费者进入等待状态 this.wait(); System.out.println(&quot;消费者&quot; + Thread.currentThread().getName() + &quot;线程进入等待状态&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 1. 使用阻塞队列BlockQueue 实现12345678910111213141516171819202122232425 public class ResourcesImpl implements Resources &#123; BlockingQueue&lt;Integer&gt; queue = new LinkedBlockingQueue&lt;Integer&gt;(10); @Override public void add() &#123; if (queue.size() &lt; 10) &#123; queue.add(1); &#125; &#125; @Override public void countDown() &#123; try &#123; if (queue.size() &gt; 0) &#123; Integer take = queue.take(); System.out.println(take); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1. 使用可重入锁的方式 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 public class ResourcesImpl3 implements Resources &#123; // 当前资源数量 private int num = 0; // 资源池中允许存放的资源数目 private int size = 10; private Lock lock = new ReentrantLock(); private Condition con; private Condition pro; public ResourcesImpl3() &#123; con = lock.newCondition(); pro = lock.newCondition(); &#125; @Override public void add() &#123; System.out.println(&quot; add ........... &quot;); lock.lock(); try &#123; if (num &lt; size) &#123; num++; System.out.println(&quot;生产者&quot; + Thread.currentThread().getName() + &quot;生产一件资源，当前资源池有&quot; + num + &quot;个&quot;); // 通知等待的消费者 con.signalAll(); &#125; else &#123; // 如果当前资源池中有10件资源 try &#123; System.out.println(&quot;生产者&quot; + Thread.currentThread().getName() + &quot;线程进入等待&quot;); pro.await();// 生产者进入等待状态，并释放锁 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; finally &#123; lock.unlock(); &#125; &#125; @Override public void countDown() &#123; lock.lock(); try &#123; if (num &gt; 0) &#123; num--; System.out.println(&quot;消费者&quot; + Thread.currentThread().getName() + &quot;消耗一件资源，&quot; + &quot;当前线程池有&quot; + num + &quot;个&quot;); pro.signalAll();// 通知生产者生产资源 &#125; else &#123; try &#123; // 如果没有资源，则消费者进入等待状态 con.await(); System.out.println(&quot;消费者&quot; + Thread.currentThread().getName() + &quot;线程进入等待状态&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://wanke.fun/categories/Java/"}],"tags":[]},{"title":"java中的Volatile","slug":"java中的Volatile","date":"2019-05-27T03:09:12.000Z","updated":"2024-03-12T01:06:15.826Z","comments":true,"path":"Java/java中的Volatile/","link":"","permalink":"http://wanke.fun/Java/java%E4%B8%AD%E7%9A%84Volatile/","excerpt":"1. Volatile的作用在Java多线程编程中，被Volatile修饰的关键字会对所有线程课件，也就是说他保证了变量的可见性。当一个volatile变量值被一个线程修改额时候，那么另外一个线程也可以读取到被修改后的值。","text":"1. Volatile的作用在Java多线程编程中，被Volatile修饰的关键字会对所有线程课件，也就是说他保证了变量的可见性。当一个volatile变量值被一个线程修改额时候，那么另外一个线程也可以读取到被修改后的值。 2. 为什么使用Volatile如果使用得当，volatile关键字会比synchronized有着更低的使用和执行成本，它不会引起线程上下文的切换和调度。 实现long&#x2F;double类型的可见性 （4个字节，赋值时低32位和高32位分别写入） 防止指令 重排序 实现变量的可见性 以上2，3 是通过内存屏障（memory barrier）来实现的","categories":[{"name":"Java","slug":"Java","permalink":"http://wanke.fun/categories/Java/"}],"tags":[]},{"title":"java技能必修技能和书单推荐","slug":"java技能必修技能和书单推荐","date":"2019-01-11T09:18:45.000Z","updated":"2024-03-12T01:06:15.826Z","comments":true,"path":"uncategorized/java技能必修技能和书单推荐/","link":"","permalink":"http://wanke.fun/uncategorized/java%E6%8A%80%E8%83%BD%E5%BF%85%E4%BF%AE%E6%8A%80%E8%83%BD%E5%92%8C%E4%B9%A6%E5%8D%95%E6%8E%A8%E8%8D%90/","excerpt":"","text":"链接：https://www.zhihu.com/question/38880482/answer/567106090","categories":[],"tags":[]},{"title":"adb command not found ","slug":"adb-command-not-found","date":"2019-01-09T05:13:00.000Z","updated":"2024-03-12T01:06:15.825Z","comments":true,"path":"Android/adb-command-not-found/","link":"","permalink":"http://wanke.fun/Android/adb-command-not-found/","excerpt":"在Mac系统中，很多时候第一次在Android SDK中使用adb的时候。无法使用。会提示-bash: abd: command not found。","text":"在Mac系统中，很多时候第一次在Android SDK中使用adb的时候。无法使用。会提示-bash: abd: command not found。 造成此类现象的原因是：未配置Android的环境变量。因此，您需为Mac中的Android SDK配置环境变量。 启动Mac自带的终端Terminal。进入当前用户的home目录。 在命令行输入echo $HOME创建.bash_profile文件。 命令行输入touch .bash_profile打开.bash_profile文件。 命令行输入open -e .bash_profile 此命令行输入完毕后，会自动弹出 .bash_profile 文件的编辑窗口，在.bash_profile文件中输入 export PATH&#x3D;&#x2F;Users&#x2F;您的用户名&#x2F;文件路径&#x2F;platform-tools&#x2F;:$PATH保存文件。 直接关闭.bash_profile文件，即可自动保存您输入的内容。 更新刚配置的环境变量在命令行中输入 source .bash_profile 验证配置是否成功输入adb， 如果没有出现-bash: adb: command not found；而出现adb的命令参数解释。则表明环境变量配置成功。 export ANDROID_HOME&#x3D;&#x2F;Users&#x2F;1111&#x2F;Library&#x2F;Android&#x2F;sdk export PATH&#x3D;${PATH}:${ANDROID_HOME}&#x2F;tools export PATH&#x3D;${PATH}:${ANDROID_HOME}&#x2F;platform-tools","categories":[{"name":"Android","slug":"Android","permalink":"http://wanke.fun/categories/Android/"}],"tags":[]},{"title":"ReactNative 常见问题汇总","slug":"ReactNative-常见问题汇总","date":"2019-01-04T09:08:42.000Z","updated":"2024-03-12T01:06:15.825Z","comments":true,"path":"ReactNative/ReactNative-常见问题汇总/","link":"","permalink":"http://wanke.fun/ReactNative/ReactNative-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","excerpt":"1. Unable to load script from assets ‘index.android.bundle’","text":"1. Unable to load script from assets ‘index.android.bundle’ 12345678910java.lang.RuntimeException: Unable to load script from assets &#x27;index.android.bundle&#x27;. Make sure your bundle is packaged correctly or you&#x27;re running a packager server. at com.facebook.react.bridge.CatalystInstanceImpl.jniLoadScriptFromAssets(Native Method) at com.facebook.react.bridge.CatalystInstanceImpl.loadScriptFromAssets(CatalystInstanceImpl.java:216) at com.facebook.react.bridge.JSBundleLoader$1.loadScript(JSBundleLoader.java:32) at com.facebook.react.bridge.CatalystInstanceImpl.runJSBundle(CatalystInstanceImpl.java:243) at com.facebook.react.ReactInstanceManager.createReactContext(ReactInstanceManager.java:1116) at com.facebook.react.ReactInstanceManager.access$900(ReactInstanceManager.java:117) at com.facebook.react.ReactInstanceManager$5.run(ReactInstanceManager.java:916) at java.lang.Thread.run(Thread.java:818) 出现此问题的原因是因为没有找到index.android.bundle文件，我是用的是2.0.1,解决方案如下 创建目录 android\\app\\src\\main\\assets 执行以下命令，将index.android.bundle 文件拷贝到 asset目录 react-native bundle –platform android –dev false –entry-file index.js –bundle-output android&#x2F;app&#x2F;src&#x2F;main&#x2F;assets&#x2F;index.android.bundle –assets-dest android&#x2F;app&#x2F;src&#x2F;main&#x2F;res&#x2F; 如此以后，再执行react-native run-android 启动app即可解决","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://wanke.fun/categories/ReactNative/"}],"tags":[]},{"title":"reactnative 使用自定义原生控件","slug":"reactnative-使用自定义原生控件","date":"2019-01-02T08:00:41.000Z","updated":"2024-03-12T01:06:15.827Z","comments":true,"path":"ReactNative/reactnative-使用自定义原生控件/","link":"","permalink":"http://wanke.fun/ReactNative/reactnative-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8E%9F%E7%94%9F%E6%8E%A7%E4%BB%B6/","excerpt":"致敬 facebook 。reactnative 是factbook推出的移动端跨平台框架，给跨平台开发带来了新的实现。它封装了大量常用的基础控件，但是在开发的过程中并不能满足个性的开发。有幸的是 rn团队为开发者接入自定义控件提供了解决方案。本章主要记录Android平台上如何使用自定义控件。","text":"致敬 facebook 。reactnative 是factbook推出的移动端跨平台框架，给跨平台开发带来了新的实现。它封装了大量常用的基础控件，但是在开发的过程中并不能满足个性的开发。有幸的是 rn团队为开发者接入自定义控件提供了解决方案。本章主要记录Android平台上如何使用自定义控件。 1.Android端原生实现1.1 继承ViewManager进行自定义控件开发123456789101112public class GameViewManager extends SimpleViewManager&lt;ImageView&gt; &#123;@Override public String getName() &#123; return &quot;rnimageview&quot;; &#125; @Override protected ImageView createViewInstance(ThemedReactContext reactContext) &#123; return new ImageView(): &#125;&#125; getName 方法返回的值 就是我们在 rn的javascript文件里面使用的view标签名字通过createViewInstance方法返回要使用控件的实例 1.2 支持自定义属性和方法我们需要添加一些动态的值通过属性的方式让我们的原生控件接收，rn提供了一套通信方式,我们在ViewManager的实现类中添加如下方法： 1234567@ReactMethod @ReactProp(name = &quot;gameURL&quot;) public void setUrl(JdGameSurface view, @Nullable String sources) &#123; Toast.makeText(view.getContext(),&quot;seturl&quot;,Toast.LENGTH_SHORT).show(); view.loadJsFromAssets(&quot;fish-android.js&quot;); view.start(); &#125; 添加 ReactMethod 注解的方法可以在javascript文件中访问， 这样我们可以在javascript中动态设值。@ReactProp(name &#x3D; “gameURL”) 此注解标识我们为本view添加了一个gameURL的属性 。 通过这样我们就完成了对应属性的添加 1.3 注册我们的自定义控件首先我们 新建ReactPackage的实现类，然后将我们的自定义ViewManager 在createViewManagers方法中添加到集合返回，如下代码所示 ： 123456789101112131415public class GameReactPackage implements ReactPackage &#123; @Override public List&lt;NativeModule&gt; createNativeModules(ReactApplicationContext reactContext) &#123; return Collections.emptyList(); &#125; @Override public List&lt;ViewManager&gt; createViewManagers(ReactApplicationContext reactContext) &#123; ArrayList&lt;ViewManager&gt; viewManagers = new ArrayList&lt;&gt;(); viewManagers.add(new GameViewManager());//重要 return viewManagers; &#125;&#125; 其次，在application中将我们新建的ReactPackage类，添加到rn中注册 12345678910111213141516171819202122232425262728293031323334public class MainApplication extends Application implements ReactApplication &#123; private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) &#123; @Override public boolean getUseDeveloperSupport() &#123; return BuildConfig.DEBUG; &#125; @Override protected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage(), new GameReactPackage()//重要 ); &#125; @Override protected String getJSMainModuleName() &#123; return &quot;index&quot;; &#125; &#125;; @Override public ReactNativeHost getReactNativeHost() &#123; return mReactNativeHost; &#125; @Override public void onCreate() &#123; super.onCreate(); SoLoader.init(this, /* native exopackage */ false); &#125;&#125; 主要是在 getPackages 方法中将此 ReactPackage 添加到集合中返回 。 到此为止，我么就将Android中原生开发进行完毕，下面开始讲解怎么在 javascript文件中使用此自定义控件 2. 在RN中使用自定义控件为方便使用，我们实现一个 rn模块对view进行统一的管理 12345678910111213141516171819import React, &#123; Component &#125; from &#x27;react&#x27;;import PropTypes from &#x27;prop-types&#x27;;import &#123; requireNativeComponent &#125; from &#x27;react-native&#x27;;class JDGameView extends React.Component&#123; render() &#123; return &lt;RNJDGame &#123;...this.props&#125; /&gt;; &#125;&#125;JDGameView.propTypes = &#123; gameURL:PropTypes.string, ...View.propTypes&#125;;var RNJDGame = requireNativeComponent(&#x27;RNJDGame&#x27;,JDGameView);export default JDGameView; 在我们需要使用此view的地方进行引入即可 12345render() &#123; return ( &lt;JDGameView gameURL=&quot;xxxxxxx&quot;&gt;&lt;/JDGameView&gt; ); &#125; 至此，我们通过代码和讲解，实现了rn中进行自定义控件的完整流程。","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://wanke.fun/categories/ReactNative/"}],"tags":[]},{"title":"Android 中so的动态加载实现","slug":"Android-中so的动态加载实现","date":"2018-12-13T07:24:06.000Z","updated":"2024-03-12T01:06:15.823Z","comments":true,"path":"Android/Android-中so的动态加载实现/","link":"","permalink":"http://wanke.fun/Android/Android-%E4%B8%ADso%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/","excerpt":"正常情况下我们都是通过System.loadLibrary()的方式来加载位于libs下的so。最近做的一个项目由于对于aar体积有严格的大小要求，所以将so做成了动态加载的策略","text":"正常情况下我们都是通过System.loadLibrary()的方式来加载位于libs下的so。最近做的一个项目由于对于aar体积有严格的大小要求，所以将so做成了动态加载的策略 获取手机cpu架构的命令 adb shell getprop ro.product.cpu.abi 1.加载远程so我们需要将so下载到本地进行加载，通过System.load()方法将本地so路径作为参数传入！ 2. 代码实现1234567891011121314151617/** * @param context * @param so 所在的路径 */ @SuppressLint(&quot;UnsafeDynamicallyLoadedCode&quot;) public static void loadSoFile(Context context, String originFilePath) &#123; File dir = context.getDir(&quot;libs&quot;, Context.MODE_PRIVATE); File file = new File(originFilePath); String toFilePath = dir.getAbsolutePath() + File.separator + file.getName(); copySdcardFile(originFilePath, toFilePath); System.load(toFilePath); &#125; 1234567891011121314151617181920212223public static int copySdcardFile(String fromFile, String toFile) &#123; try &#123; FileInputStream fosfrom = new FileInputStream(fromFile); FileOutputStream fosto = new FileOutputStream(toFile); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len = -1; while ((len = fosfrom.read(buffer)) != -1) &#123; baos.write(buffer, 0, len); &#125; // 从内存到写入到具体文件 fosto.write(baos.toByteArray()); // 关闭文件流 baos.close(); fosto.close(); fosfrom.close(); return 0; &#125; catch (Exception ex) &#123; return -1; &#125; &#125; 一定要将so拷贝到app内部目录，否则无权限执行so 3. 平台适配问题 由于android平台存在多种类型的cpu架构，所以需要我们根据不同的cpu加载对应的so库，比如 x86，armabi等 代码获取当前设备的cpu 12345678910111213141516171819202122public static String getFirstSupportedAbi() &#123; String abi1 = &quot;&quot;; if (Build.VERSION.SDK_INT &gt;= 21) &#123; String[] abis = Build.SUPPORTED_ABIS; if (abis != null &amp;&amp; abis.length &gt; 0) &#123; String abistr = &quot;&quot;; //第一个是原生支持的,后面的是兼容模式.虽然是兼容,但手动加载时很多并不兼容. abi1 = abis[0]; for (String abi : abis) &#123; abistr = abistr + abi + &quot;,&quot;; &#125; JdGame.print(abistr); &#125; &#125; else &#123; if (!TextUtils.isEmpty(Build.CPU_ABI)) &#123; abi1 = Build.CPU_ABI; &#125; else if (!TextUtils.isEmpty(Build.CPU_ABI2)) &#123; abi1 = Build.CPU_ABI2; &#125; &#125; return abi1; &#125; 然后根据获取的 cpu值，去下载对应的 so 再进行加载","categories":[{"name":"Android","slug":"Android","permalink":"http://wanke.fun/categories/Android/"}],"tags":[]},{"title":"Android上使用的javascript引擎 - duktapeJava篇","slug":"移动端跨平台探索-javascript引擎的使用","date":"2018-12-13T02:49:13.000Z","updated":"2024-03-12T01:06:15.829Z","comments":true,"path":"jdhai/javascript/跨平台/移动端跨平台探索-javascript引擎的使用/","link":"","permalink":"http://wanke.fun/jdhai/javascript/%E8%B7%A8%E5%B9%B3%E5%8F%B0/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8E%A2%E7%B4%A2-javascript%E5%BC%95%E6%93%8E%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"在实际项目中找到两款可以在android平台使用的javascript引擎，duktapeJava 和 LiquidCore 本文重点关注 duktapeJava的使用","text":"在实际项目中找到两款可以在android平台使用的javascript引擎，duktapeJava 和 LiquidCore 本文重点关注 duktapeJava的使用 duktapeJava liquidCore 支持平台 java&#x2F;android java&#x2F;android es6支持 否 是 使用便捷 是 一般 性能 一般 良 体积 小 大 相对于liquidCore duktapeJava对于java对象的支持更加便捷 , 但是需要用duktapeJava提供的转义工具，对javascript进行转义，否则无法引用java对象。 1. duktapeJava的基本使用1.1 gradle 依赖引入compile &#39;com.furture.react:DuktapeJava:1.2.0&#39; or compile &#39;com.furture.react:DuktapeJava:1.2.0@aar&#39; 1.2 加载javascript123456789101112131415161718 @Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); duktapeEngine = new DuktapeEngine(); duktapeEngine.execute(AssetScript.toScript(getBaseContext(), &quot;duk.js&quot;));&#125; @Overrideprotected void onDestroy() &#123; if (duktapeEngine != null) &#123; duktapeEngine.destory(); duktapeEngine = null; &#125; super.onDestroy();&#125; 首先新建一个duktape引擎对象 AssetScript.toScript主要是为了转义，好让我们内置的java对象能够在javascript文件里面使用 duktape.execute 执行语句 以上四步就是实例化引擎并执行javascript的完整流程 2.javascript 调用java代码 首先要新建一个sprite 对象 sprite &#x3D; new Sprite(); 123456789101112 public class Sprite &#123; private double x = -1; public double getX() &#123; return x; &#125; public void setX(double x) &#123; this.x = x; &#125;&#125; 将sprite加载进javascript引擎 duktape.put(sprite,”sp”) 那么我们就可以在 javascript里面通过 sp.getX()调起 sprite里面的方法 2. java调用javascript函数和对象javascript 语句如下 123456var obj = &#123; test : function() &#123; .... &#125;&#125; java代码： 12345JsRef ref = duktape.get(&quot;obj&quot;);JsRef func = ref.get(&quot;test&quot;);func.getEngine().call(func,&quot;&quot;);","categories":[{"name":"jdhai","slug":"jdhai","permalink":"http://wanke.fun/categories/jdhai/"},{"name":"javascript","slug":"jdhai/javascript","permalink":"http://wanke.fun/categories/jdhai/javascript/"},{"name":"跨平台","slug":"jdhai/javascript/跨平台","permalink":"http://wanke.fun/categories/jdhai/javascript/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"}],"tags":[]},{"title":"移动端跨平台探索 - 总览","slug":"移动端跨平台探索-总览","date":"2018-12-12T08:30:13.000Z","updated":"2024-03-12T01:06:15.829Z","comments":true,"path":"jdhai/移动端跨平台探索-总览/","link":"","permalink":"http://wanke.fun/jdhai/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8E%A2%E7%B4%A2-%E6%80%BB%E8%A7%88/","excerpt":"随着移动技术的发展，跨平台技术日趋火热。颇有一股推到原生开发的气势，本系列介绍之前公司内部跨平台技术开发，以及用到的相关技术点和实现细节","text":"随着移动技术的发展，跨平台技术日趋火热。颇有一股推到原生开发的气势，本系列介绍之前公司内部跨平台技术开发，以及用到的相关技术点和实现细节 1.jdhai项目介绍在7fresh项目的开发和维护过程中，由于需要经常性的进行各种活动的支持，介于HTML的糟糕体验，我们在内部探索实现了一套轻量级的跨平台的技术实现，并在7fresh项目中进行了大量的实践，同一套代码运行在Android和ios两端，并实现了动态加载和更新！ 1.1 优势jdhai 使用 javascript作为开发语言，基于mvc思想，实现了ui，样式和代码逻辑的分离。底层由Android和ios原生控件实现，布局基于 flexbox思想。一次开发，就可以运行在iOS、Android 平台上，具备iOS和Android原生的性能和用户体验上的优势，并且可以无需客户端更新版本做到动态更新页面功能。 2.jdhai 技术架构jdhai 使用 xml 作为 布局文件的描述语言，使用json进行样式文件描述，使用javascript作为开发语言。iOS和Android 两端 各自实现 上述文件的解析并通过javascript建立和native代码的通信。javascript使用同一的api接口，调用各端原生代码的native实现，从而达到使用javascript开发的统一。 # 3. jdhai 使用到的技术总览 ## 3.1 利用 javascript 进行前端页面开发 使用javascript同原生代码进行交互，为此我们借助 javascript 引擎解决通信问题。通过调研 duktape，javascCore 等引擎，我们最终选用了 duktape-Java 这个基于duktape 的引擎实现。 duktape 部分可以参考： Android上使用的javascript引擎 - duktapeJava篇 3.2 利用yoga和flexbox布局思想进行样式文件编写 flexBox布局是 W3C 在2009年 提出了一种新的布局方案，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持！ 3.2.1 yoga - Facebook 跨平台布局项目FaceBook&#x2F;Yoga 是一个基于Flexbox思想的布局项目，他提供了 java，android，ios 等多个平台的实现。这使得我们可以借助yoga 利用同一套样式文件运行到不同平台上。也为我们跨平台项目的布局提供了一种解决方案！ 3.2.2 yoga的Android实现 yogaLayoutyogalayout 是 yoga 项目中的Android 实现，他封装了一个 使得可以方便的以flexbox的规范来进行放置子控件的ViewGroup,而不用关心如何把flexBox转化成ViewGroup布局。 3.2.3 yogaLayout使用123456789View child = new View(context); YogaNode yogaNode = new YogaNode(); yogaNode.setHeight(10); yogaNode.setWidth(10); YogaLayout layout = new YogaLayout(context); layout.addView(child,yogaNode); yogalayout addview接收2个参数，一个是我们要添加的view，另外一个 yoganode 就是约束子view是如何进行布局的。假如我们有如下的 json文件 1234567&quot;flexDirection&quot;: &quot;row&quot;,&quot;justifyContent&quot;: &quot;flexStart&quot;,&quot;alignItems&quot;: &quot;center&quot;,&quot;width&quot;: &quot;100%&quot;,&quot;height&quot;: &quot;57&quot;,&quot;backgroundColor&quot;: &quot;FFFFFF&quot; 那么我们可以将上述json描述转化为 yogaNode属性 1234yogaNode.setFlexDirection(YogaFlexDirection.ROW); yogaNode.setJustifyContent(YogaJustify.FLEX_START); yogaNode.setAlignItems(YogaAlign.CENTER); 如此我们使得我们动态下发样式成为一种可能，这样也就可以动态改变页面布局的展现外观了。 FlexBox部分的学习可以参考 阮一峰的FlexBox教程 3.3 基于xml的布局文件描述12345678910&lt;view classX=&quot;floor-10&quot;&gt; &lt;view classX=&quot;11-left&quot;&gt; &lt;listFlexImage ID=&quot;11-image1&quot; classX=&quot;coupon_image_11&quot;/&gt; &lt;image ID=&quot;11-markImage1&quot; classX=&quot;10-markImage&quot;/&gt; &lt;/view&gt; &lt;view classX=&quot;11-middle&quot;&gt; &lt;listFlexImage ID=&quot;11-image2&quot; classX=&quot;coupon_image_11&quot;/&gt; &lt;image ID=&quot;11-markImage2&quot; classX=&quot;10-markImage&quot;/&gt;&lt;/view&gt;","categories":[{"name":"jdhai","slug":"jdhai","permalink":"http://wanke.fun/categories/jdhai/"}],"tags":[]},{"title":"二维数组中的查找","slug":"二维数组中的查找","date":"2018-12-12T07:03:50.000Z","updated":"2024-03-12T01:06:15.827Z","comments":true,"path":"剑指系列/二维数组中的查找/","link":"","permalink":"http://wanke.fun/%E5%89%91%E6%8C%87%E7%B3%BB%E5%88%97/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/","excerpt":"题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。","text":"题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 分析利用二维数组由上到下，由左到右递增的规律，那么选取右上角或者左下角的元素a[row][col]与target进行比较，当target小于元素a[row][col]时，那么target必定在元素a所在行的左边,即col–；当target大于元素a[row][col]时，那么target必定在元素a所在列的下边,即row++； 代码示例123456789101112131415public class Solution &#123; public boolean Find(int [][] array,int target) &#123; int row=0; int col=array[0].length-1; while(row&lt;=array.length-1&amp;&amp;col&gt;=0)&#123; if(target==array[row][col]) return true; else if(target&gt;array[row][col]) row++; else col--; &#125; return false; &#125;&#125;","categories":[{"name":"剑指系列","slug":"剑指系列","permalink":"http://wanke.fun/categories/%E5%89%91%E6%8C%87%E7%B3%BB%E5%88%97/"}],"tags":[]},{"title":"开篇","slug":"开篇","date":"2018-12-11T08:30:13.000Z","updated":"2024-03-12T01:06:15.828Z","comments":true,"path":"杂谈/开篇/","link":"","permalink":"http://wanke.fun/%E6%9D%82%E8%B0%88/%E5%BC%80%E7%AF%87/","excerpt":"回想过去，立足当下，展望未来！","text":"回想过去，立足当下，展望未来！ 心怀敬畏，查漏补缺，重温java和android知识体系，探索新的技术热点 。特建此站点博客，以作记录。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://wanke.fun/categories/%E6%9D%82%E8%B0%88/"}],"tags":[]},{"title":"027.模式对比","slug":"027-模式对比","date":"2018-04-22T07:20:00.000Z","updated":"2024-03-12T01:06:15.823Z","comments":true,"path":"uncategorized/027-模式对比/","link":"","permalink":"http://wanke.fun/uncategorized/027-%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94/","excerpt":"","text":"1 工厂方法模式 VS 建造者模式工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。 我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。 2 抽象工厂模式 VS 建造者模式抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。 建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。 如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。 3 三种代理的对比 jdk代理和CGLIB代理 使用CGLib实现动态代理，CGLib 底层采用 ASM 字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。 在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用 JDK 动态代理，如果没有接口使用 CGLIB 代理。 动态代理和静态代理 动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。 如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题 4 代理 VS 装饰者静态代理和装饰者模式的区别： 相同点： 都要实现与目标类相同的业务接口 在两个类中都要声明目标对象 都可以在不修改目标类的前提下增强目标方法 不同点： 目的不同 装饰者是为了增强目标对象 静态代理是为了保护和隐藏目标对象 获取目标对象构建的地方不同 装饰者是由外界传递进来，可以通过构造方法传递 静态代理是在代理类内部创建，以此来隐藏目标对 5 策略VS状态策略模式：策略模式的客户端必须对所有的策略类相当了解，明确当前场景下各种策略的利弊，权衡在当前场景下应该使用哪种策略，也就是是说策略类对客户端是暴露的 状态模式：状态模式依赖于其状态的变化时其内部的行为发生变化，将动作委托到代表当前状态的对象，对外表现为类发生了变化。 策略模式是通过 Context 本身的决策来主动更替使用的strategy对象达到改变行为的目的，状态模式通过状态转移来被动的更改当前的State对象，状态的改变发生在运行时。 策略模式提前封装一组可以互相替代的算法族，根据需要动态的选择合适的一个来处理问题，而状态模式处理不同状态下， Context 对象行为不同的问题； 6 外观 VS 代理 VS 中介者外观模式（Facade Pattern）定义一个外观类，外观类隐藏系统的复杂性，为客户端提供简化的方法和对现有系统类方法的委托调用。例如：二手房交易的中介，属于外观模式。买房者通过中介可以简单地买到二手房，中介自己把联系房东看房砍价、过户、交税这些复杂的事情都搞定了。 代理模式（Proxy Pattern）用一个代理类代表另一个类的功能，但是不改变被代理类的功能。目的是控制对被代理类的访问。 中介者模式（Mediator Pattern）用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。将各对象之间的网状结构分离为星型结构。例如：MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。微信群是各群员之间的中介者。","categories":[],"tags":[],"author":"师学"},{"title":"025.行为型模式_备忘录模式","slug":"025-行为型模式-备忘录模式","date":"2018-04-22T07:19:00.000Z","updated":"2024-03-12T01:06:15.823Z","comments":true,"path":"设计模式/025-行为型模式-备忘录模式/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/025-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 概念又叫快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。 备忘录模式的主要角色如下： 发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。 备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。 管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。 2 例子游戏存档。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//游戏public class GameRate &#123; private int rate; //当前进度 public int getRate() &#123; return rate; &#125; public void setRate(int rate) &#123; this.rate = rate; &#125; //保存进度 public GameRateMemento save() &#123; return new GameRateMemento(rate); &#125; //恢复进度 public void recoverState(GameRateMemento gameRateMemento) &#123; this.rate = gameRateMemento.getRate(); &#125; @Override public String toString() &#123; return &quot;GameRate&#123;&quot; + &quot;rate=&quot; + rate + &#x27;&#125;&#x27;; &#125;&#125;//游戏进度存储类(备忘录类)public class GameRateMemento &#123; private int rate; //进度 public int getRate() &#123; return rate; &#125; public void setRate(int rate) &#123; this.rate = rate; &#125; public GameRateMemento(int rate) &#123; this.rate = rate; &#125;&#125;//角色状态管理者类public class GameRateCaretaker &#123; private GameRateMemento gameRateMemento; public GameRateMemento getGameRateMemento() &#123; return gameRateMemento; &#125; public void setGameRateMemento(GameRateMemento gameRateMemento) &#123; this.gameRateMemento = gameRateMemento; &#125;&#125;public class TestClient &#123; public static void main(String[] args) &#123; final GameRate gameRate = new GameRate(); gameRate.setRate(50);//当前进度 50 System.out.println(gameRate); //保存游戏进度 final GameRateCaretaker gameRateCaretaker = new GameRateCaretaker(); gameRateCaretaker.setGameRateMemento(gameRate.save()); gameRate.setRate(70);//进行到 70 System.out.println(gameRate); //回档 gameRate.recoverState(gameRateCaretaker.getGameRateMemento()); System.out.println(gameRate); &#125;&#125; 3 优缺点优点： 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 * 实现了信息的封装，使得用户不需要关心状态的保存细节。 缺点： 消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"026.行为型模式_解释器模式","slug":"026-行为型模式-解释器模式","date":"2018-04-22T07:19:00.000Z","updated":"2024-03-12T01:06:15.823Z","comments":true,"path":"设计模式/026-行为型模式-解释器模式/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/026-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 概述提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。 解释器模式包含以下主要角色。 抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。 终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。 非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。 环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。 客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。 2 例子计算器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//创建一个表达式接口。public interface Expression &#123; int interpreter(Context context);//一定会有解释方法&#125;//抽象非终结符表达式public abstract class NonTerminalExpression implements Expression&#123; Expression e1,e2; public NonTerminalExpression(Expression e1, Expression e2)&#123; this.e1 = e1; this.e2 = e2; &#125;&#125;//减法表达式实现类public class MinusOperation extends NonTerminalExpression &#123; public MinusOperation(Expression e1, Expression e2) &#123; super(e1, e2); &#125; //将两个表达式相减 @Override public int interpreter(Context context) &#123; return this.e1.interpreter(context) - this.e2.interpreter(context); &#125;&#125;public class PlusOperation extends NonTerminalExpression &#123; public PlusOperation(Expression e1, Expression e2) &#123; super(e1, e2); &#125; //将两个表达式相加 @Override public int interpreter(Context context) &#123; return this.e1.interpreter(context) + this.e2.interpreter(context); &#125;&#125;//终结符表达式(终结符表达式)public class TerminalExpression implements Expression&#123; String variable; public TerminalExpression(String variable)&#123; this.variable = variable; &#125; @Override public int interpreter(Context context) &#123; return context.lookup(this); &#125;&#125;//下文类public class Context &#123; private Map&lt;Expression, Integer&gt; map = new HashMap&lt;&gt;(); //定义变量 public void add(Expression s, Integer value)&#123; map.put(s, value); &#125; //将变量转换成数字 public int lookup(Expression s)&#123; return map.get(s); &#125;&#125;public class TestClient &#123; public static void main(String[] args) &#123; Context context = new Context(); TerminalExpression a = new TerminalExpression(&quot;a&quot;); TerminalExpression b = new TerminalExpression(&quot;b&quot;); TerminalExpression c = new TerminalExpression(&quot;c&quot;); context.add(a, 4); context.add(b, 8); context.add(c, 2); System.out.println(new MinusOperation(new PlusOperation(a,b), c).interpreter(context)); &#125;&#125; 3 优缺点优点： 可扩展性比较好，灵活。 增加了新的解释表达式的方式。 易于实现简单文法。 缺点： 可利用场景比较少。 对于复杂的文法比较难维护。 解释器模式会引起类膨胀。 解释器模式采用递归调用方法。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"021.行为型模式_观察者模式","slug":"021-行为型模式-观察者模式","date":"2018-04-22T07:18:00.000Z","updated":"2024-03-12T01:06:15.822Z","comments":true,"path":"uncategorized/021-行为型模式-观察者模式/","link":"","permalink":"http://wanke.fun/uncategorized/021-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 概述又被称为发布-订阅（Publish&#x2F;Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。 在观察者模式中有如下角色： Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。 ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。 Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。 ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。 2 例子订阅新闻，新闻有更新，订阅者就会收到通知。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//观察者public interface Observer &#123; void update(String msg);&#125;//具体观察者public class User implements Observer &#123; private String name; public User(String name) &#123; this.name = name; &#125; @Override public void update(String msg) &#123; System.out.println(&quot;尊敬的&quot; + name + &quot;：&quot; + msg); &#125;&#125;//抽象被观察者public interface Subject &#123; //增加订阅者 void attach(Observer observer); //删除订阅者 void detach(Observer observer); //通知订阅者更新消息 void notify(String message);&#125;//具体被观察者public class SubscriptionSubject implements Subject &#123; private List&lt;Observer&gt; users = new ArrayList&lt;&gt;(); @Override public void attach(Observer observer) &#123; users.add(observer); &#125; @Override public void detach(Observer observer) &#123; users.remove(observer); &#125; @Override public void notify(String message) &#123; //通知给订阅者 for (Observer observer : users) &#123; observer.update(message); &#125; &#125;&#125;//客户端public class TestClient &#123; public static void main(String[] args) &#123; final User aa = new User(&quot;AA&quot;); final User bb = new User(&quot;BB&quot;); final SubscriptionSubject subscriptionSubject = new SubscriptionSubject(); subscriptionSubject.attach(aa); subscriptionSubject.attach(bb); subscriptionSubject.notify(&quot;订阅更新了&quot;); &#125;&#125; 3 优缺点优点： 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。 被观察者发送通知，所有注册的观察者都会收到信息 - 可以实现广播机制 缺点： 如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时 如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃","categories":[],"tags":[],"author":"师学"},{"title":"022.行为型模式_中介者模式","slug":"022-行为型模式-中介者模式","date":"2018-04-22T07:18:00.000Z","updated":"2024-03-12T01:06:15.822Z","comments":true,"path":"设计模式/022-行为型模式-中介者模式/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/022-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 概述又叫调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。 中介者模式包含以下主要角色： 抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。 具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。 抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。 具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。 2 例子租客通过房屋中介获取租房信息，房主通过房屋中介发布要出租的房子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//抽象同事类public abstract class Person &#123; protected String name; protected Mediator mediator; public Person(String name, Mediator mediator) &#123; this.name = name; this.mediator = mediator; &#125;&#125;//抽象中介者public abstract class Mediator &#123; //申明一个联络方法 public abstract void contact(String message, Person person);&#125;//具体同事类 房主public class HouseOwner extends Person &#123; public HouseOwner(String name, Mediator mediator) &#123; super(name, mediator); &#125; //与中介者联系 public void constact(String message) &#123; mediator.contact(message, this); &#125; //获取信息 public void getMessage(String message) &#123; System.out.println(&quot;房主&quot; + name + &quot;获取到的信息：&quot; + message); &#125;&#125;//具体同事类 租房者public class Tenant extends Person &#123; public Tenant(String name, Mediator mediator) &#123; super(name, mediator); &#125; //与中介者联系 public void constact(String message) &#123; mediator.contact(message, this); &#125; //获取信息 public void getMessage(String message) &#123; System.out.println(&quot;租房者&quot; + name + &quot;获取到的信息：&quot; + message); &#125;&#125;//中介public class MediatorStructure extends Mediator &#123; //首先中介结构必须知道所有房主和租房者的信息 private HouseOwner houseOwner; private Tenant tenant; public HouseOwner getHouseOwner() &#123; return houseOwner; &#125; public void setHouseOwner(HouseOwner houseOwner) &#123; this.houseOwner = houseOwner; &#125; public Tenant getTenant() &#123; return tenant; &#125; public void setTenant(Tenant tenant) &#123; this.tenant = tenant; &#125; public void contact(String message, Person person) &#123; if (person == houseOwner) &#123; //如果是房主，则租房者获得信息 tenant.getMessage(message); &#125; else &#123; //否则是房主获得信息 houseOwner.getMessage(message); &#125; &#125;&#125;public class TestClient &#123; public static void main(String[] args) &#123; final MediatorStructure structure = new MediatorStructure(); final HouseOwner aa = new HouseOwner(&quot;AA&quot;, structure); final Tenant bb = new Tenant(&quot;BB&quot;, structure); structure.setHouseOwner(aa); structure.setTenant(bb); aa.contact(&quot;押一付三，每月1500元&quot;); bb.contact(&quot;1500元左右的房子&quot;); &#125;&#125; 3 优缺点优点： 松散耦合 中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦合，基本上可以做到互补依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样“牵一处而动全身”了。 集中控制交互 多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以了，当然如果是已经做好的系统，那么就扩展中介者对象，而各个同事类不需要做修改。 一对多关联转变为一对一的关联 没有使用中介者模式的时候，同事对象之间的关系通常是一对多的，引入中介者对象以后，中介者对象和同事对象的关系通常变成双向的一对一，这会让对象的关系更容易理解和实现。 缺点： 当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"023.行为型模式_迭代器模式","slug":"023-行为型模式-迭代器模式","date":"2018-04-22T07:18:00.000Z","updated":"2024-03-12T01:06:15.822Z","comments":true,"path":"设计模式/023-行为型模式-迭代器模式/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/023-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 概述提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 迭代器模式主要包含以下角色： 抽象聚合（Aggregate）角色：定义存储、添加、删除聚合元素以及创建迭代器对象的接口。 具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。 抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、next() 等方法。 具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。 2 例子定义一个可以存储学生对象的容器对象，将遍历该容器的功能交由迭代器实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class Student &#123; private String name; public Student(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125;//迭代器接口public interface StudentIterator &#123; boolean hasNext(); Student next();&#125;//具体的迭代器类public class StudentIteratorImpl implements StudentIterator &#123; private List&lt;Student&gt; list; private int position = 0; public StudentIteratorImpl(List&lt;Student&gt; list) &#123; this.list = list; &#125; @Override public boolean hasNext() &#123; return position &lt; list.size(); &#125; @Override public Student next() &#123; Student currentStudent = list.get(position); position++; return currentStudent; &#125;&#125;//定义抽象容器类，包含添加元素，删除元素，获取迭代器对象的方法public interface StudentAggregate &#123; void addStudent(Student student); void removeStudent(Student student); StudentIterator getStudentIterator();&#125;//具体的容器类public class StudentAggregateImpl implements StudentAggregate &#123; private List&lt;Student&gt; list = new ArrayList&lt;&gt;(); // 学生列表 @Override public void addStudent(Student student) &#123; this.list.add(student); &#125; @Override public void removeStudent(Student student) &#123; this.list.remove(student); &#125; @Override public StudentIterator getStudentIterator() &#123; return new StudentIteratorImpl(list); &#125;&#125;public class TestClient &#123; public static void main(String[] args) &#123; final StudentAggregateImpl aggregate = new StudentAggregateImpl(); aggregate.addStudent(new Student(&quot;AA&quot;)); aggregate.addStudent(new Student(&quot;BB&quot;)); final StudentIterator iterator = aggregate.getStudentIterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next().toString()); &#125; &#125;&#125; 3 优缺点优点： 它支持以不同的方式遍历一个聚合对象。 迭代器简化了聚合类。 在同一个聚合上可以有多个遍历。 在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。 缺点： 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"024.行为型模式_访问者模式","slug":"024-行为型模式-访问者模式","date":"2018-04-22T07:18:00.000Z","updated":"2024-03-12T01:06:15.822Z","comments":true,"path":"设计模式/024-行为型模式-访问者模式/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/024-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 概述封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作，主要将数据结构与数据操作分离。 访问者模式包含以下主要角色: 抽象访问者（Visitor）角色：定义了对每一个元素（Element）访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素类个数（Element的实现类个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变。 具体访问者（ConcreteVisitor）角色：给出对每一个元素类访问时所产生的具体行为。 抽象元素（Element）角色：定义了一个接受访问者的方法（accept），其意义是指，每一个元素都要可以被访问者访问。 具体元素（ConcreteElement）角色： 提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。 对象结构（Object Structure）角色：定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素（Element），并且可以迭代这些元素，供访问者访问。 2 例子给宠物喂食，主人可以喂，其他人也可以喂。 访问者角色：给宠物喂食的人 具体访问者角色：主人、其他人 抽象元素角色：动物抽象类 具体元素角色：宠物狗、宠物猫 结构对象角色：主人家 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//创建抽象访问者接口public interface Person &#123; void feed(Cat cat); void feed(Dog dog);&#125;//创建不同的具体访问者角色（主人和其他人），都需要实现 Person接口public class Owner implements Person &#123; @Override public void feed(Cat cat) &#123; System.out.println(&quot;主人喂食猫&quot;); &#125; @Override public void feed(Dog dog) &#123; System.out.println(&quot;主人喂食狗&quot;); &#125;&#125;public class Someone implements Person &#123; @Override public void feed(Cat cat) &#123; System.out.println(&quot;其他人喂食猫&quot;); &#125; @Override public void feed(Dog dog) &#123; System.out.println(&quot;其他人喂食狗&quot;); &#125;&#125;//定义抽象节点 -- 宠物public interface Animal &#123; void accept(Person person);&#125;//定义实现Animal接口的 具体节点（元素）public class Dog implements Animal &#123; @Override public void accept(Person person) &#123; person.feed(this); System.out.println(&quot;好好吃，汪汪汪！！！&quot;); &#125;&#125;public class Cat implements Animal &#123; @Override public void accept(Person person) &#123; person.feed(this); System.out.println(&quot;好好吃，喵喵喵！！！&quot;); &#125;&#125;public class Home &#123; private List&lt;Animal&gt; nodeList = new ArrayList&lt;Animal&gt;(); public void action(Person person) &#123; for (Animal node : nodeList) &#123; node.accept(person); &#125; &#125; //添加操作 public void add(Animal animal) &#123; nodeList.add(animal); &#125;&#125;public class TestClient &#123; public static void main(String[] args) &#123; Home home = new Home(); home.add(new Dog()); home.add(new Cat()); Owner owner = new Owner(); home.action(owner); Someone someone = new Someone(); home.action(someone); &#125;&#125; 3 优缺点优点： 符合单一职责原则 优秀的扩展性 灵活性非常高 缺点： 具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的 具体元素变更比较困难 违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"020.行为型模式_状态模式","slug":"020-行为型模式-状态模式","date":"2018-04-22T07:17:00.000Z","updated":"2024-03-12T01:06:15.822Z","comments":true,"path":"设计模式/020-行为型模式-状态模式/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/020-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 概述对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。 角色： 环境（Context）角色：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。 抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。 具体状态（Concrete State）角色：实现抽象状态所对应的行为。 2 案例通过按钮来控制一个电梯的状态，一个电梯有开门状态，关门状态，停止状态，运行状态。每一种状态改变，都有可能要根据其他状态来更新处理。例如，如果电梯门现在处于运行时状态，就不能进行开门操作，而如果电梯门是停止状态，就可以执行开门操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184public abstract class LiftState &#123; //定义一个环境角色，也就是封装状态的变化引起的功能变化 protected Context context; public void setContext(Context context) &#123; this.context = context; &#125; //电梯开门动作 public abstract void open(); //电梯关门动作 public abstract void close(); //电梯运行动作 public abstract void run(); //电梯停止动作 public abstract void stop();&#125;//开启状态public class OpenState extends LiftState &#123; //开启当然可以关闭了，我就想测试一下电梯门开关功能 @Override public void open() &#123; System.out.println(&quot;电梯门开启...&quot;); &#125; @Override public void close() &#123; //状态修改 super.context.setLiftState(Context.CLOSE_STATE); //动作委托为CloseState来执行，也就是委托给了CloseState子类执行这个动作 super.context.close(); &#125; //电梯门不能开着就跑，这里什么也不做 @Override public void run() &#123; //do nothing &#125; //开门状态已经是停止的了 @Override public void stop() &#123; //do nothing &#125;&#125;//关闭状态public class CloseState extends LiftState &#123; @Override //电梯门关闭，这是关闭状态要实现的动作 public void close() &#123; System.out.println(&quot;电梯门关闭...&quot;); &#125; //电梯门关了再打开，逗你玩呢，那这个允许呀 @Override public void open() &#123; super.context.setLiftState(Context.OPEN_STATE); super.context.open(); &#125; //电梯门关了就跑，这是再正常不过了 @Override public void run() &#123; super.context.setLiftState(Context.RUN_STATE); super.context.run(); &#125; //电梯门关着，我就不按楼层 @Override public void stop() &#123; super.context.setLiftState(Context.STOP_STATE); super.context.stop(); &#125;&#125;//运行状态public class RunState extends LiftState &#123; //运行的时候开电梯门？你疯了！电梯不会给你开的 @Override public void open() &#123; //do nothing &#125; //电梯门关闭？这是肯定了 @Override public void close() &#123;//虽然可以关门，但这个动作不归我执行 //do nothing &#125; //这是在运行状态下要实现的方法 @Override public void run() &#123; System.out.println(&quot;电梯正在运行...&quot;); &#125; //这个事绝对是合理的，光运行不停止还有谁敢做这个电梯？！估计只有上帝了 @Override public void stop() &#123; super.context.setLiftState(Context.STOP_STATE); super.context.getLiftState().stop(); &#125;&#125;//停止状态public class StopState extends LiftState &#123; //停止状态，开门，那是要的！ @Override public void open() &#123; //状态修改 super.context.setLiftState(Context.OPEN_STATE); //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作 super.context.open(); &#125; @Override public void close() &#123;//虽然可以关门，但这个动作不归我执行 //状态修改 super.context.setLiftState(Context.CLOSE_STATE); //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作 super.context.close(); &#125; //停止状态再跑起来，正常的很 @Override public void run() &#123; //状态修改 super.context.setLiftState(Context.RUN_STATE); //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作 super.context.run(); &#125; //停止状态是怎么发生的呢？当然是停止方法执行了 @Override public void stop() &#123; System.out.println(&quot;电梯停止了...&quot;); &#125;&#125;//环境角色public class Context &#123; //定义出所有的电梯状态 public final static OpenState OPEN_STATE = new OpenState();//开门状态，这时候电梯只能关闭 public final static CloseState CLOSE_STATE = new CloseState();//关闭状态，这时候电梯可以运行、停止和开门 public final static RunState RUN_STATE = new RunState();//运行状态，这时候电梯只能停止 public final static StopState STOP_STATE = new StopState();//停止状态，这时候电梯可以开门、运行 //定义一个当前电梯状态 private LiftState liftState; public LiftState getLiftState() &#123; return this.liftState; &#125; public void setLiftState(LiftState liftState) &#123; //当前环境改变 this.liftState = liftState; //把当前的环境通知到各个实现类中 this.liftState.setContext(this); &#125; public void open() &#123; this.liftState.open(); &#125; public void close() &#123; this.liftState.close(); &#125; public void run() &#123; this.liftState.run(); &#125; public void stop() &#123; this.liftState.stop(); &#125;&#125;public class TestClient &#123; public static void main(String[] args) &#123; final Context context = new Context(); context.setLiftState(new CloseState()); context.open(); context.close(); context.run(); context.stop(); &#125;&#125; 3 优缺点优点： 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 缺点： 状态模式的使用必然会增加系统类和对象的个数。 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 状态模式对”开闭原则”的支持并不太好。 4 使用场景 当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。 一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"018.行为型模式_命令模式","slug":"018-行为型模式-命令模式","date":"2018-04-22T07:16:00.000Z","updated":"2024-03-12T01:06:15.822Z","comments":true,"path":"设计模式/018-行为型模式-命令模式/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/018-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 概述将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。 命令模式包含以下主要角色： 抽象命令类（Command）角色： 定义命令的接口，声明执行的方法。 具体命令（Concrete Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。 实现者&#x2F;接收者（Receiver）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。 调用者&#x2F;请求者（Invoker）角色： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。 2 例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//接收者：真正执行命令的对象public class Receiver &#123; public void action()&#123; System.out.println(&quot;命令执行了.......&quot;); &#125;&#125;//抽象命令类：抽象的命令，可以根据不同类型的命令写出不同的实现public interface ICommand &#123; //调用命令 void execute();&#125;//具体命令类class ConcreteCommand implements ICommand&#123; private Receiver receiver;//持有真正执行命令对象的引用 public ConcreteCommand(Receiver receiver) &#123; super(); this.receiver = receiver; &#125; @Override public void execute() &#123; //调用接收者执行命令的方法 receiver.action(); &#125;&#125;//请求者/调用者：发起执行命令请求的对象public class Invoker &#123; private ICommand command;//持有命令对象的引用 public Invoker(ICommand command) &#123; super(); this.command = command; &#125; public void call() &#123; //请求者调用命令对象执行命令的那个execute方法 command.execute(); &#125;&#125;public class TestClient &#123; public static void main(String[] args) &#123; //通过请求者（invoker）调用命令对象（command），命令对象中调用了命令具体执行者（Receiver） ICommand command = new ConcreteCommand(new Receiver()); Invoker invoker = new Invoker(command); invoker.call(); &#125;&#125; 3 优缺点优点： 降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。 增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。 可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。 方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。 缺点： 使用命令模式可能会导致某些系统有过多的具体命令类。 系统结构更加复杂。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"019.行为型模式_职责链模式","slug":"019-行为型模式-职责链模式","date":"2018-04-22T07:16:00.000Z","updated":"2024-03-12T01:06:15.822Z","comments":true,"path":"设计模式/019-行为型模式-职责链模式/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/019-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 概述又称职责链模式（击鼓传花），为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。 职责链模式主要包含以下角色: 抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。 客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。 2 例子请假流程控制系统，请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需要部门经理同意；请求3天到7天还需要总经理同意才行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148//请假public class LeaveRequest &#123; //姓名 private String name; //天数 private int num; //内容 private String content; public LeaveRequest(String name, int num, String content) &#123; this.name = name; this.num = num; this.content = content; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getNum() &#123; return num; &#125; public void setNum(int num) &#123; this.num = num; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125;//总经理public class GeneralManager extends Handler &#123; public GeneralManager() &#123; //部门经理处理7天以上的请假 super(Handler.NUM_SEVEN); &#125; @Override protected void handleLeave(LeaveRequest leave) &#123; System.out.println(leave.getName() + &quot;请假&quot; + leave.getNum() + &quot;天,&quot; + leave.getContent() + &quot;。&quot;); System.out.println(&quot;总经理审批：同意。&quot;); &#125;&#125;//部门经理public class Manager extends Handler &#123; public Manager() &#123; //部门经理处理3-7天的请假 super(Handler.NUM_THREE, Handler.NUM_SEVEN); &#125; @Override protected void handleLeave(LeaveRequest leave) &#123; System.out.println(leave.getName() + &quot;请假&quot; + leave.getNum() + &quot;天,&quot; + leave.getContent() + &quot;。&quot;); System.out.println(&quot;部门经理审批：同意。&quot;); &#125;&#125;//小组长public class GroupLeader extends Handler &#123; public GroupLeader() &#123; //小组长处理1-3天的请假 super(Handler.NUM_ONE, Handler.NUM_THREE); &#125; @Override protected void handleLeave(LeaveRequest leave) &#123; System.out.println(leave.getName() + &quot;请假&quot; + leave.getNum() + &quot;天,&quot; + leave.getContent() + &quot;。&quot;); System.out.println(&quot;小组长审批：同意。&quot;); &#125;&#125;//处理者抽象类public abstract class Handler &#123; protected final static int NUM_ONE = 1; protected final static int NUM_THREE = 3; protected final static int NUM_SEVEN = 7; //该领导处理的请假天数区间 private int numStart; private int numEnd; //领导上面还有领导 private Handler nextHandler; //设置请假天数范围 上不封顶 public Handler(int numStart) &#123; this.numStart = numStart; &#125; //设置请假天数范围 public Handler(int numStart, int numEnd) &#123; this.numStart = numStart; this.numEnd = numEnd; &#125; //设置上级领导 public void setNextHandler(Handler nextHandler) &#123; this.nextHandler = nextHandler; &#125; //提交请假条 public final void submit(LeaveRequest leave) &#123; if (0 == this.numStart) &#123; return; &#125; //如果请假天数达到该领导者的处理要求 if (leave.getNum() &gt;= this.numStart) &#123; this.handleLeave(leave); //如果还有上级 并且请假天数超过了当前领导的处理范围 if (null != this.nextHandler &amp;&amp; leave.getNum() &gt; numEnd) &#123; this.nextHandler.submit(leave);//继续提交 &#125; else &#123; System.out.println(&quot;流程结束&quot;); &#125; &#125; &#125; //各级领导处理请假条方法 protected abstract void handleLeave(LeaveRequest leave);&#125;public class TestClient &#123; public static void main(String[] args) &#123; //请假条 LeaveRequest leave = new LeaveRequest(&quot;小明&quot;, 5, &quot;婚假&quot;); //各位领导 GroupLeader groupLeader = new GroupLeader(); Manager manager = new Manager(); GeneralManager generalManager = new GeneralManager(); groupLeader.setNextHandler(manager);//小组长的领导是部门经理 manager.setNextHandler(generalManager);//部门经理的领导是总经理 //提交申请 groupLeader.submit(leave); &#125;&#125; 3 优缺点优点： 降低耦合度。它将请求的发送者和接收者解耦。 简化了对象。使得对象不需要知道链的结构。 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 增加新的请求处理类很方便。 缺点： 不能保证请求一定被接收。 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 可能不容易观察运行时的特征，有碍于除错。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"016.行为型模式_模板模式","slug":"016-行为型模式-模板模式","date":"2018-04-22T07:15:00.000Z","updated":"2024-03-12T01:06:15.822Z","comments":true,"path":"设计模式/016-行为型模式-模板模式/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/016-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 概述定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。 模板方法（Template Method）模式包含以下主要角色： 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。 基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种： 抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。 具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。 钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。 一般钩子方法是用于判断的逻辑方法，这类方法名一般为 isXxx，返回值类型为boolean类型。 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。 2 例子打游戏有一般先初始化游戏、开始游戏、结束游戏。 123456789101112131415161718192021222324252627282930313233343536373839404142public abstract class Game &#123; public abstract void initialize(); public abstract void startPlay(); public abstract void endPlay(); //模板 public final void play() &#123; //初始化游戏 initialize(); //开始游戏 startPlay(); //结束游戏 endPlay(); &#125;&#125;public class Honor extends Game &#123; @Override void endPlay() &#123; System.out.println(&quot;王者荣耀结束&quot;); &#125; @Override void initialize() &#123; System.out.println(&quot;王者荣耀初始化&quot;); &#125; @Override void startPlay() &#123; System.out.println(&quot;王者荣耀开始&quot;); &#125;&#125;public class TestClient &#123; public static void main(String[] args) &#123; final Honor honor = new Honor(); honor.play(); &#125;&#125; 3 优缺点优点 提高代码复用性 将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。 实现了反向控制 通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。 缺点 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"017.行为型模式_策略模式","slug":"017-行为型模式-策略模式","date":"2018-04-22T07:15:00.000Z","updated":"2024-03-12T01:06:15.822Z","comments":true,"path":"设计模式/017-行为型模式-策略模式/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/017-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 概述该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。 策略模式的主要角色如下： 抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。 环境（Context）类：持有一个策略类的引用，最终给客户端调用。 2 例子百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。 1234567891011121314151617181920212223242526272829303132333435363738394041//抽象策略public interface Strategy &#123; void show();&#125;//具体策略角色//为春节准备的促销活动Apublic class StrategyA implements Strategy &#123; public void show() &#123; System.out.println(&quot;买一送一&quot;); &#125;&#125;//为中秋准备的促销活动Bpublic class StrategyB implements Strategy &#123; public void show() &#123; System.out.println(&quot;满200元减50元&quot;); &#125;&#125;//为圣诞准备的促销活动Cpublic class StrategyC implements Strategy &#123; public void show() &#123; System.out.println(&quot;满1000元加一元换购任意200元以下商品&quot;); &#125;&#125;//环境角色（Context）public class SalesMan &#123; //抽象策略角色的引用 private Strategy strategy; public SalesMan(Strategy strategy) &#123; this.strategy = strategy; &#125; //向客户展示促销活动 public void salesManShow()&#123; strategy.show(); &#125; &#125; 3 优缺点优点： 策略类之间可以自由切换 由于策略类都实现同一个接口，所以使它们之间可以自由切换。 易于扩展 增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“ 避免使用多重条件选择语句（if else），充分体现面向对象设计思想。 缺点： 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"015.结构型模式_桥接模式","slug":"015-结构型模式-桥接模式","date":"2018-04-22T07:14:00.000Z","updated":"2024-03-12T01:06:15.822Z","comments":true,"path":"设计模式/015-结构型模式-桥接模式/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/015-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 概述将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 桥接（Bridge）模式包含以下主要角色： 抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。 扩展抽象化（Refined Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。 实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。 具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。 2 例子需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。 类图如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//视频文件public interface VideoFile &#123; void decode(String fileName);&#125;//avi文件public class AVIFile implements VideoFile &#123; public void decode(String fileName) &#123; System.out.println(&quot;avi视频文件：&quot;+ fileName); &#125;&#125;//rmvb文件public class REVBBFile implements VideoFile &#123; public void decode(String fileName) &#123; System.out.println(&quot;rmvb文件：&quot; + fileName); &#125;&#125;//操作系统版本public abstract class OperatingSystemVersion &#123; protected VideoFile videoFile; public OperatingSystemVersion(VideoFile videoFile) &#123; this.videoFile = videoFile; &#125; public abstract void play(String fileName);&#125;//Windows版本public class Windows extends OperatingSystem &#123; public Windows(VideoFile videoFile) &#123; super(videoFile); &#125; public void play(String fileName) &#123; videoFile.decode(fileName); &#125;&#125;//mac版本public class Mac extends OperatingSystemVersion &#123; public Mac(VideoFile videoFile) &#123; super(videoFile); &#125; public void play(String fileName) &#123; videoFile.decode(fileName); &#125;&#125;//测试类public class TestClient &#123; public static void main(String[] args) &#123; OperatingSystem os = new Windows(new AVIFile()); os.play(&quot;战狼3&quot;); &#125;&#125; 3 优缺点 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。 如：如果现在还有一种视频文件类型 wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。 实现细节对客户透明 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时，适合使用桥接模式。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"014.结构型模式_组合模式","slug":"014-结构型模式-组合模式","date":"2018-04-22T07:12:00.000Z","updated":"2024-03-12T01:06:15.822Z","comments":true,"path":"设计模式/014-结构型模式-组合模式/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/014-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 概述又称为部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。属于结构型模式，它创建了对象组的树形结构。 组合模式主要包含三种角色： 抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。 树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。 叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。 分类： 透明组合模式：抽象根节点角色中声明了所有用于管理成员对象的方法，add，remove 等。 安全组合模式：抽象构件角色中没有声明任何用于管理成员对象的方法。 2 例子一个公司组织架构，有许多员工，员工有上下级关系。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class Employee &#123; private String name; private List&lt;Employee&gt; employees; public Employee(String name) &#123; this.name = name; employees = new ArrayList&lt;&gt;(); &#125; public String getName() &#123; return name; &#125; public void add(Employee employee) &#123; employees.add(employee); &#125; public void remove(Employee employee) &#123; employees.remove(employee); &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;Employee&gt; getEmployees() &#123; return employees; &#125; public void setEmployees(List&lt;Employee&gt; employees) &#123; this.employees = employees; &#125; @Override public String toString() &#123; return &quot;Employee&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, employees=&quot; + employees + &#x27;&#125;&#x27;; &#125;&#125;public class TestClient &#123; public static void main(String[] args) &#123; final Employee a = new Employee(&quot;总裁&quot;); final Employee b1 = new Employee(&quot;人事经理&quot;); final Employee b2 = new Employee(&quot;财务经理&quot;); final Employee c1 = new Employee(&quot;人事专员1&quot;); final Employee c2 = new Employee(&quot;人事专员2&quot;); a.add(b1); a.add(b2); b1.add(c1); b1.add(c2); System.out.println(a); for (Employee employee : a.getEmployees()) &#123; System.out.println(employee); for (Employee sub : employee.getEmployees()) &#123; System.out.println(sub); &#125; &#125; &#125;&#125; 3 优缺点 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。 在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"013.结构性模式_享元模式","slug":"013-结构性模式-享元模式","date":"2018-04-22T07:11:00.000Z","updated":"2024-03-12T01:06:15.822Z","comments":true,"path":"设计模式/013-结构性模式-享元模式/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/013-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 概述运用共享技术（共享对象）来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。 享元（Flyweight ）模式中存在以下两种状态： 内部状态，即不会随着环境的改变而改变的可共享部分。 外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。 享元模式的主要有以下角色： 抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。 具体享元（Concrete Flyweight）角色 ：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。 非享元（Unsharable Flyweight)角色 ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。 享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。 2 例子俄罗斯方块有不同的形状，每个不同的方块都是一个实例对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public abstract class AbstractBox &#123; public abstract String getShape(); public void display(String color) &#123; System.out.println(&quot;方块形状：&quot; + this.getShape() + &quot; 颜色：&quot; + color); &#125;&#125;public class IBox extends AbstractBox &#123; @Override public String getShape() &#123; return &quot;I&quot;; &#125;&#125;public class LBox extends AbstractBox &#123; @Override public String getShape() &#123; return &quot;L&quot;; &#125;&#125;public class OBox extends AbstractBox &#123; @Override public String getShape() &#123; return &quot;O&quot;; &#125;&#125;//创建一个工厂类public class BoxFactory &#123; private static HashMap&lt;&gt; map; private BoxFactory() &#123; map = new HashMap&lt;String, AbstractBox&gt;(); AbstractBox iBox = new IBox(); AbstractBox lBox = new LBox(); AbstractBox oBox = new OBox(); map.put(&quot;I&quot;, iBox); map.put(&quot;L&quot;, lBox); map.put(&quot;O&quot;, oBox); &#125; public static final BoxFactory getInstance() &#123; return SingletonHolder.INSTANCE; &#125; private static class SingletonHolder &#123; private static final BoxFactory INSTANCE = new BoxFactory(); &#125; public AbstractBox getBox(String key) &#123; return map.get(key); &#125;&#125; 3 优缺点优点： 极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能 享元模式中的外部状态相对独立，且不影响内部状态 缺点： 为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"012.结构型模式_外观模式","slug":"012-结构型模式-外观模式","date":"2018-04-22T07:10:00.000Z","updated":"2024-03-12T01:06:15.822Z","comments":true,"path":"设计模式/012-结构型模式-外观模式/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/012-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 概述又叫门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。 外观（Facade）模式包含以下主要角色： 外观（Facade）角色：为多个子系统对外提供一个共同的接口。 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。 2 例子启动一台电脑，电脑内部，包括 CPU 启动、硬盘启动、内存启动等，但是我们无需关心这些细节，电脑自提供一个开机的方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//电脑接口public interface Computer &#123; void open();&#125;//CPUpublic class Cpu implements Computer &#123; @Override public void open() &#123; System.out.println(&quot;启动CPU&quot;); &#125;&#125;//硬盘public class Ssd implements Computer &#123; @Override public void open() &#123; System.out.println(&quot;启动硬盘&quot;); &#125;&#125;//内存public class Ddr implements Computer &#123; @Override public void open() &#123; System.out.println(&quot;启动内存&quot;); &#125;&#125;//外观类public class Facade &#123; private Computer cpu; private Computer ddr; private Computer ssd; public Facade() &#123; cpu = new Cpu(); ddr = new Ddr(); ssd = new Ssd(); &#125; public void open() &#123; cpu.open(); ddr.open(); ssd = new Ssd(); &#125;&#125;public class TestClient &#123; public static void main(String[] args) &#123; //创建外观对象 Facade facade = new Facade(); //客户端直接与外观对象进行交互 facade.open(); &#125;&#125; 3 优缺点优点： 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。 缺点： 不符合开闭原则，修改很麻烦。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"009.结构型模式_代理模式","slug":"009-结构型模式-代理模式","date":"2018-04-22T07:09:00.000Z","updated":"2024-03-12T01:06:15.821Z","comments":true,"path":"设计模式/009-结构型模式-代理模式/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/009-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 概述由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。 代理（Proxy）模式分为三种角色： 抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。 真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。 代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。 为其他对象提供一种代理以控制对这个对象的访问（代理类相当于一个中介）。 2 静态代理12345678910111213141516171819202122232425262728//卖票接口public interface SellTickets &#123; void sell();&#125;//火车站 火车站具有卖票功能，需要实现 SellTickets 接口public class TrainStation implements SellTickets &#123; public void sell() &#123; System.out.println(&quot;火车站卖票&quot;); &#125;&#125;//黄牛 黄牛也是卖票，需要实现 SellTickets 接口public class YellowCow implements SellTickets &#123; private TrainStation station = new TrainStation(); public void sell() &#123; System.out.println(&quot;黄牛收取服务费用&quot;); station.sell(); &#125;&#125;//测试类public class TestClient &#123; public static void main(String[] args) &#123; YellowCow yc = new YellowCow(); yc.sell(); &#125;&#125; 代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。 但是有弊端，假如这人不仅不仅要面膜，还要核导弹、航空母舰等等，就创建了许多代理类。 3 JDK动态代理123456789101112131415161718192021222324252627282930313233343536373839//代理工厂，用来创建代理对象public class ProxyFactory &#123; private TrainStation station = new TrainStation(); public SellTickets getProxyObject() &#123; //使用Proxy获取代理对象 /* *ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可 *Class&lt;?&gt;[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口 *InvocationHandler h ： 代理对象的调用处理程序 */ SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(), station.getClass().getInterfaces(), new InvocationHandler() &#123; /* *proxy ： 代理对象 *method ： 对应于在代理对象上调用的接口方法的 Method 实例 *args ： 代理对象调用接口方法时传递的实际参数 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;JDK动态代理：代理点收取一些服务费用&quot;); //执行真实对象 Object result = method.invoke(station, args); return result; &#125; &#125;); return sellTickets; &#125;&#125;//测试类public class TestClient &#123; public static void main(String[] args) &#123; //获取代理对象 ProxyFactory factory = new ProxyFactory(); SellTickets st = factory.getProxyObject(); st.sell(); &#125;&#125; 由于使用了反射，效率比较低。 4 CGLIB动态代理使用 JDK动态代理 必须定义一个接口，如果没有只定义一个类，就需要使用 CGLIB。 12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//火车站public class TrainStation &#123; public void sell() &#123; System.out.println(&quot;火车站卖票&quot;); &#125;&#125;//代理工厂public class ProxyFactory implements MethodInterceptor &#123; private TrainStation target = new TrainStation(); public TrainStation getProxyObject() &#123; //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数 Enhancer enhancer =new Enhancer(); //设置父类的字节码对象 enhancer.setSuperclass(target.getClass()); //设置回调函数 enhancer.setCallback(this); //创建代理对象 TrainStation obj = (TrainStation) enhancer.create(); return obj; &#125; /* *o ： 代理对象 *method ： 真实对象中的方法的Method实例 *args ： 实际参数 *methodProxy ：代理对象中的方法的method实例 */ public TrainStation intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; System.out.println(&quot;CGLIB动态代理:代理点收取一些服务费用&quot;); TrainStation result = (TrainStation) methodProxy.invokeSuper(o, args); return result; &#125;&#125;//测试类public class TestClient &#123; public static void main(String[] args) &#123; //创建代理工厂对象 ProxyFactory factory = new ProxyFactory(); //获取代理对象 TrainStation proxyObject = factory.getProxyObject(); proxyObject.sell(); &#125;&#125; 5 代理对比 jdk 代理和 CGLIB 代理 CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在 JDK1.6 之前比使用 Java 反射效率要高。唯一需要注意的是，CGLib不能对声明为 final 的类或者方法进行代理，因为 CGLib 原理是动态生成被代理类的子类。 在 JDK1.6、JDK1.7、JDK1.8逐步对 JDK 动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib 代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。 动态代理和静态代理 动态代理：接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。 如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。 6 优缺点优点： 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用； 代理对象可以扩展目标对象的功能； 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度； 缺点： 增加了系统的复杂度；","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"010.结构型模式_装饰者模式","slug":"010-结构型模式-装饰者模式","date":"2018-04-22T07:09:00.000Z","updated":"2024-03-12T01:06:15.821Z","comments":true,"path":"设计模式/010-结构型模式-装饰者模式/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/010-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 概述在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。 装饰（Decorator）模式中的角色： 抽象构件（Component）角色 ：定义一个抽象接口以规范准备接收附加责任的对象。 具体构件（Concrete Component）角色 ：实现抽象构件，通过装饰角色为其添加一些职责。 抽象装饰（Decorator）角色 ： 继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。 具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。 2 例子快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，加配菜需要额外加钱，最后结账也不同。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//快餐接口public abstract class FastFood &#123; private float price; private String desc; public FastFood() &#123;&#125; public FastFood(float price, String desc) &#123; this.price = price; this.desc = desc; &#125; public void setPrice(float price) &#123; this.price = price; &#125; public float getPrice() &#123; return price; &#125; public String getDesc() &#123; return desc; &#125; public void setDesc(String desc) &#123; this.desc = desc; &#125; //获取价格 public abstract float cost();&#125;//普通炒饭public class FriedRice extends FastFood &#123; public FriedRice() &#123; super(10, &quot;炒饭&quot;); &#125; public float cost() &#123; return getPrice(); &#125;&#125;//配料类public abstract class Garnish extends FastFood &#123; private FastFood fastFood; public FastFood getFastFood() &#123; return fastFood; &#125; public void setFastFood(FastFood fastFood) &#123; this.fastFood = fastFood; &#125; public Garnish(FastFood fastFood, float price, String desc) &#123; super(price,desc); this.fastFood = fastFood; &#125;&#125;//鸡蛋配料public class Egg extends Garnish &#123; public Egg(FastFood fastFood) &#123; super(fastFood,1,&quot;鸡蛋&quot;); &#125; public float cost() &#123; return getPrice() + getFastFood().getPrice(); &#125; @Override public String getDesc() &#123; return super.getDesc() + getFastFood().getDesc(); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; //点一份炒饭 FastFood food = new FriedRice(); //花费的价格 System.out.println(food.getDesc() + &quot; &quot; + food.cost() + &quot;元&quot;); System.out.println(&quot;========&quot;); //点一份鸡蛋炒饭 FastFood food1 = new FriedRice(); food1 = new Egg(food1); //花费的价格 System.out.println(food1.getDesc() + &quot; &quot; + food1.cost() + &quot;元&quot;); &#125;&#125; 优点： 装饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。 装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。 4 代理和装饰者的区别静态代理和装饰者模式的区别： 相同点： 都要实现与目标类相同的业务接口 在两个类中都要声明目标对象 都可以在不修改目标类的前提下增强目标方法 不同点： 目的不同：装饰者是为了增强目标对象，静态代理是为了保护和隐藏目标对象； 获取目标对象构建的地方不同：装饰者是由外界传递进来，可以通过构造方法传递，静态代理是在代理类内部创建，以此来隐藏目标对象","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"011.结构型模式_桥接模式","slug":"011-结构型模式-桥接模式","date":"2018-04-22T07:09:00.000Z","updated":"2024-03-12T01:06:15.821Z","comments":true,"path":"设计模式/011-结构型模式-桥接模式/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/011-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 概述将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 桥接（Bridge）模式包含以下主要角色： 抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。 扩展抽象化（Refined Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。 实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。 具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"008.结构型模式_适配器模式","slug":"008-结构型模式-适配器模式","date":"2018-04-22T07:08:00.000Z","updated":"2024-03-12T01:06:15.821Z","comments":true,"path":"设计模式/008-结构型模式-适配器模式/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/008-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 适配器模式适配器模式(Adapter Pattern)：将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作，其别名为包装器(Wrapper)，属于结构型模式，主要分为三类：类适配器模式、对象适配器模式、接口适配器模式。 2 工作原理 适配器模式：将一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容。 从用户的角度看不到被适配者，是解耦的。 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法。 用户收到反馈结果，感觉只是和目标接口交互。 3 类适配器模式手机需要 5V（dst 目标）充电 ，现在有 220V 交流电（src 被适配者），需要转接头转成 5V（充电器）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//适配接口public interface IVoltage5V &#123; int output5V();&#125;public class Phone &#123; public void charging(IVoltage5V iVoltage5V)&#123; if (iVoltage5V.output5V() &gt; 5)&#123; System.out.println(&quot;不能充电&quot;); &#125;else if (iVoltage5V.output5V() == 5)&#123; System.out.println(&quot;可以充电&quot;); &#125; &#125;&#125;//被适配的类public class Voltage220V &#123; //输出 220V 的电压 public int output220V() &#123; int src = 220; System.out.println(&quot;电压 = &quot; + src + &quot;伏&quot;); return src; &#125;&#125;//适配器类public class VoltageAdapter extends Voltage220V implements IVoltage5V &#123; @Override public int output5V() &#123; int output220V = output220V(); //转换成 5v return output220V / 44; &#125;&#125;public class TestClient &#123; public static void main(String[] args) &#123; VoltageAdapter adapter = new VoltageAdapter(); Phone phone = new Phone(); phone.charging(adapter); &#125;&#125; Java 是单继承机制，所以类适配器需要继承 src 类这一点算是一个缺点, 因为这要求 dst 必须是接口，有一定局限性。 src 类的方法在 Adapter 中都会暴露出来，也增加了使用的成本。 由于其继承了 src 类，所以它可以根据需求重写 src 类的方法，使得 Adapter 的灵活性增强了。 4 对象适配器模式基本思路和类的适配器模式相同，只是将 Adapter 类作修改，不是继承 src 类，而是持有 src 类的实例，以解决兼容性的问题。 即：持有 src 类，实现 dst 类接口，完成 src -&gt; dst 的适配。 123456789101112131415public class ObjectVoltageAdapter implements IVoltage5V &#123; private Voltage220V voltage220V; public ObjectVoltageAdapter(Voltage220V voltage220)&#123; this.voltage220V = voltage220; &#125; @Override public int output5V() &#123; int output220V = voltage220V.output220V(); //转换成 5v return output220V / 44; &#125;&#125; 对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。 根据合成复用原则，使用组合替代继承， 所以它解决了类适配器必须继承 src 的局限性问题，也不再要求 dst必须是接口。 使用成本更低，更灵活。 5 接口适配器模式当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，适用于一个接口不想使用其所有的方法的情况。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"006.创建者模式_原型模式","slug":"006-创建者模式-原型模式","date":"2018-04-22T07:07:00.000Z","updated":"2024-03-12T01:06:15.821Z","comments":true,"path":"设计模式/006-创建者模式-原型模式/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/006-%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 原型模式指定创建对象的种类，并且通过拷贝这些原型，创建新的对象，是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节。这种模式现了一个原型接口，该接口用于创建当前对象的克隆。 原型模式的构成： Prototype : 原型类，声明一个克隆自己的接口 ConcretePrototype: 具体的原型类, 实现一个克隆自己的操作 Client: 让一个原型对象克隆自己，从而创建一个新的对象(属性一样） 2 例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//克隆羊public class Sheep implements Cloneable&#123; private String name; private int age; public Country country; //对象, 克隆是会如何处理, 默认是浅拷贝 public Sheep(String name, int age,Country country) &#123; this.name = name; this.age = age; this.country = country; &#125; @Override protected Object clone() &#123; Sheep sheep = null; try &#123; sheep = (Sheep)super.clone(); &#125;catch (Exception e)&#123; System.out.println(e.getMessage()); &#125; return sheep; &#125; @Override public String toString() &#123; return &quot;Sheep&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, country=&quot; + country + &quot;, countryHashCode=&quot; + country.hashCode() + &#x27;&#125;&#x27;; &#125; //省略 getter/setter&#125;public class Country implements Cloneable&#123; private String name; @Override protected Object clone() &#123; Country country = null; try &#123; country = (Country)super.clone(); &#125;catch (Exception e)&#123; System.out.println(e.getMessage()); &#125; return country; &#125; @Override public String toString() &#123; return &quot;Country&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; //省略 getter/setter&#125;public class Client &#123; public static void main(String[] args) &#123; Sheep sheep = new Sheep(&quot;多利羊&quot;, 3,new Country(&quot;美国&quot;)); Sheep sheep1 = (Sheep)sheep.clone(); Sheep sheep2 = (Sheep)sheep.clone(); Sheep sheep3 = (Sheep)sheep.clone(); Sheep sheep4 = (Sheep)sheep.clone(); System.out.println(&quot;sheep1 =&quot; + sheep1 ); System.out.println(&quot;sheep2 =&quot; + sheep2 ); System.out.println(&quot;sheep3 =&quot; + sheep3 ); System.out.println(&quot;sheep4 =&quot; + sheep4 ); &#125;&#125;//输出：//sheep1 =Sheep&#123;name=&#x27;多利羊&#x27;, age=3, country=Country&#123;name=&#x27;美国&#x27;&#125;, countryHashCode=356573597&#125;//sheep2 =Sheep&#123;name=&#x27;多利羊&#x27;, age=3, country=Country&#123;name=&#x27;美国&#x27;&#125;, countryHashCode=356573597&#125;//sheep3 =Sheep&#123;name=&#x27;多利羊&#x27;, age=3, country=Country&#123;name=&#x27;美国&#x27;&#125;, countryHashCode=356573597&#125;//sheep4 =Sheep&#123;name=&#x27;多利羊&#x27;, age=3, country=Country&#123;name=&#x27;美国&#x27;&#125;, countryHashCode=356573597&#125; 3 浅拷贝和深拷贝基本数据类型的成员变量： 浅拷贝：直接进行值传递，该属性值复制一份给新的对象。 深拷贝：直接进行值传递，该属性值复制一份给新的对象。 引用数据类型的成员变量： 浅拷贝：将该成员变量的引用值（内存地址）复制一份给新的对象。 深拷贝：创建一个新对象，赋值。 4 深拷贝123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//方法一：将 Sheep 的 clone 修改为如下@Overrideprotected Object clone() &#123; Sheep sheep = null; try &#123; sheep = (Sheep)super.clone(); //对象修改为可 clone sheep.setCountry((Country)this.country.clone()); &#125; catch (Exception e)&#123; System.out.println(e.getMessage()); &#125; return sheep;&#125;//输出：//sheep1 =Sheep&#123;name=&#x27;多利羊&#x27;, age=3, country=Country&#123;name=&#x27;美国&#x27;&#125;, countryHashCode=356573597&#125;//sheep2 =Sheep&#123;name=&#x27;多利羊&#x27;, age=3, country=Country&#123;name=&#x27;美国&#x27;&#125;, countryHashCode=1735600054&#125;//sheep3 =Sheep&#123;name=&#x27;多利羊&#x27;, age=3, country=Country&#123;name=&#x27;美国&#x27;&#125;, countryHashCode=21685669&#125;// =Sheep&#123;name=&#x27;多利羊&#x27;, age=3, country=Country&#123;name=&#x27;美国&#x27;&#125;, countryHashCode=2133927002&#125;//方法二：使用序列化public class DeepSheep implements Serializable, Cloneable&#123; private String name; private int age; public Country country; //对象, 克隆是会如何处理, 默认是浅拷贝 public DeepSheep(String name, int age, Country country) &#123; this.name = name; this.age = age; this.country = country; &#125; @Override protected Object clone() &#123; DeepSheep sheep = null; try &#123; sheep = deepClone(); //sheep = SerializationUtils.deepCopy(this); &#125;catch (Exception e)&#123; System.out.println(e.getMessage()); &#125; return sheep; &#125; public DeepSheep deepClone() throws IOException,ClassNotFoundException&#123; //将对象写入流中 ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); objectOutputStream.writeObject(this); //从流中取出 ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray()); ObjectInputStream objectInputStream = new ObjectInputStream(inputStream); return (DeepSheep)objectInputStream.readObject(); &#125; @Override public String toString() &#123; return &quot;Sheep&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, country=&quot; + country + &quot;, countryHashCode=&quot; + country.hashCode() + &#x27;&#125;&#x27;; &#125; //省略 getter/setter&#125;public class Client &#123; public static void main(String[] args) &#123; DeepSheep deepSheep = new DeepSheep(&quot;汤姆羊&quot;, 3,new Country(&quot;法国&quot;)); DeepSheep deepSheep1 = (DeepSheep)deepSheep.clone(); DeepSheep deepSheep2 = (DeepSheep)deepSheep.clone(); DeepSheep deepSheep3 = (DeepSheep)deepSheep.clone(); DeepSheep deepSheep4 = (DeepSheep)deepSheep.clone(); System.out.println(&quot;deepSheep1 =&quot; + deepSheep1 ); System.out.println(&quot;deepSheep2 =&quot; + deepSheep2 ); System.out.println(&quot;deepSheep3 =&quot; + deepSheep3 ); System.out.println(&quot;deepSheep4 =&quot; + deepSheep4 ); &#125;&#125;//deepSheep1 =Sheep&#123;name=&#x27;汤姆羊&#x27;, age=3, country=Country&#123;name=&#x27;法国&#x27;&#125;, countryHashCode=1531448569&#125;//deepSheep2 =Sheep&#123;name=&#x27;汤姆羊&#x27;, age=3, country=Country&#123;name=&#x27;法国&#x27;&#125;, countryHashCode=1867083167&#125;//deepSheep3 =Sheep&#123;name=&#x27;汤姆羊&#x27;, age=3, country=Country&#123;name=&#x27;法国&#x27;&#125;, countryHashCode=1915910607&#125;//deepSheep4 =Sheep&#123;name=&#x27;汤姆羊&#x27;, age=3, country=Country&#123;name=&#x27;法国&#x27;&#125;, countryHashCode=284720968&#125;//深拷贝工具类public class SerializationUtils &#123; public static &lt;T&gt; T deepCopy(T src) throws IOException, ClassNotFoundException &#123; ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); ObjectOutputStream out = new ObjectOutputStream(byteOut); out.writeObject(src); ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray()); ObjectInputStream in = new ObjectInputStream(byteIn); @SuppressWarnings(&quot;unchecked&quot;) T dest = (T) in.readObject(); return dest; &#125;&#125; 5 注意事项 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率 不用重新初始化对象，而是动态地获得对象运行时的状态 如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码 在实现深克隆的时候可能需要比较复杂的代码 缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了 ocp 原则，这点请同学们注意.","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"007.创建者模式_建造者模式","slug":"007-创建者模式-建造者模式","date":"2018-04-22T07:07:00.000Z","updated":"2024-03-12T01:06:15.821Z","comments":true,"path":"设计模式/007-创建者模式-建造者模式/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/007-%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 建造者模式 建造者模式（Builder Pattern） 又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们， 用户不需要知道内部的具体构建细节。 四个角色： Product（产品角色）： 一个具体的产品对象。 Builder（抽象建造者）： 创建一个 Product 对象的各个部件指定的 接口**&#x2F;**抽象类。 ConcreteBuilder（具体建造者）： 实现接口，构建和装配各个部件。 Director（指挥者）： 构建一个使用 Builder 接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。 2 例子使用建造者模式创建一台电脑。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//具体要构建的对象,电脑public class Computer &#123; private String cpu; private String memory; private String disk; public String getCpu() &#123; return cpu; &#125; public void setCpu(String cpu) &#123; this.cpu = cpu; &#125; public String getMemory() &#123; return memory; &#125; public void setMemory(String memory) &#123; this.memory = memory; &#125; public String getDisk() &#123; return disk; &#125; public void setDisk(String disk) &#123; this.disk = disk; &#125; @Override public String toString() &#123; return &quot;Computer&#123;&quot; + &quot;cpu=&#x27;&quot; + cpu + &#x27;\\&#x27;&#x27; + &quot;, memory=&#x27;&quot; + memory + &#x27;\\&#x27;&#x27; + &quot;, disk=&#x27;&quot; + disk + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125;//抽象接口来描述电脑构建和装配过程public interface ComputerBuilder &#123; ComputerBuilder buildCpu(String cpu); ComputerBuilder buildMemory(String memory); ComputerBuilder buildDisk(String disk); Computer build();&#125;//定义ComputerBuild接口的具体实现,实现构建方法和装配电脑的各个组件public class ComputerConcreteBuilder implements ComputerBuilder &#123; private final Computer computer = new Computer(); public ComputerBuilder buildCpu(String cpu) &#123; computer.setCpu(cpu); return this; &#125; public ComputerBuilder buildMemory(String memory) &#123; computer.setMemory(memory); return this; &#125; public ComputerBuilder buildDisk(String disk) &#123; computer.setDisk(disk); return this; &#125; public Computer build()&#123; return computer; &#125;&#125;public class TestComputer &#123; public static void main(String[] args) &#123; ComputerBuilder builder = new ComputerConcreteBuilder(); Computer computer = builder.buildCpu(&quot;AMD&quot;) .buildMemory(&quot;三星&quot;) .buildDisk(&quot;金士顿&quot;) .build(); System.out.println(computer);//Computer&#123;cpu=&#x27;AMD&#x27;, memory=&#x27;三星&#x27;, disk=&#x27;金士顿&#x27;&#125; &#125;&#125; 3 注意事项 客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象。 主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。 抽象工厂模式 VS 建造者模式 抽象工厂模式：实现对产品家族（一系列具有不同分类维度的产品组合）的创建，不需要关心构建过程，只关心什么产品由什么工厂生产即可。 建造者模式：要求按照指定的蓝图建造产，建造者模式更加关注与零件装配的顺序。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"005.创建者模式_工厂模式","slug":"005-创建者模式-工厂模式","date":"2018-04-22T07:06:00.000Z","updated":"2024-03-12T01:06:15.821Z","comments":true,"path":"设计模式/005-创建者模式-工厂模式/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/005-%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 工厂模式工厂模式是 Java 中最常用的设计模式之一，属于创建型模式。 2 简单工厂模式简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。 使用：定义了一个创建对象的类，由这个类来封装实例化对象的行为。 12345678910111213141516171819202122232425262728293031323334//鼠标工厂，专业生产鼠标，给参数 0，生产小米鼠标，给参数 1，生产华为鼠标。public interface Mouse &#123; void print();&#125;public class XMMouse implements Mouse &#123; @Override public void print() &#123; System.out.println(&quot;小米鼠标&quot;); &#125;&#125;public class HWMouse implements Mouse &#123; @Override public void print() &#123; System.out.println(&quot;华为鼠标&quot;); &#125;&#125;//简单工厂模式 又称 静态工厂模式public class MouseFactory &#123; public static Mouse createMouse(int type) &#123; Mouse mouse = null; if (type == 0) &#123; mouse = new XMMouse(); &#125; if (type == 1) &#123; mouse = new HWMouse(); &#125; return mouse; &#125;&#125; 优点： 不需要关心类的创建细节。 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 屏蔽产品的具体实现，调用者只关心产品的接口。 缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 2 工厂方法模式工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过工厂父类定义负责创建产品的公共接口，子类负责生产具体对象。 1234567891011121314151617181920212223242526/**** 把鼠标工厂抽象成一个类（接口）。* 小米鼠标工厂，继承它：小米鼠标。* 华为鼠标工厂，继承它：华为鼠标。***/public interface IMouseFactory &#123; Mouse createMouse();&#125;public class XMMouseFactory implements IMouseFactory &#123; @Override public Mouse createMouse() &#123; return new XMMouse(); &#125;&#125;public class HWMouseFactory implements IMouseFactory &#123; @Override public Mouse createMouse() &#123; return new HWMouse(); &#125;&#125; 优点：更符合开闭原则，增加一个产品类，则只需要实现其他具体的产品类和具体的工厂类即可；符合单一职责原则，每个工厂只负责生产对应的产品。 缺点：每增加一个产品，就需要实现对应的具体工厂类和具体产品类；每个产品需要有对应的具体工厂和具体产品类。 3 抽象工厂模式抽象工厂模式是围绕一个超级工厂创建其他工厂（提供一套标准），超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 123456789101112131415161718192021222324252627282930313233343536373839/**** 抽象工厂模式也就是不仅生产鼠标，同时生产键盘。也就是 PC 厂商是个父类，有生产鼠标，生产键盘两个接口。* 小米 PC 工厂继承抽象工厂：小米鼠标 + 小米键盘。* 华为 PC 工厂继承抽象工厂：华为鼠标 + 华为键盘。***/public interface IPCFactory &#123; Mouse createMouse(); Keybo createKeybo();&#125;public class XMPCFactory implements IPCFactory &#123; @Override public Mouse createMouse() &#123; return new XMMouse(); &#125; @Override public Keybo createKeybo() &#123; return new XMKeybo(); &#125;&#125;public class HWPCFactory implements IPCFactory &#123; @Override public Mouse createMouse() &#123; return new HWMouse(); &#125; @Override public Keybo createKeybo() &#123; return new HWKeybo(); &#125;&#125; 优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。 4 区别简单工厂： 就是有一个专门生产某个产品的类。 鼠标工厂，专业生产鼠标，给参数 0，生产小米鼠标，给参数 1，生产华为鼠标。 工厂方法（生产一个产品）： 把鼠标工厂抽象成一个类（接口）。 小米鼠标工厂，继承它：小米鼠标。 华为鼠标工厂，继承它：华为鼠标。 抽象工厂（生产多个产品）： 抽象工厂模式也就是不仅生产鼠标，同时生产键盘。也就是 PC 厂商是个父类，有生产鼠标，生产键盘两个接口。 小米 PC 工厂继承抽象工厂：小米鼠标 + 小米键盘。 华为 PC 工厂继承抽象工厂：华为鼠标 + 华为键盘。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"004.创建者模式_单例模式","slug":"004-创建者模式-单例模式","date":"2018-04-22T07:05:00.000Z","updated":"2024-03-12T01:06:15.821Z","comments":true,"path":"设计模式/004-创建者模式-单例模式/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/004-%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 单例模式保证在整个的软件系统中，对某个类只能存在一个对象实例， 并且该类只提供一个取得其对象实例的方法(静态方法)。 使用场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、session 工厂等)。 2 饿汉式**(静态常量)** -&gt; 推荐1234567891011//饿汉式（静态变量）public class Singleton01 &#123; private final static Singleton01 instance = new Singleton01(); private Singleton01() &#123; &#125; public static Singleton01 getInstance() &#123; return instance; &#125;&#125; 优点：写法简单，就是在类装载的时候就完成实例化，避免了线程同步问题。 缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果没有使用，则会造成内存的浪费。 3 饿汉式（静态代码块）-&gt; 推荐123456789101112131415//饿汉式（静态代码块）public class Singleton02 &#123; private static Singleton02 instance; static &#123; instance = new Singleton02(); &#125; private Singleton02() &#123; &#125; public static Singleton02 getInstance() &#123; return instance; &#125;&#125; 这种单例模式可用，但是可能造成内存浪费。 4 懒汉式(线程不安全)1234567891011121314//懒汉式（线程不安全）public class Singleton03 &#123; private static Singleton03 instance; private Singleton03() &#123; &#125; public static Singleton03 getInstance() &#123; if (instance == null) &#123; instance = new Singleton03(); &#125; return instance; &#125;&#125; 优点： Lazy Loading 的效果，只能在单线程下使用。 缺点：线程不安全。 5 懒汉式(线程安全，同步方法)1234567891011121314//懒汉式（线程安全,同步方法）public class Singleton04 &#123; private static Singleton04 instance; private Singleton04() &#123; &#125; public static synchronized Singleton04 getInstance() &#123; if (instance == null) &#123; instance = new Singleton04(); &#125; return instance; &#125;&#125; 优点：解决了线程安全问题。 缺点：效率低，每个线程在想获得类的实例时候，执行 getInstance() 方法都要进行同步。 6 懒汉式(线程安全，同步代码块)1234567891011121314151617//懒汉式（线程安全,同步代码块）public class Singleton05 &#123; private static Singleton05 instance; private Singleton05() &#123; &#125; public static Singleton05 getInstance() &#123; if (instance == null) &#123; synchronized (Singleton05.class) &#123; instance = new Singleton05(); &#125; &#125; return instance; &#125;&#125; 优点：解决了线程安全问题。 缺点：效率低，每个线程在想获得类的实例时候，执行 getInstance() 方法都要进行同步。 7 双重检查（DCL） -&gt; 推荐123456789101112131415161718//懒汉式（线程安全,同步代码块）public class Singleton06 &#123; private static volatile Singleton06 instance; private Singleton06() &#123; &#125; public static Singleton06 getInstance() &#123; if (instance == null) &#123; synchronized (Singleton06.class) &#123; if (instance == null) &#123; instance = new Singleton06(); &#125; &#125; &#125; return instance; &#125;&#125; 线程安全；延迟加载；效率较高。 8 静态内部类 -&gt; 推荐1234567891011121314//静态内部类完成， 推荐使用public class Singleton07 &#123; private Singleton07() &#123; &#125; public static class SingletonInstance &#123; private static final Singleton07 INSTANCE = new Singleton07(); &#125; public static Singleton07 getInstance() &#123; return SingletonInstance.INSTANCE; &#125;&#125; 线程安全，利用静态内部类特点实现延迟加载，效率高。 9 枚举 -&gt; 推荐1234//枚举public enum Singleton08 &#123; INSTANCE;&#125; 不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"003.UML","slug":"03-UML","date":"2018-04-22T07:04:00.000Z","updated":"2024-03-12T01:06:15.823Z","comments":true,"path":"设计模式/03-UML/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03-UML/","excerpt":"","text":"1 UML 图统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。 UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。 2 类图类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。它既用于应用程序的系统分类的一般概念建模，也用于详细建模，将模型转换成编程代码。类图也可用于数据建模。 2.2 表示方式 +：表示 public -：表示 private #：表示 protected 属性的完整表示方式是： 可见性 名称 ：类型 [ &#x3D; 缺省值] 方法的完整表示方式是： 可见性 名称(参数列表) [ ： 返回类型] 2.3 类与类的关系2.3.1 关联关系对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系。 单向关联 双向关联 自关联 2.3.2 聚合关系是关联关系的一种，是强的关联关系。聚合关系是整体和个体的关系。关联关系的两个类处于同一层次上，而聚合关系两个类处于不同的层次，一个是整体，一个是部分。 2.3.3 组合关系是关联关系的一种，是比聚合关系强的关系。它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期，组合关系不能共享。 2.3.4 依赖关系依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。 2.3.5 继承关系继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。 2.3.6 实现关系实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"002.设计模式简介","slug":"002-设计模式简介","date":"2018-04-22T07:03:00.000Z","updated":"2024-03-12T01:06:15.821Z","comments":true,"path":"设计模式/002-设计模式简介/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/002-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/","excerpt":"","text":"1 简介软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。 2 分类 创建型模式 描述“怎样创建对象”，它的主要特点是”将对象的创建与使用分离“，包括以下 5 种： 单例 原型 工厂方法 抽象工厂 建造者 结构型模式 描述如何将类或对象按某种布局组成更大的结构，包括以下 7 种： 代理 适配器 桥接 装饰 外观 享元 组合 行为型模式 描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责，包括以下 11 种： 模板方法 策略 命令 职责链 状态 观察者 中介者 迭代器 访问者 备忘录 解释器","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"001.设计模式七大原则","slug":"001-设计模式七大原则","date":"2018-04-22T07:01:00.000Z","updated":"2024-03-12T01:06:15.821Z","comments":true,"path":"设计模式/001-设计模式七大原则/","link":"","permalink":"http://wanke.fun/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/001-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/","excerpt":"","text":"1 设计模式的目的编写软件过程中，面临着来自耦合性、内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的挑战，设计模式是为了让程序，具有更好代码重用性、可读性、可扩展性、可靠性。 设计模式是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。 2 设计模式的七大原则2.1 单一职责原则一个类应该只负责一项职责。 2.2 接口隔离原则客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。 2.3 依赖倒置原则 高层模块不应该依赖低层模块，二者都应该依赖其抽象。 抽象不应该依赖细节，细节应该依赖抽象。 依赖倒转(倒置)的中心思想是面向接口编程。 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类。 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。 2.4 里式替换原则 子类中尽量不要重写父类的方法。 任何基类可以出现的地方，子类一定可以出现。 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖 来解决问题。 2.5 开闭原则 一个软件实体如类，**模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)**。用抽象构建框架，用实现扩展细节。 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。 最少知道原则，即一个类对自己依赖的类知道的越少越好。 2.6 迪米特原则 一个对象应该对其他对象保持最少的了解。 类与类关系越密切，耦合度越大。 又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。 2.7 合成复用原则 尽量使用合成&#x2F;聚合的方式，而不是使用继承。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"师学"},{"title":"白酒","slug":"白酒","date":"2018-02-22T14:49:00.000Z","updated":"2024-03-12T01:06:15.829Z","comments":true,"path":"酒/白酒/","link":"","permalink":"http://wanke.fun/%E9%85%92/%E7%99%BD%E9%85%92/","excerpt":"","text":"酱香型 红花郎10 53° 习酒 金质、银质 53° 赖茅传承蓝 53° 茅台王子酱香经典 53° 茅台王子黑金 53° 茅台汉酱 51° 茅台王子珍品 浓香型 百年牛栏山 53° 五粮春 45° 泸州老窖特曲 52° 剑南春水晶剑 52° 清香型 老白汾10 53° 黄盖玻汾 53° 汾酒青花20 53° 兼香型 白云边15 42° 凤香型 华山论剑20 52° 西凤6年 15年 馥郁香型 紫酒鬼","categories":[{"name":"酒","slug":"酒","permalink":"http://wanke.fun/categories/%E9%85%92/"}],"tags":[],"author":"师学"}],"categories":[{"name":"手游SDK","slug":"手游SDK","permalink":"http://wanke.fun/categories/%E6%89%8B%E6%B8%B8SDK/"},{"name":"爬虫","slug":"爬虫","permalink":"http://wanke.fun/categories/%E7%88%AC%E8%99%AB/"},{"name":"Gradle","slug":"Gradle","permalink":"http://wanke.fun/categories/Gradle/"},{"name":"bizhe","slug":"bizhe","permalink":"http://wanke.fun/categories/bizhe/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://wanke.fun/categories/Kotlin/"},{"name":"Android","slug":"Android","permalink":"http://wanke.fun/categories/Android/"},{"name":"源码分析","slug":"源码分析","permalink":"http://wanke.fun/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Android","slug":"源码分析/Android","permalink":"http://wanke.fun/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android/"},{"name":"源码分析","slug":"Android/源码分析","permalink":"http://wanke.fun/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Java","slug":"Java","permalink":"http://wanke.fun/categories/Java/"},{"name":"concurrent","slug":"Java/concurrent","permalink":"http://wanke.fun/categories/Java/concurrent/"},{"name":"设计模式","slug":"设计模式","permalink":"http://wanke.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Jvm","slug":"Jvm","permalink":"http://wanke.fun/categories/Jvm/"},{"name":"Java","slug":"Jvm/Java","permalink":"http://wanke.fun/categories/Jvm/Java/"},{"name":"Java","slug":"Android/Java","permalink":"http://wanke.fun/categories/Android/Java/"},{"name":"OpenGL","slug":"OpenGL","permalink":"http://wanke.fun/categories/OpenGL/"},{"name":"dlib","slug":"Android/dlib","permalink":"http://wanke.fun/categories/Android/dlib/"},{"name":"DIP","slug":"Android/dlib/DIP","permalink":"http://wanke.fun/categories/Android/dlib/DIP/"},{"name":"DIP","slug":"DIP","permalink":"http://wanke.fun/categories/DIP/"},{"name":"mvp","slug":"Android/mvp","permalink":"http://wanke.fun/categories/Android/mvp/"},{"name":"JavaConcurrent","slug":"Java/JavaConcurrent","permalink":"http://wanke.fun/categories/Java/JavaConcurrent/"},{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://wanke.fun/categories/FFmpeg/"},{"name":"Flutter","slug":"Flutter","permalink":"http://wanke.fun/categories/Flutter/"},{"name":"Note2","slug":"Note2","permalink":"http://wanke.fun/categories/Note2/"},{"name":"Nio","slug":"Nio","permalink":"http://wanke.fun/categories/Nio/"},{"name":"pr","slug":"pr","permalink":"http://wanke.fun/categories/pr/"},{"name":"ReactNative","slug":"ReactNative","permalink":"http://wanke.fun/categories/ReactNative/"},{"name":"jdhai","slug":"jdhai","permalink":"http://wanke.fun/categories/jdhai/"},{"name":"javascript","slug":"jdhai/javascript","permalink":"http://wanke.fun/categories/jdhai/javascript/"},{"name":"跨平台","slug":"jdhai/javascript/跨平台","permalink":"http://wanke.fun/categories/jdhai/javascript/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"},{"name":"剑指系列","slug":"剑指系列","permalink":"http://wanke.fun/categories/%E5%89%91%E6%8C%87%E7%B3%BB%E5%88%97/"},{"name":"杂谈","slug":"杂谈","permalink":"http://wanke.fun/categories/%E6%9D%82%E8%B0%88/"},{"name":"酒","slug":"酒","permalink":"http://wanke.fun/categories/%E9%85%92/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://wanke.fun/tags/Kotlin/"},{"name":"kotlin","slug":"kotlin","permalink":"http://wanke.fun/tags/kotlin/"},{"name":"网络","slug":"网络","permalink":"http://wanke.fun/tags/%E7%BD%91%E7%BB%9C/"}]}